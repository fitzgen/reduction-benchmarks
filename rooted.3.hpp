# 2106 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/x86_64-redhat-linux/bits/c++config.h" 3
namespace std {   typedef long unsigned int size_t;   typedef long int ptrdiff_t;   typedef decltype(nullptr) nullptr_t; }
# 2128 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/x86_64-redhat-linux/bits/c++config.h" 3
namespace std {   inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { } }
 namespace __gnu_cxx {   inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { } }
# 2414 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/x86_64-redhat-linux/bits/c++config.h" 3
# 51 "/usr/local/bin/../lib/clang/3.9.1/include/stddef.h" 3
typedef long int ptrdiff_t;
# 62 "/usr/local/bin/../lib/clang/3.9.1/include/stddef.h" 3
typedef long unsigned int size_t;
# 118 "/usr/local/bin/../lib/clang/3.9.1/include/stddef.h" 3
# 1 "/usr/local/bin/../lib/clang/3.9.1/include/__stddef_max_align_t.h" 1 3
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/stdint.h" 2 3 4
typedef signed char int8_t;
 typedef short int int16_t;
 typedef int int32_t;
 typedef long int int64_t;
 typedef unsigned char uint8_t;
 typedef unsigned short int uint16_t;
 typedef unsigned int uint32_t;
 typedef unsigned long int uint64_t;
# 65 "/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
 typedef short int int_least16_t;
 typedef int int_least32_t;
 typedef long int int_least64_t;
 typedef unsigned char uint_least8_t;
 typedef unsigned short int uint_least16_t;
 typedef unsigned int uint_least32_t;
 typedef unsigned long int uint_least64_t;
# 90 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;
 typedef long int int_fast16_t;
 typedef long int int_fast32_t;
 typedef long int int_fast64_t;
# 103 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;
 typedef unsigned long int uint_fast16_t;
 typedef unsigned long int uint_fast32_t;
 typedef unsigned long int uint_fast64_t;
# 119 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;
 typedef unsigned long int uintptr_t;
# 134 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
 typedef unsigned long int uintmax_t;
# 1 "/usr/local/bin/../lib/clang/3.9.1/include/stddef.h" 1 3
# 48 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Assertions.h" 2
# 1 "/usr/include/stdio.h" 1 3 4
# 29 "/usr/include/stdio.h" 3 4
extern "C" { 
# 1 "/usr/local/bin/../lib/clang/3.9.1/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
# 27 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/types.h" 2 3 4
typedef unsigned char __u_char; typedef unsigned short int __u_short; typedef unsigned int __u_int; typedef unsigned long int __u_long; typedef signed char __int8_t; typedef unsigned char __uint8_t; typedef signed short int __int16_t; typedef unsigned short int __uint16_t; typedef signed int __int32_t; typedef unsigned int __uint32_t; typedef signed long int __int64_t; typedef unsigned long int __uint64_t; typedef long int __quad_t; typedef unsigned long int __u_quad_t; 
# 121 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 122 "/usr/include/bits/types.h" 2 3 4
typedef unsigned long int __dev_t; typedef unsigned int __uid_t; typedef unsigned int __gid_t; typedef unsigned long int __ino_t; typedef unsigned long int __ino64_t; typedef unsigned int __mode_t; typedef unsigned long int __nlink_t; typedef long int __off_t; typedef long int __off64_t; typedef int __pid_t; typedef struct { int __val[2]; } __fsid_t; typedef long int __clock_t; typedef unsigned long int __rlim_t; typedef unsigned long int __rlim64_t; typedef unsigned int __id_t; typedef long int __time_t; typedef unsigned int __useconds_t; typedef long int __suseconds_t; typedef int __daddr_t; typedef int __key_t; typedef int __clockid_t; typedef void * __timer_t; typedef long int __blksize_t; typedef long int __blkcnt_t; typedef long int __blkcnt64_t; typedef unsigned long int __fsblkcnt_t; typedef unsigned long int __fsblkcnt64_t; typedef unsigned long int __fsfilcnt_t; typedef unsigned long int __fsfilcnt64_t; typedef long int __fsword_t; typedef long int __ssize_t; typedef long int __syscall_slong_t; typedef unsigned long int __syscall_ulong_t; typedef __off64_t __loff_t; typedef __quad_t *__qaddr_t; typedef char *__caddr_t; typedef long int __intptr_t; typedef unsigned int __socklen_t; 
# 36 "/usr/include/stdio.h" 2 3 4
struct _IO_FILE; typedef struct _IO_FILE FILE; 
# 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE; 
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 31 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/local/bin/../lib/clang/3.9.1/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 82 "/usr/include/wchar.h" 3 4
typedef struct {   int __count;   union   {     unsigned int __wch;     char __wchb[4];   } __value; } __mbstate_t; 
typedef __builtin_va_list va_list; 
# 50 "/usr/local/bin/../lib/clang/3.9.1/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list; 
# 50 "/usr/include/libio.h" 2 3 4
# 144 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE; typedef void _IO_lock_t; struct _IO_marker {   struct _IO_marker *_next;   struct _IO_FILE *_sbuf;   int _pos; 
# 173 "/usr/include/libio.h" 3 4
}; enum __codecvt_result {   __codecvt_ok,   __codecvt_partial,   __codecvt_error,   __codecvt_noconv }; 
# 241 "/usr/include/libio.h" 3 4
struct _IO_FILE {   int _flags;   char* _IO_read_ptr;   char* _IO_read_end;   char* _IO_read_base;   char* _IO_write_base;   char* _IO_write_ptr;   char* _IO_write_end;   char* _IO_buf_base;   char* _IO_buf_end;   char *_IO_save_base;   char *_IO_backup_base;   char *_IO_save_end;   struct _IO_marker *_markers;   struct _IO_FILE *_chain;   int _fileno;   int _flags2;   __off_t _old_offset;   unsigned short _cur_column;   signed char _vtable_offset;   char _shortbuf[1];   _IO_lock_t *_lock; 
# 289 "/usr/include/libio.h" 3 4
  __off64_t _offset;   void *__pad1;   void *__pad2;   void *__pad3;   void *__pad4;   size_t __pad5;   int _mode;   char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)]; }; struct _IO_FILE_plus; extern struct _IO_FILE_plus _IO_2_1_stdin_; extern struct _IO_FILE_plus _IO_2_1_stdout_; extern struct _IO_FILE_plus _IO_2_1_stderr_; 
}
# 49 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Assertions.h" 2
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/stdlib.h" 1 3
# 36 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/stdlib.h" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cstdlib" 1 3
# 40 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cstdlib" 3
# 75 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/usr/local/bin/../lib/clang/3.9.1/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4
extern "C" { 
# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 43 "/usr/include/stdlib.h" 2 3 4
# 58 "/usr/include/stdlib.h" 3 4
typedef struct   {     int quot;     int rem;   } div_t; typedef struct   {     long int quot;     long int rem;   } ldiv_t; __extension__ typedef struct   {     long long int quot;     long long int rem;   } lldiv_t; 
# 100 "/usr/include/stdlib.h" 3 4
 ;  ;  ;  ;  ; ; ; ; ; ; ; ; ; ; 
# 196 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/xlocale.h" 1 3 4
# 27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct {   struct __locale_data *__locales[13];   const unsigned short int *__ctype_b;   const int *__ctype_tolower;   const int *__ctype_toupper;   const char *__names[13]; } *__locale_t; typedef __locale_t locale_t; 
extern "C" { typedef __u_char u_char; typedef __u_short u_short; typedef __u_int u_int; typedef __u_long u_long; typedef __quad_t quad_t; typedef __u_quad_t u_quad_t; typedef __fsid_t fsid_t; typedef __loff_t loff_t; typedef __ino_t ino_t; typedef __ino64_t ino64_t; typedef __dev_t dev_t; typedef __gid_t gid_t; typedef __mode_t mode_t; typedef __nlink_t nlink_t; typedef __uid_t uid_t; 
# 98 "/usr/include/sys/types.h" 3 4
typedef __pid_t pid_t; typedef __id_t id_t; 
# 115 "/usr/include/sys/types.h" 3 4
typedef __daddr_t daddr_t; typedef __caddr_t caddr_t; typedef __key_t key_t; 
# 132 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/select.h" 1 3 4
# 30 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 22 "/usr/include/bits/select.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 23 "/usr/include/bits/select.h" 2 3 4
extern "C" { 
# 108 "/usr/include/sys/select.h" 3 4
; 
# 120 "/usr/include/sys/select.h" 3 4
; 
# 133 "/usr/include/sys/select.h" 3 4
} 
# 223 "/usr/include/sys/types.h" 2 3 4
typedef __blksize_t blksize_t; typedef __blkcnt_t blkcnt_t; typedef __fsblkcnt_t fsblkcnt_t; typedef __fsfilcnt_t fsfilcnt_t; 
# 262 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t; typedef __fsblkcnt64_t fsblkcnt64_t; typedef __fsfilcnt64_t fsfilcnt64_t; 
# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 21 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 22 "/usr/include/bits/pthreadtypes.h" 2 3 4
# 60 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t; union pthread_attr_t {   char __size[56];   long int __align; }; typedef union pthread_attr_t pthread_attr_t; typedef struct __pthread_internal_list {   struct __pthread_internal_list *__prev;   struct __pthread_internal_list *__next; } __pthread_list_t; 
# 90 "/usr/include/bits/pthreadtypes.h" 3 4
typedef union {   struct __pthread_mutex_s   {     int __lock;     unsigned int __count;     int __owner;     unsigned int __nusers;     int __kind;     short __spins;     short __elision;     __pthread_list_t __list; 
# 125 "/usr/include/bits/pthreadtypes.h" 3 4
  } __data;   char __size[40];   long int __align; } pthread_mutex_t; typedef union {   char __size[4];   int __align; } pthread_mutexattr_t; typedef union {   struct   {     int __lock;     unsigned int __futex;     __extension__ unsigned long long int __total_seq;     __extension__ unsigned long long int __wakeup_seq;     __extension__ unsigned long long int __woken_seq;     void *__mutex;     unsigned int __nwaiters;     unsigned int __broadcast_seq;   } __data;   char __size[48];   __extension__ long long int __align; } pthread_cond_t; typedef union {   char __size[4];   int __align; } pthread_condattr_t; typedef unsigned int pthread_key_t; typedef int pthread_once_t; typedef union {   struct   {     int __lock;     unsigned int __nr_readers;     unsigned int __readers_wakeup;     unsigned int __writer_wakeup;     unsigned int __nr_readers_queued;     unsigned int __nr_writers_queued;     int __writer;     int __shared;     signed char __rwelision;     unsigned char __pad1[7];     unsigned long int __pad2;     unsigned int __flags;   } __data; 
# 220 "/usr/include/bits/pthreadtypes.h" 3 4
  char __size[56];   long int __align; } pthread_rwlock_t; typedef union {   char __size[8];   long int __align; } pthread_rwlockattr_t; typedef volatile int pthread_spinlock_t; typedef union {   char __size[32];   long int __align; } pthread_barrier_t; typedef union {   char __size[4];   int __align; } pthread_barrierattr_t; 
# 271 "/usr/include/sys/types.h" 2 3 4
} 
# 276 "/usr/include/stdlib.h" 2 3 4
; ; extern char *initstate (unsigned int __seed, char *__statebuf,    size_t __statelen) throw () __attribute__ ((__nonnull__ (2))); extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1))); struct random_data   {     int32_t *fptr;     int32_t *rptr;     int32_t *state;     int rand_type;     int rand_deg;     int rand_sep;     int32_t *end_ptr;   }; extern int random_r (struct random_data *__restrict __buf,        int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2))); extern int srandom_r (unsigned int __seed, struct random_data *__buf)      throw () __attribute__ ((__nonnull__ (2))); extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,    size_t __statelen,    struct random_data *__restrict __buf)      throw () __attribute__ ((__nonnull__ (2, 4))); extern int setstate_r (char *__restrict __statebuf,          struct random_data *__restrict __buf)      throw () __attribute__ ((__nonnull__ (1, 2))); extern int rand (void) throw (); extern void srand (unsigned int __seed) throw (); ; ; ; ; ; ; ; ; ; ; struct drand48_data   {     unsigned short int __x[3];     unsigned short int __old_x[3];     unsigned short int __c;     unsigned short int __init;     __extension__ unsigned long long int __a;   }; ; ; ; ; ; ; ; ; ; 
# 427 "/usr/include/stdlib.h" 3 4
 ;  ; 
# 441 "/usr/include/stdlib.h" 3 4
# 454 "/usr/include/stdlib.h" 2 3 4
 ;  ;  ; extern void abort (void) throw () __attribute__ ((__noreturn__)); ; ; 
# 496 "/usr/include/stdlib.h" 3 4
; ; ; ;  ;  ; ; ; ; ; 
# 567 "/usr/include/stdlib.h" 3 4
; 
# 922 "/usr/include/stdlib.h" 2 3 4
# 934 "/usr/include/stdlib.h" 3 4
}
# 76 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cstdlib" 2 3
# 118 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cstdlib" 3
extern "C++" { namespace std __attribute__ ((__visibility__ ("default"))) {   using ::div_t;   using ::ldiv_t;   using ::abort;                                                               using ::rand;      using ::srand;                               
# 202 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cstdlib" 3
} 
# 215 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {   using ::lldiv_t;              
# 247 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cstdlib" 3
               } namespace std {   using ::__gnu_cxx::lldiv_t;                            } }
# 50 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Assertions.h" 2
# 63 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Assertions.h"
# 1 "/usr/include/signal.h" 1 3 4
# 30 "/usr/include/signal.h" 3 4
extern "C" { 
# 1 "/usr/include/bits/sigset.h" 1 3 4
; ; ; ; ; ; 
# 1 "/usr/include/bits/sigthread.h" 1 3 4
# 30 "/usr/include/bits/sigthread.h" 3 4
; ; ; 
# 363 "/usr/include/signal.h" 2 3 4
; ; }
# 64 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Assertions.h" 2
# 141 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Assertions.h"
extern "C" { 
# 151 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Assertions.h"
__attribute__ ((__unused__)) static __attribute__ ((cold)) __attribute__((noinline)) void MOZ_ReportAssertionFailure(const char* aStr, const char* aFilename, int aLine) ; __attribute__ ((__unused__)) static __attribute__ ((cold)) __attribute__((noinline)) void MOZ_ReportCrash(const char* aStr, const char* aFilename, int aLine) ; 
# 287 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Assertions.h"
         ; static const size_t sPrintfMaxArgs = 4; static const size_t sPrintfCrashReasonSize = 1024;          ; 
# 326 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Assertions.h"
}
# 375 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Assertions.h"
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h" 1
# 20 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
# 1 "/usr/include/wchar.h" 1 3 4
# 51 "/usr/include/wchar.h" 3 4
# 1 "/usr/local/bin/../lib/clang/3.9.1/include/stddef.h" 1 3 4
# 132 "/usr/local/bin/../lib/clang/3.9.1/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 52 "/usr/include/wchar.h" 2 3 4
# 106 "/usr/include/wchar.h" 3 4
typedef __mbstate_t mbstate_t;
# 132 "/usr/include/wchar.h" 3 4
extern "C" { struct tm; 
# 147 "/usr/include/wchar.h" 3 4
; ; ; ; ; ; ; ; ; ; ; ; 
# 269 "/usr/include/wchar.h" 3 4
; 
# 280 "/usr/include/wchar.h" 3 4
; ; extern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__)); 
# 302 "/usr/include/wchar.h" 3 4
extern wchar_t *wcswcs (const wchar_t *__haystack, const wchar_t *__needle)      throw () __attribute__ ((__pure__)); extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)      throw () __attribute__ ((__pure__)); 
# 323 "/usr/include/wchar.h" 3 4
extern wchar_t *wmemchr (const wchar_t *__s, wchar_t __c, size_t __n)      throw () __attribute__ ((__pure__)); extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)      throw () __attribute__ ((__pure__)); extern wchar_t *wmemcpy (wchar_t *__restrict __s1,     const wchar_t *__restrict __s2, size_t __n) throw (); extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)      throw (); extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw (); ; ; ; ; ; ; ; ; 
# 411 "/usr/include/wchar.h" 3 4
; extern size_t wcsrtombs (char *__restrict __dst,     const wchar_t **__restrict __src, size_t __len,     mbstate_t *__restrict __ps) throw (); extern size_t mbsnrtowcs (wchar_t *__restrict __dst,      const char **__restrict __src, size_t __nmc,      size_t __len, mbstate_t *__restrict __ps) throw (); extern size_t wcsnrtombs (char *__restrict __dst,      const wchar_t **__restrict __src,      size_t __nwc, size_t __len,      mbstate_t *__restrict __ps) throw (); extern int wcwidth (wchar_t __c) throw (); ; ; ; ; ; ; ; ; ; ; 
# 533 "/usr/include/wchar.h" 3 4
; ; ; ; ; ; ; ; ; ; ;                                                             ;                                                             ;  ;                                                             ;                                                             ; extern int vswprintf (wchar_t *__restrict __s, size_t __n,         const wchar_t *__restrict __format,         __gnuc_va_list __arg)      throw () ;                                                            ;                                                            ;  ; 
# 692 "/usr/include/wchar.h" 3 4
                                                           ;                                                            ;  ; 
# 748 "/usr/include/wchar.h" 3 4
; extern wint_t getwc (__FILE *__stream); ; ; ; ; ; ; ; 
# 804 "/usr/include/wchar.h" 3 4
; ; ; ; 
# 830 "/usr/include/wchar.h" 3 4
; ; 
# 840 "/usr/include/wchar.h" 3 4
; ; ; ; 
# 894 "/usr/include/wchar.h" 3 4
}
# 21 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h" 2
namespace mozilla { template<typename> struct RemoveCV; template<typename> struct AddRvalueReference; 
# 37 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> typename AddRvalueReference<T>::Type DeclVal(); template<typename T, T Value> struct IntegralConstant {   static constexpr T value = Value;   typedef T ValueType;   typedef IntegralConstant<T, Value> Type; }; typedef IntegralConstant<bool, true> TrueType; typedef IntegralConstant<bool, false> FalseType; namespace detail { template<typename T> struct IsVoidHelper : FalseType {}; template<> struct IsVoidHelper<void> : TrueType {}; } 
# 80 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsVoid : detail::IsVoidHelper<typename RemoveCV<T>::Type> {}; namespace detail { template <typename T> struct IsIntegralHelper : FalseType {}; template<> struct IsIntegralHelper<char> : TrueType {}; template<> struct IsIntegralHelper<signed char> : TrueType {}; template<> struct IsIntegralHelper<unsigned char> : TrueType {}; template<> struct IsIntegralHelper<short> : TrueType {}; template<> struct IsIntegralHelper<unsigned short> : TrueType {}; template<> struct IsIntegralHelper<int> : TrueType {}; template<> struct IsIntegralHelper<unsigned int> : TrueType {}; template<> struct IsIntegralHelper<long> : TrueType {}; template<> struct IsIntegralHelper<unsigned long> : TrueType {}; template<> struct IsIntegralHelper<long long> : TrueType {}; template<> struct IsIntegralHelper<unsigned long long> : TrueType {}; template<> struct IsIntegralHelper<bool> : TrueType {}; template<> struct IsIntegralHelper<wchar_t> : TrueType {}; template<> struct IsIntegralHelper<char16_t> : TrueType {}; } 
# 114 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsIntegral : detail::IsIntegralHelper<typename RemoveCV<T>::Type> {}; template<typename T, typename U> struct IsSame; namespace detail { template<typename T> struct IsFloatingPointHelper   : IntegralConstant<bool,                      IsSame<T, float>::value ||                      IsSame<T, double>::value ||                      IsSame<T, long double>::value> {}; } 
# 142 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsFloatingPoint   : detail::IsFloatingPointHelper<typename RemoveCV<T>::Type> {}; namespace detail { template<typename T> struct IsArrayHelper : FalseType {}; template<typename T, decltype(sizeof(1)) N> struct IsArrayHelper<T[N]> : TrueType {}; template<typename T> struct IsArrayHelper<T[]> : TrueType {}; } 
# 168 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsArray : detail::IsArrayHelper<typename RemoveCV<T>::Type> {}; namespace detail { template<typename T> struct IsFunPtr; template<typename> struct IsFunPtr   : public FalseType {}; template<typename Result, typename... ArgTypes> struct IsFunPtr<Result(*)(ArgTypes...)>   : public TrueType {}; }; 
# 201 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsFunction   : public detail::IsFunPtr<typename RemoveCV<T>::Type *> {}; namespace detail { template<typename T> struct IsPointerHelper : FalseType {}; template<typename T> struct IsPointerHelper<T*> : TrueType {}; } 
# 231 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsPointer : detail::IsPointerHelper<typename RemoveCV<T>::Type> {}; 
# 246 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsLvalueReference : FalseType {}; template<typename T> struct IsLvalueReference<T&> : TrueType {}; 
# 263 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsRvalueReference : FalseType {}; template<typename T> struct IsRvalueReference<T&&> : TrueType {}; namespace detail { template<typename T> struct IsEnumHelper   : IntegralConstant<bool, __is_enum(T)> {}; } 
# 286 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsEnum   : detail::IsEnumHelper<typename RemoveCV<T>::Type> {}; namespace detail { template<typename T> struct IsClassHelper   : IntegralConstant<bool, __is_class(T)> {}; } 
# 313 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsClass   : detail::IsClassHelper<typename RemoveCV<T>::Type> {}; 
# 334 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsReference   : IntegralConstant<bool,                      IsLvalueReference<T>::value || IsRvalueReference<T>::value> {}; 
# 348 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsArithmetic   : IntegralConstant<bool, IsIntegral<T>::value || IsFloatingPoint<T>::value> {}; namespace detail { template<typename T> struct IsMemberPointerHelper : FalseType {}; template<typename T, typename U> struct IsMemberPointerHelper<T U::*> : TrueType {}; } 
# 370 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsMemberPointer   : detail::IsMemberPointerHelper<typename RemoveCV<T>::Type> {}; 
# 382 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsScalar   : IntegralConstant<bool, IsArithmetic<T>::value || IsEnum<T>::value ||                      IsPointer<T>::value || IsMemberPointer<T>::value> {}; 
# 397 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsConst : FalseType {}; template<typename T> struct IsConst<const T> : TrueType {}; 
# 410 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsVolatile : FalseType {}; template<typename T> struct IsVolatile<volatile T> : TrueType {}; 
# 424 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsPod : public FalseType {}; template<> struct IsPod<char> : TrueType {}; template<> struct IsPod<signed char> : TrueType {}; template<> struct IsPod<unsigned char> : TrueType {}; template<> struct IsPod<short> : TrueType {}; template<> struct IsPod<unsigned short> : TrueType {}; template<> struct IsPod<int> : TrueType {}; template<> struct IsPod<unsigned int> : TrueType {}; template<> struct IsPod<long> : TrueType {}; template<> struct IsPod<unsigned long> : TrueType {}; template<> struct IsPod<long long> : TrueType {}; template<> struct IsPod<unsigned long long> : TrueType {}; template<> struct IsPod<bool> : TrueType {}; template<> struct IsPod<float> : TrueType {}; template<> struct IsPod<double> : TrueType {}; template<> struct IsPod<wchar_t> : TrueType {}; template<> struct IsPod<char16_t> : TrueType {}; template<typename T> struct IsPod<T*> : TrueType {}; namespace detail { template<typename T> struct IsEmptyHelper   : IntegralConstant<bool, IsClass<T>::value && __is_empty(T)> {}; } 
# 498 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsEmpty : detail::IsEmptyHelper<typename RemoveCV<T>::Type> {}; namespace detail { template<typename T,          bool = IsFloatingPoint<T>::value,          bool = IsIntegral<T>::value,          typename NoCV = typename RemoveCV<T>::Type> struct IsSignedHelper; template<typename T, typename NoCV> struct IsSignedHelper<T, true, false, NoCV> : TrueType {}; template<typename T, typename NoCV> struct IsSignedHelper<T, false, true, NoCV>   : IntegralConstant<bool, bool(NoCV(-1) < NoCV(1))> {}; template<typename T, typename NoCV> struct IsSignedHelper<T, false, false, NoCV> : FalseType {}; } 
# 536 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsSigned : detail::IsSignedHelper<T> {}; namespace detail { template<typename T,          bool = IsFloatingPoint<T>::value,          bool = IsIntegral<T>::value,          typename NoCV = typename RemoveCV<T>::Type> struct IsUnsignedHelper; template<typename T, typename NoCV> struct IsUnsignedHelper<T, true, false, NoCV> : FalseType {}; template<typename T, typename NoCV> struct IsUnsignedHelper<T, false, true, NoCV>   : IntegralConstant<bool,                      (IsSame<NoCV, bool>::value || bool(NoCV(1) < NoCV(-1)))> {}; template<typename T, typename NoCV> struct IsUnsignedHelper<T, false, false, NoCV> : FalseType {}; } 
# 572 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsUnsigned : detail::IsUnsignedHelper<T> {}; namespace detail { struct DoIsDefaultConstructibleImpl {   template<typename T, typename = decltype(T())>   static TrueType test(int);   template<typename T>   static FalseType test(...); }; template<typename T> struct IsDefaultConstructibleImpl : public DoIsDefaultConstructibleImpl {   typedef decltype(test<T>(0)) Type; }; } 
# 611 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsDefaultConstructible   : public detail::IsDefaultConstructibleImpl<T>::Type {}; namespace detail { struct DoIsDestructibleImpl {   template<typename T, typename = decltype(DeclVal<T&>().~T())>   static TrueType test(int);   template<typename T>   static FalseType test(...); }; template<typename T> struct IsDestructibleImpl : public DoIsDestructibleImpl {   typedef decltype(test<T>(0)) Type; }; } 
# 645 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct IsDestructible : public detail::IsDestructibleImpl<T>::Type {}; 
# 662 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T, typename U> struct IsSame : FalseType {}; template<typename T> struct IsSame<T, T> : TrueType {}; namespace detail { template<class Base, class Derived> struct BaseOfTester : IntegralConstant<bool, __is_base_of(Base, Derived)> {}; 
# 727 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
} 
# 741 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<class Base, class Derived> struct IsBaseOf   : IntegralConstant<bool, detail::BaseOfTester<Base, Derived>::value> {}; namespace detail { template<typename From, typename To> struct ConvertibleTester { private:   template<typename To1>   static char test_helper(To1);   template<typename From1, typename To1>   static decltype(test_helper<To1>(DeclVal<From1>())) test(int);   template<typename From1, typename To1>   static int test(...); public:   static const bool value =     sizeof(test<From, To>(0)) == sizeof(char); }; } 
# 793 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename From, typename To> struct IsConvertible   : IntegralConstant<bool, detail::ConvertibleTester<From, To>::value> {}; template<typename B> struct IsConvertible<void, B>   : IntegralConstant<bool, IsVoid<B>::value> {}; template<typename A> struct IsConvertible<A, void>   : IntegralConstant<bool, IsVoid<A>::value> {}; template<> struct IsConvertible<void, void>   : TrueType {}; 
# 825 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct RemoveConst {   typedef T Type; }; template<typename T> struct RemoveConst<const T> {   typedef T Type; }; 
# 845 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct RemoveVolatile {   typedef T Type; }; template<typename T> struct RemoveVolatile<volatile T> {   typedef T Type; }; 
# 865 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct RemoveCV {   typedef typename RemoveConst<typename RemoveVolatile<T>::Type>::Type Type; }; 
# 881 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct RemoveReference {   typedef T Type; }; template<typename T> struct RemoveReference<T&> {   typedef T Type; }; template<typename T> struct RemoveReference<T&&> {   typedef T Type; }; template<bool Condition, typename A, typename B> struct Conditional; namespace detail { enum Voidness { TIsVoid, TIsNotVoid }; template<typename T, Voidness V = IsVoid<T>::value ? TIsVoid : TIsNotVoid> struct AddLvalueReferenceHelper; template<typename T> struct AddLvalueReferenceHelper<T, TIsVoid> {   typedef void Type; }; template<typename T> struct AddLvalueReferenceHelper<T, TIsNotVoid> {   typedef T& Type; }; } 
# 937 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct AddLvalueReference   : detail::AddLvalueReferenceHelper<T> {}; namespace detail { template<typename T, Voidness V = IsVoid<T>::value ? TIsVoid : TIsNotVoid> struct AddRvalueReferenceHelper; template<typename T> struct AddRvalueReferenceHelper<T, TIsVoid> {   typedef void Type; }; template<typename T> struct AddRvalueReferenceHelper<T, TIsNotVoid> {   typedef T&& Type; }; } 
# 976 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct AddRvalueReference   : detail::AddRvalueReferenceHelper<T> {}; template<bool B, typename T = void> struct EnableIf; namespace detail { template<bool MakeConst, typename T> struct WithC : Conditional<MakeConst, const T, T> {}; template<bool MakeVolatile, typename T> struct WithV : Conditional<MakeVolatile, volatile T, T> {}; template<bool MakeConst, bool MakeVolatile, typename T> struct WithCV : WithC<MakeConst, typename WithV<MakeVolatile, T>::Type> {}; template<typename T> struct CorrespondingSigned; template<> struct CorrespondingSigned<char> { typedef signed char Type; }; template<> struct CorrespondingSigned<unsigned char> { typedef signed char Type; }; template<> struct CorrespondingSigned<unsigned short> { typedef short Type; }; template<> struct CorrespondingSigned<unsigned int> { typedef int Type; }; template<> struct CorrespondingSigned<unsigned long> { typedef long Type; }; template<> struct CorrespondingSigned<unsigned long long> { typedef long long Type; }; template<typename T,          typename CVRemoved = typename RemoveCV<T>::Type,          bool IsSignedIntegerType = IsSigned<CVRemoved>::value &&                                     !IsSame<char, CVRemoved>::value> struct MakeSigned; template<typename T, typename CVRemoved> struct MakeSigned<T, CVRemoved, true> {   typedef T Type; }; template<typename T, typename CVRemoved> struct MakeSigned<T, CVRemoved, false>   : WithCV<IsConst<T>::value, IsVolatile<T>::value,            typename CorrespondingSigned<CVRemoved>::Type> {}; } 
# 1059 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct MakeSigned   : EnableIf<IsIntegral<T>::value &&              !IsSame<bool, typename RemoveCV<T>::Type>::value,              typename detail::MakeSigned<T>             >::Type {}; namespace detail { template<typename T> struct CorrespondingUnsigned; template<> struct CorrespondingUnsigned<char> { typedef unsigned char Type; }; template<> struct CorrespondingUnsigned<signed char> { typedef unsigned char Type; }; template<> struct CorrespondingUnsigned<short> { typedef unsigned short Type; }; template<> struct CorrespondingUnsigned<int> { typedef unsigned int Type; }; template<> struct CorrespondingUnsigned<long> { typedef unsigned long Type; }; template<> struct CorrespondingUnsigned<long long> { typedef unsigned long long Type; }; template<typename T,          typename CVRemoved = typename RemoveCV<T>::Type,          bool IsUnsignedIntegerType = IsUnsigned<CVRemoved>::value &&                                       !IsSame<char, CVRemoved>::value> struct MakeUnsigned; template<typename T, typename CVRemoved> struct MakeUnsigned<T, CVRemoved, true> {   typedef T Type; }; template<typename T, typename CVRemoved> struct MakeUnsigned<T, CVRemoved, false>   : WithCV<IsConst<T>::value, IsVolatile<T>::value,            typename CorrespondingUnsigned<CVRemoved>::Type> {}; } 
# 1128 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct MakeUnsigned   : EnableIf<IsIntegral<T>::value &&              !IsSame<bool, typename RemoveCV<T>::Type>::value,              typename detail::MakeUnsigned<T>             >::Type {}; 
# 1147 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct RemoveExtent {   typedef T Type; }; template<typename T> struct RemoveExtent<T[]> {   typedef T Type; }; template<typename T, decltype(sizeof(1)) N> struct RemoveExtent<T[N]> {   typedef T Type; }; namespace detail { template<typename T, typename CVRemoved> struct RemovePointerHelper {   typedef T Type; }; template<typename T, typename Pointee> struct RemovePointerHelper<T, Pointee*> {   typedef Pointee Type; }; } 
# 1198 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct RemovePointer   : detail::RemovePointerHelper<T, typename RemoveCV<T>::Type> {}; 
# 1213 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> struct AddPointer {   typedef typename RemoveReference<T>::Type* Type; }; 
# 1239 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<bool B, typename T> struct EnableIf {}; template<typename T> struct EnableIf<true, T> {   typedef T Type; }; template<bool Condition, typename A, typename B> struct Conditional {   typedef A Type; }; template<class A, class B> struct Conditional<false, A, B> {   typedef B Type; }; namespace detail { template<typename U,          bool IsArray = IsArray<U>::value,          bool IsFunction = IsFunction<U>::value> struct DecaySelector; template<typename U> struct DecaySelector<U, false, false> {   typedef typename RemoveCV<U>::Type Type; }; template<typename U> struct DecaySelector<U, true, false> {   typedef typename RemoveExtent<U>::Type* Type; }; template<typename U> struct DecaySelector<U, false, true> {   typedef typename AddPointer<U>::Type Type; }; }; 
# 1306 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TypeTraits.h"
template<typename T> class Decay   : public detail::DecaySelector<typename RemoveReference<T>::Type> { }; }
# 376 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Assertions.h" 2
namespace mozilla { namespace detail { template<typename T> struct AssertionConditionType {   typedef typename RemoveReference<T>::Type ValueT;   static_assert(!IsArray<ValueT>::value,                 "Expected boolean assertion condition, got an array or a "                 "string!");   static_assert(!IsFunction<ValueT>::value,                 "Expected boolean assertion condition, got a function! Did "                 "you intend to call that function?");   static_assert(!IsFloatingPoint<ValueT>::value,                 "It's often a bad idea to assert that a floating-point number "                 "is nonzero, because such assertions tend to intermittently "                 "fail. Shouldn't your code gracefully handle this case instead "                 "of asserting? Anyway, if you really want to do that, write an "                 "explicit boolean condition, like !!x or x!=0.");   static const bool isValid = true; }; } }
# 13 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/GuardObjects.h" 2
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Move.h" 1
# 14 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Move.h"
namespace mozilla { 
# 199 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Move.h"
 ; template<typename T>  T&& Forward(typename RemoveReference<T>::Type& aX) ;  ;  ; }
# 14 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/GuardObjects.h" 2
# 27 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/GuardObjects.h"
namespace mozilla { namespace detail { 
# 78 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/GuardObjects.h"
class GuardObjectNotifier { private:   bool* mStatementDone; public:          }; class GuardObjectNotificationReceiver { private:   bool mStatementDone; public:          }; } }
# 13 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/RootingAPI.h" 2
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/LinkedList.h" 1
# 69 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/LinkedList.h"
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/MemoryReporting.h" 1
# 12 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/MemoryReporting.h"
# 1 "/usr/local/bin/../lib/clang/3.9.1/include/stddef.h" 1 3
# 13 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/MemoryReporting.h" 2
namespace mozilla { typedef size_t (*MallocSizeOf)(const void* p); }
 typedef size_t (*MozMallocSizeOf)(const void* p);
# 70 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/LinkedList.h" 2
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/RefPtr.h" 1
# 10 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/RefPtr.h"
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/AlreadyAddRefed.h" 1
# 16 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/AlreadyAddRefed.h"
namespace mozilla { struct unused_t; }
# 39 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/AlreadyAddRefed.h"
template<class T> struct already_AddRefed { 
# 68 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/AlreadyAddRefed.h"
     typedef void (already_AddRefed::* MatchNullptr)(double, float);                                
# 106 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/AlreadyAddRefed.h"
# 143 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/AlreadyAddRefed.h"
   private:   T* mRawPtr; };
# 11 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/RefPtr.h" 2
class nsCOMPtr_helper;
 namespace mozilla { template<class T> class OwningNonNull; template<class T> class StaticRefPtr; 
# 33 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/RefPtr.h"
template<class U> struct RefPtrTraits {       }; }
 template <class T> class RefPtr { private:       private:   T* mRawPtr; public:   typedef T element_type;                                                                           ;   ;            ;         ;      ;         ;   ;               ;                     template <typename R, typename... Args>   class Proxy   {     typedef R (T::*member_function)(Args...);     T* mRawPtr;     member_function mFunction;   public:               ;   };      ;       public:       private: 
# 388 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/RefPtr.h"
  template<class U>   struct ConstRemovingRefPtrTraits   {             };   template<class U>   struct ConstRemovingRefPtrTraits<const U>   {             }; };
 class nsCycleCollectionTraversalCallback;
  ;
 namespace mozilla { 
# 642 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/RefPtr.h"
 ;  ; }
# 72 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/LinkedList.h" 2
namespace mozilla { template<typename T> class LinkedListElement; namespace detail { template<typename T> struct LinkedListElementTraits {   typedef T* RawType;   typedef const T* ConstRawType;   typedef T* ClientType;   typedef const T* ConstClientType;       }; template<typename T> struct LinkedListElementTraits<RefPtr<T>> {   typedef T* RawType;   typedef const T* ConstRawType;   typedef RefPtr<T> ClientType;   typedef RefPtr<const T> ConstClientType;       }; } template<typename T> class LinkedList; template<typename T> class LinkedListElement {   typedef typename detail::LinkedListElementTraits<T> Traits;   typedef typename Traits::RawType RawType;   typedef typename Traits::ConstRawType ConstRawType;   typedef typename Traits::ClientType ClientType;   typedef typename Traits::ConstClientType ConstClientType; 
# 164 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/LinkedList.h"
private:   LinkedListElement* mNext;   LinkedListElement* mPrev;   const bool mIsSentinel; public:                                              private:   friend class LinkedList<T>;   friend struct detail::LinkedListElementTraits<T>;   enum class NodeKind {     Normal,     Sentinel   };                         }; template<typename T> class LinkedList { private:   typedef typename detail::LinkedListElementTraits<T> Traits;   typedef typename Traits::RawType RawType;   typedef typename Traits::ConstRawType ConstRawType;   typedef typename Traits::ClientType ClientType;   typedef typename Traits::ConstClientType ConstClientType;   LinkedListElement<T> sentinel; public:   class Iterator {     RawType mCurrent;   public:                       };                                                          private:   friend class LinkedListElement<T>;          }; template <typename T> class AutoCleanLinkedList : public LinkedList<T> { public:    }; }
# 14 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/RootingAPI.h" 2
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/type_traits" 1 3
# 33 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/type_traits" 3
# 42 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/type_traits" 3
namespace std {   typedef unsigned short uint_least16_t;   typedef unsigned int uint_least32_t; }
 namespace std __attribute__ ((__visibility__ ("default"))) { 
# 68 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/type_traits" 3
  template<typename _Tp, _Tp __v>     struct integral_constant     {       static constexpr _Tp value = __v;       typedef _Tp value_type;       typedef integral_constant<_Tp, __v> type;              constexpr value_type operator()() const { return value; }     };   template<typename _Tp, _Tp __v>     constexpr _Tp integral_constant<_Tp, __v>::value;   typedef integral_constant<bool, true> true_type;   typedef integral_constant<bool, false> false_type;   template<bool __v>     using __bool_constant = integral_constant<bool, __v>; 
# 103 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/type_traits" 3
  template<bool, typename, typename>     struct conditional;   template<typename...>     struct __or_;   template<>     struct __or_<>     : public false_type     { };   template<typename _B1>     struct __or_<_B1>     : public _B1     { };   template<typename _B1, typename _B2>     struct __or_<_B1, _B2>     : public conditional<_B1::value, _B1, _B2>::type     { };   template<typename _B1, typename _B2, typename _B3, typename... _Bn>     struct __or_<_B1, _B2, _B3, _Bn...>     : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type     { };   template<typename...>     struct __and_;   template<>     struct __and_<>     : public true_type     { };   template<typename _B1>     struct __and_<_B1>     : public _B1     { };   template<typename _B1, typename _B2>     struct __and_<_B1, _B2>     : public conditional<_B1::value, _B2, _B1>::type     { };   template<typename _B1, typename _B2, typename _B3, typename... _Bn>     struct __and_<_B1, _B2, _B3, _Bn...>     : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type     { };   template<typename _Pp>     struct __not_     : public integral_constant<bool, !_Pp::value>     { };   struct __nonesuch {                       }; 
# 189 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/type_traits" 3
  template<typename _Tp>     struct __success_type     { typedef _Tp type; };   struct __failure_type   { };   template<typename>     struct remove_cv;   template<typename>     struct __is_void_helper     : public false_type { };   template<>     struct __is_void_helper<void>     : public true_type { };   template<typename _Tp>     struct is_void     : public __is_void_helper<typename remove_cv<_Tp>::type>::type     { };   template<typename>     struct __is_integral_helper     : public false_type { };   template<>     struct __is_integral_helper<bool>     : public true_type { };   template<>     struct __is_integral_helper<char>     : public true_type { };   template<>     struct __is_integral_helper<signed char>     : public true_type { };   template<>     struct __is_integral_helper<unsigned char>     : public true_type { };   template<>     struct __is_integral_helper<wchar_t>     : public true_type { };   template<>     struct __is_integral_helper<char16_t>     : public true_type { };   template<>     struct __is_integral_helper<char32_t>     : public true_type { };   template<>     struct __is_integral_helper<short>     : public true_type { };   template<>     struct __is_integral_helper<unsigned short>     : public true_type { };   template<>     struct __is_integral_helper<int>     : public true_type { };   template<>     struct __is_integral_helper<unsigned int>     : public true_type { };   template<>     struct __is_integral_helper<long>     : public true_type { };   template<>     struct __is_integral_helper<unsigned long>     : public true_type { };   template<>     struct __is_integral_helper<long long>     : public true_type { };   template<>     struct __is_integral_helper<unsigned long long>     : public true_type { }; 
# 321 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/type_traits" 3
  template<typename _Tp>     struct is_integral     : public __is_integral_helper<typename remove_cv<_Tp>::type>::type     { };   template<typename>     struct __is_floating_point_helper     : public false_type { };   template<>     struct __is_floating_point_helper<float>     : public true_type { };   template<>     struct __is_floating_point_helper<double>     : public true_type { };   template<>     struct __is_floating_point_helper<long double>     : public true_type { }; 
# 349 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/type_traits" 3
  template<typename _Tp>     struct is_floating_point     : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type     { };   template<typename>     struct is_array     : public false_type { };   template<typename _Tp, std::size_t _Size>     struct is_array<_Tp[_Size]>     : public true_type { };   template<typename _Tp>     struct is_array<_Tp[]>     : public true_type { };   template<typename>     struct __is_pointer_helper     : public false_type { };   template<typename _Tp>     struct __is_pointer_helper<_Tp*>     : public true_type { };   template<typename _Tp>     struct is_pointer     : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type     { };   template<typename>     struct is_lvalue_reference     : public false_type { };   template<typename _Tp>     struct is_lvalue_reference<_Tp&>     : public true_type { };   template<typename>     struct is_rvalue_reference     : public false_type { };   template<typename _Tp>     struct is_rvalue_reference<_Tp&&>     : public true_type { };   template<typename>     struct is_function;   template<typename>     struct __is_member_object_pointer_helper     : public false_type { };   template<typename _Tp, typename _Cp>     struct __is_member_object_pointer_helper<_Tp _Cp::*>     : public integral_constant<bool, !is_function<_Tp>::value> { };   template<typename _Tp>     struct is_member_object_pointer     : public __is_member_object_pointer_helper<     typename remove_cv<_Tp>::type>::type     { };   template<typename>     struct __is_member_function_pointer_helper     : public false_type { };   template<typename _Tp, typename _Cp>     struct __is_member_function_pointer_helper<_Tp _Cp::*>     : public integral_constant<bool, is_function<_Tp>::value> { };   template<typename _Tp>     struct is_member_function_pointer     : public __is_member_function_pointer_helper<     typename remove_cv<_Tp>::type>::type     { };   template<typename _Tp>     struct is_enum     : public integral_constant<bool, __is_enum(_Tp)>     { };   template<typename _Tp>     struct is_union     : public integral_constant<bool, __is_union(_Tp)>     { };   template<typename _Tp>     struct is_class     : public integral_constant<bool, __is_class(_Tp)>     { };   template<typename>     struct is_function     : public false_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes...)>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes...) &>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes...) &&>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes......)>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes......) &>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes......) &&>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes...) const>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes...) const &>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes...) const &&>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes......) const>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes......) const &>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes......) const &&>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes...) volatile>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes...) volatile &>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes...) volatile &&>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes......) volatile>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes......) volatile &>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes......) volatile &&>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes...) const volatile>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes...) const volatile &>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes...) const volatile &&>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes......) const volatile>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes......) const volatile &>     : public true_type { };   template<typename _Res, typename... _ArgTypes>     struct is_function<_Res(_ArgTypes......) const volatile &&>     : public true_type { };   template<typename>     struct __is_null_pointer_helper     : public false_type { };   template<>     struct __is_null_pointer_helper<std::nullptr_t>     : public true_type { };   template<typename _Tp>     struct is_null_pointer     : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type     { };   template<typename _Tp>     struct __is_nullptr_t     : public is_null_pointer<_Tp>     { };   template<typename _Tp>     struct is_reference     : public __or_<is_lvalue_reference<_Tp>,                    is_rvalue_reference<_Tp>>::type     { };   template<typename _Tp>     struct is_arithmetic     : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type     { };   template<typename _Tp>     struct is_fundamental     : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,      is_null_pointer<_Tp>>::type     { };   template<typename _Tp>     struct is_object     : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,                           is_void<_Tp>>>::type     { };   template<typename>     struct is_member_pointer;   template<typename _Tp>     struct is_scalar     : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,                    is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type     { };   template<typename _Tp>     struct is_compound     : public integral_constant<bool, !is_fundamental<_Tp>::value> { };   template<typename _Tp>     struct __is_member_pointer_helper     : public false_type { };   template<typename _Tp, typename _Cp>     struct __is_member_pointer_helper<_Tp _Cp::*>     : public true_type { };   template<typename _Tp>     struct is_member_pointer     : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type     { };   template<typename _Tp>     struct __is_referenceable     : public __or_<is_object<_Tp>, is_reference<_Tp>>::type     { };   template<typename _Res, typename... _Args>     struct __is_referenceable<_Res(_Args...)>     : public true_type     { };   template<typename _Res, typename... _Args>     struct __is_referenceable<_Res(_Args......)>     : public true_type     { };   template<typename>     struct is_const     : public false_type { };   template<typename _Tp>     struct is_const<_Tp const>     : public true_type { };   template<typename>     struct is_volatile     : public false_type { };   template<typename _Tp>     struct is_volatile<_Tp volatile>     : public true_type { };   template<typename _Tp>     struct is_trivial     : public integral_constant<bool, __is_trivial(_Tp)>     { };   template<typename _Tp>     struct is_trivially_copyable     : public integral_constant<bool, __is_trivially_copyable(_Tp)>     { };   template<typename _Tp>     struct is_standard_layout     : public integral_constant<bool, __is_standard_layout(_Tp)>     { };   template<typename _Tp>     struct is_pod     : public integral_constant<bool, __is_pod(_Tp)>     { };   template<typename _Tp>     struct is_literal_type     : public integral_constant<bool, __is_literal_type(_Tp)>     { };   template<typename _Tp>     struct is_empty     : public integral_constant<bool, __is_empty(_Tp)>     { };   template<typename _Tp>     struct is_polymorphic     : public integral_constant<bool, __is_polymorphic(_Tp)>     { };   template<typename _Tp>     struct is_final     : public integral_constant<bool, __is_final(_Tp)>     { };   template<typename _Tp>     struct is_abstract     : public integral_constant<bool, __is_abstract(_Tp)>     { };   template<typename _Tp,     bool = is_arithmetic<_Tp>::value>     struct __is_signed_helper     : public false_type { };   template<typename _Tp>     struct __is_signed_helper<_Tp, true>     : public integral_constant<bool, _Tp(-1) < _Tp(0)>     { };   template<typename _Tp>     struct is_signed     : public __is_signed_helper<_Tp>::type     { };   template<typename _Tp>     struct is_unsigned     : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>     { };   template<typename>     struct add_rvalue_reference;   template<typename _Tp>     typename add_rvalue_reference<_Tp>::type declval() noexcept;   template<typename, unsigned = 0>     struct extent;   template<typename>     struct remove_all_extents;   template<typename _Tp>     struct __is_array_known_bounds     : public integral_constant<bool, (extent<_Tp>::value > 0)>     { };   template<typename _Tp>     struct __is_array_unknown_bounds     : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>     { };   struct __do_is_destructible_impl   {     template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>       static true_type __test(int);     template<typename>       static false_type __test(...);   };   template<typename _Tp>     struct __is_destructible_impl     : public __do_is_destructible_impl     {       typedef decltype(__test<_Tp>(0)) type;     };   template<typename _Tp,            bool = __or_<is_void<_Tp>,                         __is_array_unknown_bounds<_Tp>,                         is_function<_Tp>>::value,            bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>     struct __is_destructible_safe;   template<typename _Tp>     struct __is_destructible_safe<_Tp, false, false>     : public __is_destructible_impl<typename                remove_all_extents<_Tp>::type>::type     { };   template<typename _Tp>     struct __is_destructible_safe<_Tp, true, false>     : public false_type { };   template<typename _Tp>     struct __is_destructible_safe<_Tp, false, true>     : public true_type { };   template<typename _Tp>     struct is_destructible     : public __is_destructible_safe<_Tp>::type     { };   struct __do_is_nt_destructible_impl   {     template<typename _Tp>       static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>         __test(int);     template<typename>       static false_type __test(...);   };   template<typename _Tp>     struct __is_nt_destructible_impl     : public __do_is_nt_destructible_impl     {       typedef decltype(__test<_Tp>(0)) type;     };   template<typename _Tp,            bool = __or_<is_void<_Tp>,                         __is_array_unknown_bounds<_Tp>,                         is_function<_Tp>>::value,            bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>     struct __is_nt_destructible_safe;   template<typename _Tp>     struct __is_nt_destructible_safe<_Tp, false, false>     : public __is_nt_destructible_impl<typename                remove_all_extents<_Tp>::type>::type     { };   template<typename _Tp>     struct __is_nt_destructible_safe<_Tp, true, false>     : public false_type { };   template<typename _Tp>     struct __is_nt_destructible_safe<_Tp, false, true>     : public true_type { };   template<typename _Tp>     struct is_nothrow_destructible     : public __is_nt_destructible_safe<_Tp>::type     { };   struct __do_is_default_constructible_impl   {     template<typename _Tp, typename = decltype(_Tp())>       static true_type __test(int);     template<typename>       static false_type __test(...);   };   template<typename _Tp>     struct __is_default_constructible_impl     : public __do_is_default_constructible_impl     {       typedef decltype(__test<_Tp>(0)) type;     };   template<typename _Tp>     struct __is_default_constructible_atom     : public __and_<__not_<is_void<_Tp>>,                     __is_default_constructible_impl<_Tp>>     { };   template<typename _Tp, bool = is_array<_Tp>::value>     struct __is_default_constructible_safe;   template<typename _Tp>     struct __is_default_constructible_safe<_Tp, true>     : public __and_<__is_array_known_bounds<_Tp>,       __is_default_constructible_atom<typename                       remove_all_extents<_Tp>::type>>     { };   template<typename _Tp>     struct __is_default_constructible_safe<_Tp, false>     : public __is_default_constructible_atom<_Tp>::type     { };   template<typename _Tp>     struct is_default_constructible     : public __is_default_constructible_safe<_Tp>::type     { }; 
# 933 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/type_traits" 3
  struct __do_is_static_castable_impl   {     template<typename _From, typename _To, typename              = decltype(static_cast<_To>(declval<_From>()))>       static true_type __test(int);     template<typename, typename>       static false_type __test(...);   };   template<typename _From, typename _To>     struct __is_static_castable_impl     : public __do_is_static_castable_impl     {       typedef decltype(__test<_From, _To>(0)) type;     };   template<typename _From, typename _To>     struct __is_static_castable_safe     : public __is_static_castable_impl<_From, _To>::type     { };   template<typename _From, typename _To>     struct __is_static_castable     : public integral_constant<bool, (__is_static_castable_safe<           _From, _To>::value)>     { };   struct __do_is_direct_constructible_impl   {     template<typename _Tp, typename _Arg, typename       = decltype(::new _Tp(declval<_Arg>()))>       static true_type __test(int);     template<typename, typename>       static false_type __test(...);   };   template<typename _Tp, typename _Arg>     struct __is_direct_constructible_impl     : public __do_is_direct_constructible_impl     {       typedef decltype(__test<_Tp, _Arg>(0)) type;     };   template<typename _Tp, typename _Arg>     struct __is_direct_constructible_new_safe     : public __and_<is_destructible<_Tp>,                     __is_direct_constructible_impl<_Tp, _Arg>>     { };   template<typename, typename>     struct is_same;   template<typename, typename>     struct is_base_of;   template<typename>     struct remove_reference;   template<typename _From, typename _To, bool            = __not_<__or_<is_void<_From>,                           is_function<_From>>>::value>     struct __is_base_to_derived_ref;   template<typename _Tp, typename... _Args>     struct is_constructible;   template<typename _From, typename _To>     struct __is_base_to_derived_ref<_From, _To, true>     {       typedef typename remove_cv<typename remove_reference<_From         >::type>::type __src_t;       typedef typename remove_cv<typename remove_reference<_To         >::type>::type __dst_t;       typedef __and_<__not_<is_same<__src_t, __dst_t>>,        is_base_of<__src_t, __dst_t>,        __not_<is_constructible<__dst_t, _From>>> type;       static constexpr bool value = type::value;     };   template<typename _From, typename _To>     struct __is_base_to_derived_ref<_From, _To, false>     : public false_type     { };   template<typename _From, typename _To, bool            = __and_<is_lvalue_reference<_From>,                     is_rvalue_reference<_To>>::value>     struct __is_lvalue_to_rvalue_ref;   template<typename _From, typename _To>     struct __is_lvalue_to_rvalue_ref<_From, _To, true>     {       typedef typename remove_cv<typename remove_reference<         _From>::type>::type __src_t;       typedef typename remove_cv<typename remove_reference<         _To>::type>::type __dst_t;       typedef __and_<__not_<is_function<__src_t>>,         __or_<is_same<__src_t, __dst_t>,       is_base_of<__dst_t, __src_t>>> type;       static constexpr bool value = type::value;     };   template<typename _From, typename _To>     struct __is_lvalue_to_rvalue_ref<_From, _To, false>     : public false_type     { };   template<typename _Tp, typename _Arg>     struct __is_direct_constructible_ref_cast     : public __and_<__is_static_castable<_Arg, _Tp>,                     __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,                                  __is_lvalue_to_rvalue_ref<_Arg, _Tp>                    >>>     { };   template<typename _Tp, typename _Arg>     struct __is_direct_constructible_new     : public conditional<is_reference<_Tp>::value,     __is_direct_constructible_ref_cast<_Tp, _Arg>,     __is_direct_constructible_new_safe<_Tp, _Arg>     >::type     { };   template<typename _Tp, typename _Arg>     struct __is_direct_constructible     : public __is_direct_constructible_new<_Tp, _Arg>::type     { };   struct __do_is_nary_constructible_impl   {     template<typename _Tp, typename... _Args, typename              = decltype(_Tp(declval<_Args>()...))>       static true_type __test(int);     template<typename, typename...>       static false_type __test(...);   };   template<typename _Tp, typename... _Args>     struct __is_nary_constructible_impl     : public __do_is_nary_constructible_impl     {       typedef decltype(__test<_Tp, _Args...>(0)) type;     };   template<typename _Tp, typename... _Args>     struct __is_nary_constructible     : public __is_nary_constructible_impl<_Tp, _Args...>::type     {       static_assert(sizeof...(_Args) > 1,                     "Only useful for > 1 arguments");     };   template<typename _Tp, typename... _Args>     struct __is_constructible_impl     : public __is_nary_constructible<_Tp, _Args...>     { };   template<typename _Tp, typename _Arg>     struct __is_constructible_impl<_Tp, _Arg>     : public __is_direct_constructible<_Tp, _Arg>     { };   template<typename _Tp>     struct __is_constructible_impl<_Tp>     : public is_default_constructible<_Tp>     { };   template<typename _Tp, typename... _Args>     struct is_constructible     : public __is_constructible_impl<_Tp, _Args...>::type     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_copy_constructible_impl;   template<typename _Tp>     struct __is_copy_constructible_impl<_Tp, false>     : public false_type { };   template<typename _Tp>     struct __is_copy_constructible_impl<_Tp, true>     : public is_constructible<_Tp, const _Tp&>     { };   template<typename _Tp>     struct is_copy_constructible     : public __is_copy_constructible_impl<_Tp>     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_move_constructible_impl;   template<typename _Tp>     struct __is_move_constructible_impl<_Tp, false>     : public false_type { };   template<typename _Tp>     struct __is_move_constructible_impl<_Tp, true>     : public is_constructible<_Tp, _Tp&&>     { };   template<typename _Tp>     struct is_move_constructible     : public __is_move_constructible_impl<_Tp>     { };   template<typename _Tp>     struct __is_nt_default_constructible_atom     : public integral_constant<bool, noexcept(_Tp())>     { };   template<typename _Tp, bool = is_array<_Tp>::value>     struct __is_nt_default_constructible_impl;   template<typename _Tp>     struct __is_nt_default_constructible_impl<_Tp, true>     : public __and_<__is_array_known_bounds<_Tp>,       __is_nt_default_constructible_atom<typename                       remove_all_extents<_Tp>::type>>     { };   template<typename _Tp>     struct __is_nt_default_constructible_impl<_Tp, false>     : public __is_nt_default_constructible_atom<_Tp>     { };   template<typename _Tp>     struct is_nothrow_default_constructible     : public __and_<is_default_constructible<_Tp>,                     __is_nt_default_constructible_impl<_Tp>>     { };   template<typename _Tp, typename... _Args>     struct __is_nt_constructible_impl     : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>     { };   template<typename _Tp, typename _Arg>     struct __is_nt_constructible_impl<_Tp, _Arg>     : public integral_constant<bool,                                noexcept(static_cast<_Tp>(declval<_Arg>()))>     { };   template<typename _Tp>     struct __is_nt_constructible_impl<_Tp>     : public is_nothrow_default_constructible<_Tp>     { };   template<typename _Tp, typename... _Args>     struct is_nothrow_constructible     : public __and_<is_constructible<_Tp, _Args...>,       __is_nt_constructible_impl<_Tp, _Args...>>     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_nothrow_copy_constructible_impl;   template<typename _Tp>     struct __is_nothrow_copy_constructible_impl<_Tp, false>     : public false_type { };   template<typename _Tp>     struct __is_nothrow_copy_constructible_impl<_Tp, true>     : public is_nothrow_constructible<_Tp, const _Tp&>     { };   template<typename _Tp>     struct is_nothrow_copy_constructible     : public __is_nothrow_copy_constructible_impl<_Tp>     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_nothrow_move_constructible_impl;   template<typename _Tp>     struct __is_nothrow_move_constructible_impl<_Tp, false>     : public false_type { };   template<typename _Tp>     struct __is_nothrow_move_constructible_impl<_Tp, true>     : public is_nothrow_constructible<_Tp, _Tp&&>     { };   template<typename _Tp>     struct is_nothrow_move_constructible     : public __is_nothrow_move_constructible_impl<_Tp>     { };   template<typename _Tp, typename _Up>     class __is_assignable_helper     {       template<typename _Tp1, typename _Up1,         typename = decltype(declval<_Tp1>() = declval<_Up1>())>  static true_type  __test(int);       template<typename, typename>  static false_type  __test(...);     public:       typedef decltype(__test<_Tp, _Up>(0)) type;     };   template<typename _Tp, typename _Up>     struct is_assignable       : public __is_assignable_helper<_Tp, _Up>::type     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_copy_assignable_impl;   template<typename _Tp>     struct __is_copy_assignable_impl<_Tp, false>     : public false_type { };   template<typename _Tp>     struct __is_copy_assignable_impl<_Tp, true>     : public is_assignable<_Tp&, const _Tp&>     { };   template<typename _Tp>     struct is_copy_assignable     : public __is_copy_assignable_impl<_Tp>     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_move_assignable_impl;   template<typename _Tp>     struct __is_move_assignable_impl<_Tp, false>     : public false_type { };   template<typename _Tp>     struct __is_move_assignable_impl<_Tp, true>     : public is_assignable<_Tp&, _Tp&&>     { };   template<typename _Tp>     struct is_move_assignable     : public __is_move_assignable_impl<_Tp>     { };   template<typename _Tp, typename _Up>     struct __is_nt_assignable_impl     : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>     { };   template<typename _Tp, typename _Up>     struct is_nothrow_assignable     : public __and_<is_assignable<_Tp, _Up>,       __is_nt_assignable_impl<_Tp, _Up>>     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_nt_copy_assignable_impl;   template<typename _Tp>     struct __is_nt_copy_assignable_impl<_Tp, false>     : public false_type { };   template<typename _Tp>     struct __is_nt_copy_assignable_impl<_Tp, true>     : public is_nothrow_assignable<_Tp&, const _Tp&>     { };   template<typename _Tp>     struct is_nothrow_copy_assignable     : public __is_nt_copy_assignable_impl<_Tp>     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __is_nt_move_assignable_impl;   template<typename _Tp>     struct __is_nt_move_assignable_impl<_Tp, false>     : public false_type { };   template<typename _Tp>     struct __is_nt_move_assignable_impl<_Tp, true>     : public is_nothrow_assignable<_Tp&, _Tp&&>     { };   template<typename _Tp>     struct is_nothrow_move_assignable     : public __is_nt_move_assignable_impl<_Tp>     { };   template<typename _Tp, typename... _Args>     struct is_trivially_constructible     : public __and_<is_constructible<_Tp, _Args...>, integral_constant<bool,    __is_trivially_constructible(_Tp, _Args...)>>     { };   template<typename _Tp>     struct is_trivially_default_constructible     : public is_trivially_constructible<_Tp>::type     { };   struct __do_is_implicitly_default_constructible_impl   {     template <typename _Tp>     static void __helper(const _Tp&);     template <typename _Tp>     static true_type __test(const _Tp&,                             decltype(__helper<const _Tp&>({}))* = 0);     static false_type __test(...);   };   template<typename _Tp>     struct __is_implicitly_default_constructible_impl       : public __do_is_implicitly_default_constructible_impl   {     typedef decltype(__test(declval<_Tp>())) type;   };   template<typename _Tp>     struct __is_implicitly_default_constructible_safe       : public __is_implicitly_default_constructible_impl<_Tp>::type   { };   template <typename _Tp>     struct __is_implicitly_default_constructible       : public __and_<is_default_constructible<_Tp>,                       __is_implicitly_default_constructible_safe<_Tp>>   { };   template<typename _Tp>     struct is_trivially_copy_constructible     : public __and_<is_copy_constructible<_Tp>,       integral_constant<bool,    __is_trivially_constructible(_Tp, const _Tp&)>>     { };   template<typename _Tp>     struct is_trivially_move_constructible     : public __and_<is_move_constructible<_Tp>,       integral_constant<bool,    __is_trivially_constructible(_Tp, _Tp&&)>>     { };   template<typename _Tp, typename _Up>     struct is_trivially_assignable     : public __and_<is_assignable<_Tp, _Up>,       integral_constant<bool,    __is_trivially_assignable(_Tp, _Up)>>     { };   template<typename _Tp>     struct is_trivially_copy_assignable     : public __and_<is_copy_assignable<_Tp>,       integral_constant<bool,    __is_trivially_assignable(_Tp&, const _Tp&)>>     { };   template<typename _Tp>     struct is_trivially_move_assignable     : public __and_<is_move_assignable<_Tp>,       integral_constant<bool,    __is_trivially_assignable(_Tp&, _Tp&&)>>     { };   template<typename _Tp>     struct is_trivially_destructible     : public __and_<is_destructible<_Tp>, integral_constant<bool,          __has_trivial_destructor(_Tp)>>     { };   template<typename _Tp>     struct has_trivial_default_constructor     : public integral_constant<bool, __has_trivial_constructor(_Tp)>     { } __attribute__ ((__deprecated__));   template<typename _Tp>     struct has_trivial_copy_constructor     : public integral_constant<bool, __has_trivial_copy(_Tp)>     { } __attribute__ ((__deprecated__));   template<typename _Tp>     struct has_trivial_copy_assign     : public integral_constant<bool, __has_trivial_assign(_Tp)>     { } __attribute__ ((__deprecated__));   template<typename _Tp>     struct has_virtual_destructor     : public integral_constant<bool, __has_virtual_destructor(_Tp)>     { };   template<typename _Tp>     struct alignment_of     : public integral_constant<std::size_t, __alignof__(_Tp)> { };   template<typename>     struct rank     : public integral_constant<std::size_t, 0> { };   template<typename _Tp, std::size_t _Size>     struct rank<_Tp[_Size]>     : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };   template<typename _Tp>     struct rank<_Tp[]>     : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };   template<typename, unsigned _Uint>     struct extent     : public integral_constant<std::size_t, 0> { };   template<typename _Tp, unsigned _Uint, std::size_t _Size>     struct extent<_Tp[_Size], _Uint>     : public integral_constant<std::size_t,           _Uint == 0 ? _Size : extent<_Tp,           _Uint - 1>::value>     { };   template<typename _Tp, unsigned _Uint>     struct extent<_Tp[], _Uint>     : public integral_constant<std::size_t,           _Uint == 0 ? 0 : extent<_Tp,              _Uint - 1>::value>     { };   template<typename, typename>     struct is_same     : public false_type { };   template<typename _Tp>     struct is_same<_Tp, _Tp>     : public true_type { };   template<typename _Base, typename _Derived>     struct is_base_of     : public integral_constant<bool, __is_base_of(_Base, _Derived)>     { };   template<typename _From, typename _To,            bool = __or_<is_void<_From>, is_function<_To>,                         is_array<_To>>::value>     struct __is_convertible_helper     { typedef typename is_void<_To>::type type; };   template<typename _From, typename _To>     class __is_convertible_helper<_From, _To, false>     {        template<typename _To1>  static void __test_aux(_To1);       template<typename _From1, typename _To1,         typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>  static true_type  __test(int);       template<typename, typename>  static false_type  __test(...);     public:       typedef decltype(__test<_From, _To>(0)) type;     };   template<typename _From, typename _To>     struct is_convertible     : public __is_convertible_helper<_From, _To>::type     { };   template<typename _Tp>     struct remove_const     { typedef _Tp type; };   template<typename _Tp>     struct remove_const<_Tp const>     { typedef _Tp type; };   template<typename _Tp>     struct remove_volatile     { typedef _Tp type; };   template<typename _Tp>     struct remove_volatile<_Tp volatile>     { typedef _Tp type; };   template<typename _Tp>     struct remove_cv     {       typedef typename       remove_const<typename remove_volatile<_Tp>::type>::type type;     };   template<typename _Tp>     struct add_const     { typedef _Tp const type; };   template<typename _Tp>     struct add_volatile     { typedef _Tp volatile type; };   template<typename _Tp>     struct add_cv     {       typedef typename       add_const<typename add_volatile<_Tp>::type>::type type;     };   template<typename _Tp>     using remove_const_t = typename remove_const<_Tp>::type;   template<typename _Tp>     using remove_volatile_t = typename remove_volatile<_Tp>::type;   template<typename _Tp>     using remove_cv_t = typename remove_cv<_Tp>::type;   template<typename _Tp>     using add_const_t = typename add_const<_Tp>::type;   template<typename _Tp>     using add_volatile_t = typename add_volatile<_Tp>::type;   template<typename _Tp>     using add_cv_t = typename add_cv<_Tp>::type;   template<typename _Tp>     struct remove_reference     { typedef _Tp type; };   template<typename _Tp>     struct remove_reference<_Tp&>     { typedef _Tp type; };   template<typename _Tp>     struct remove_reference<_Tp&&>     { typedef _Tp type; };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __add_lvalue_reference_helper     { typedef _Tp type; };   template<typename _Tp>     struct __add_lvalue_reference_helper<_Tp, true>     { typedef _Tp& type; };   template<typename _Tp>     struct add_lvalue_reference     : public __add_lvalue_reference_helper<_Tp>     { };   template<typename _Tp, bool = __is_referenceable<_Tp>::value>     struct __add_rvalue_reference_helper     { typedef _Tp type; };   template<typename _Tp>     struct __add_rvalue_reference_helper<_Tp, true>     { typedef _Tp&& type; };   template<typename _Tp>     struct add_rvalue_reference     : public __add_rvalue_reference_helper<_Tp>     { };   template<typename _Tp>     using remove_reference_t = typename remove_reference<_Tp>::type;   template<typename _Tp>     using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;   template<typename _Tp>     using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;   template<typename _Unqualified, bool _IsConst, bool _IsVol>     struct __cv_selector;   template<typename _Unqualified>     struct __cv_selector<_Unqualified, false, false>     { typedef _Unqualified __type; };   template<typename _Unqualified>     struct __cv_selector<_Unqualified, false, true>     { typedef volatile _Unqualified __type; };   template<typename _Unqualified>     struct __cv_selector<_Unqualified, true, false>     { typedef const _Unqualified __type; };   template<typename _Unqualified>     struct __cv_selector<_Unqualified, true, true>     { typedef const volatile _Unqualified __type; };   template<typename _Qualified, typename _Unqualified,     bool _IsConst = is_const<_Qualified>::value,     bool _IsVol = is_volatile<_Qualified>::value>     class __match_cv_qualifiers     {       typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;     public:       typedef typename __match::__type __type;     };   template<typename _Tp>     struct __make_unsigned     { typedef _Tp __type; };   template<>     struct __make_unsigned<char>     { typedef unsigned char __type; };   template<>     struct __make_unsigned<signed char>     { typedef unsigned char __type; };   template<>     struct __make_unsigned<short>     { typedef unsigned short __type; };   template<>     struct __make_unsigned<int>     { typedef unsigned int __type; };   template<>     struct __make_unsigned<long>     { typedef unsigned long __type; };   template<>     struct __make_unsigned<long long>     { typedef unsigned long long __type; };   template<>     struct __make_unsigned<wchar_t> : __make_unsigned<int>     { }; 
# 1785 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/type_traits" 3
  template<typename _Tp,     bool _IsInt = is_integral<_Tp>::value,     bool _IsEnum = is_enum<_Tp>::value>     class __make_unsigned_selector;   template<typename _Tp>     class __make_unsigned_selector<_Tp, true, false>     {       typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;       typedef typename __unsignedt::__type __unsigned_type;       typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;     public:       typedef typename __cv_unsigned::__type __type;     };   template<typename _Tp>     class __make_unsigned_selector<_Tp, false, true>     {       typedef unsigned char __smallest;       static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);       static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);       static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);       static const bool __b3 = sizeof(_Tp) <= sizeof(unsigned long);       typedef conditional<__b3, unsigned long, unsigned long long> __cond3;       typedef typename __cond3::type __cond3_type;       typedef conditional<__b2, unsigned int, __cond3_type> __cond2;       typedef typename __cond2::type __cond2_type;       typedef conditional<__b1, unsigned short, __cond2_type> __cond1;       typedef typename __cond1::type __cond1_type;       typedef typename conditional<__b0, __smallest, __cond1_type>::type  __unsigned_type;       typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;     public:       typedef typename __cv_unsigned::__type __type;     };   template<typename _Tp>     struct make_unsigned     { typedef typename __make_unsigned_selector<_Tp>::__type type; };   template<>     struct make_unsigned<bool>;   template<typename _Tp>     struct __make_signed     { typedef _Tp __type; };   template<>     struct __make_signed<char>     { typedef signed char __type; };   template<>     struct __make_signed<unsigned char>     { typedef signed char __type; };   template<>     struct __make_signed<unsigned short>     { typedef signed short __type; };   template<>     struct __make_signed<unsigned int>     { typedef signed int __type; };   template<>     struct __make_signed<unsigned long>     { typedef signed long __type; };   template<>     struct __make_signed<unsigned long long>     { typedef signed long long __type; }; 
# 1874 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/type_traits" 3
  template<>     struct __make_signed<char16_t> : __make_signed<uint_least16_t>     { };   template<>     struct __make_signed<char32_t> : __make_signed<uint_least32_t>     { }; 
# 1904 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/type_traits" 3
  template<typename _Tp,     bool _IsInt = is_integral<_Tp>::value,     bool _IsEnum = is_enum<_Tp>::value>     class __make_signed_selector;   template<typename _Tp>     class __make_signed_selector<_Tp, true, false>     {       typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;       typedef typename __signedt::__type __signed_type;       typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;     public:       typedef typename __cv_signed::__type __type;     };   template<typename _Tp>     class __make_signed_selector<_Tp, false, true>     {       typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;     public:       typedef typename __make_signed_selector<__unsigned_type>::__type __type;     };   template<typename _Tp>     struct make_signed     { typedef typename __make_signed_selector<_Tp>::__type type; };   template<>     struct make_signed<bool>;   template<typename _Tp>     using make_signed_t = typename make_signed<_Tp>::type;   template<typename _Tp>     using make_unsigned_t = typename make_unsigned<_Tp>::type;   template<typename _Tp>     struct remove_extent     { typedef _Tp type; };   template<typename _Tp, std::size_t _Size>     struct remove_extent<_Tp[_Size]>     { typedef _Tp type; };   template<typename _Tp>     struct remove_extent<_Tp[]>     { typedef _Tp type; };   template<typename _Tp>     struct remove_all_extents     { typedef _Tp type; };   template<typename _Tp, std::size_t _Size>     struct remove_all_extents<_Tp[_Size]>     { typedef typename remove_all_extents<_Tp>::type type; };   template<typename _Tp>     struct remove_all_extents<_Tp[]>     { typedef typename remove_all_extents<_Tp>::type type; };   template<typename _Tp>     using remove_extent_t = typename remove_extent<_Tp>::type;   template<typename _Tp>     using remove_all_extents_t = typename remove_all_extents<_Tp>::type;   template<typename _Tp, typename>     struct __remove_pointer_helper     { typedef _Tp type; };   template<typename _Tp, typename _Up>     struct __remove_pointer_helper<_Tp, _Up*>     { typedef _Up type; };   template<typename _Tp>     struct remove_pointer     : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>     { };   template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,           is_void<_Tp>>::value>     struct __add_pointer_helper     { typedef _Tp type; };   template<typename _Tp>     struct __add_pointer_helper<_Tp, true>     { typedef typename remove_reference<_Tp>::type* type; };   template<typename _Tp>     struct add_pointer     : public __add_pointer_helper<_Tp>     { };   template<typename _Tp>     using remove_pointer_t = typename remove_pointer<_Tp>::type;   template<typename _Tp>     using add_pointer_t = typename add_pointer<_Tp>::type;   template<std::size_t _Len>     struct __aligned_storage_msa     {       union __type       {  unsigned char __data[_Len];  struct __attribute__((__aligned__)) { } __align;       };     }; 
# 2050 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =     __alignof__(typename __aligned_storage_msa<_Len>::__type)>     struct aligned_storage     {       union type       {  unsigned char __data[_Len];  struct __attribute__((__aligned__((_Align)))) { } __align;       };     };   template <typename... _Types>     struct __strictest_alignment     {       static const size_t _S_alignment = 0;       static const size_t _S_size = 0;     };   template <typename _Tp, typename... _Types>     struct __strictest_alignment<_Tp, _Types...>     {       static const size_t _S_alignment =         alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment  ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;       static const size_t _S_size =         sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size  ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;     }; 
# 2089 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/type_traits" 3
  template <size_t _Len, typename... _Types>     struct aligned_union     {     private:       static_assert(sizeof...(_Types) != 0, "At least one type is required");       using __strictest = __strictest_alignment<_Types...>;       static const size_t _S_len = _Len > __strictest::_S_size  ? _Len : __strictest::_S_size;     public:       static const size_t alignment_value = __strictest::_S_alignment;       typedef typename aligned_storage<_S_len, alignment_value>::type type;     };   template <size_t _Len, typename... _Types>     const size_t aligned_union<_Len, _Types...>::alignment_value;   template<typename _Up,     bool _IsArray = is_array<_Up>::value,     bool _IsFunction = is_function<_Up>::value>     struct __decay_selector;   template<typename _Up>     struct __decay_selector<_Up, false, false>     { typedef typename remove_cv<_Up>::type __type; };   template<typename _Up>     struct __decay_selector<_Up, true, false>     { typedef typename remove_extent<_Up>::type* __type; };   template<typename _Up>     struct __decay_selector<_Up, false, true>     { typedef typename add_pointer<_Up>::type __type; };   template<typename _Tp>     class decay     {       typedef typename remove_reference<_Tp>::type __remove_type;     public:       typedef typename __decay_selector<__remove_type>::__type type;     };   template<typename _Tp>     class reference_wrapper;   template<typename _Tp>     struct __strip_reference_wrapper     {       typedef _Tp __type;     };   template<typename _Tp>     struct __strip_reference_wrapper<reference_wrapper<_Tp> >     {       typedef _Tp& __type;     };   template<typename _Tp>     struct __decay_and_strip     {       typedef typename __strip_reference_wrapper<  typename decay<_Tp>::type>::__type __type;     };   template<bool, typename _Tp = void>     struct enable_if     { };   template<typename _Tp>     struct enable_if<true, _Tp>     { typedef _Tp type; };   template<typename... _Cond>     using _Require = typename enable_if<__and_<_Cond...>::value>::type;   template<bool _Cond, typename _Iftrue, typename _Iffalse>     struct conditional     { typedef _Iftrue type; };   template<typename _Iftrue, typename _Iffalse>     struct conditional<false, _Iftrue, _Iffalse>     { typedef _Iffalse type; };   template<typename... _Tp>     struct common_type;   struct __do_common_type_impl   {     template<typename _Tp, typename _Up>       static __success_type<typename decay<decltype        (true ? std::declval<_Tp>()         : std::declval<_Up>())>::type> _S_test(int);     template<typename, typename>       static __failure_type _S_test(...);   };   template<typename _Tp, typename _Up>     struct __common_type_impl     : private __do_common_type_impl     {       typedef decltype(_S_test<_Tp, _Up>(0)) type;     };   struct __do_member_type_wrapper   {     template<typename _Tp>       static __success_type<typename _Tp::type> _S_test(int);     template<typename>       static __failure_type _S_test(...);   };   template<typename _Tp>     struct __member_type_wrapper     : private __do_member_type_wrapper     {       typedef decltype(_S_test<_Tp>(0)) type;     };   template<typename _CTp, typename... _Args>     struct __expanded_common_type_wrapper     {       typedef common_type<typename _CTp::type, _Args...> type;     };   template<typename... _Args>     struct __expanded_common_type_wrapper<__failure_type, _Args...>     { typedef __failure_type type; };   template<typename _Tp>     struct common_type<_Tp>     { typedef typename decay<_Tp>::type type; };   template<typename _Tp, typename _Up>     struct common_type<_Tp, _Up>     : public __common_type_impl<_Tp, _Up>::type     { };   template<typename _Tp, typename _Up, typename... _Vp>     struct common_type<_Tp, _Up, _Vp...>     : public __expanded_common_type_wrapper<typename __member_type_wrapper<                common_type<_Tp, _Up>>::type, _Vp...>::type     { };   template<typename _Tp>     struct underlying_type     {       typedef __underlying_type(_Tp) type;     };   template<typename _Tp>     struct __declval_protector     {       static const bool __stop = false;       static typename add_rvalue_reference<_Tp>::type __delegate();     };   template<typename _Tp>     inline typename add_rvalue_reference<_Tp>::type     declval() noexcept     {       static_assert(__declval_protector<_Tp>::__stop,       "declval() must not be used!");       return __declval_protector<_Tp>::__delegate();     }   template<typename _Signature>     class result_of;   struct __invoke_memfun_ref { };   struct __invoke_memfun_deref { };   struct __invoke_memobj_ref { };   struct __invoke_memobj_deref { };   struct __invoke_other { };   template<typename _Tp, typename _Tag>     struct __result_of_success : __success_type<_Tp>     { using __invoke_type = _Tag; };   struct __result_of_memfun_ref_impl   {     template<typename _Fp, typename _Tp1, typename... _Args>       static __result_of_success<decltype(       (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)       ), __invoke_memfun_ref> _S_test(int);     template<typename...>       static __failure_type _S_test(...);   };   template<typename _MemPtr, typename _Arg, typename... _Args>     struct __result_of_memfun_ref     : private __result_of_memfun_ref_impl     {       typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;     };   struct __result_of_memfun_deref_impl   {     template<typename _Fp, typename _Tp1, typename... _Args>       static __result_of_success<decltype(       ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)       ), __invoke_memfun_deref> _S_test(int);     template<typename...>       static __failure_type _S_test(...);   };   template<typename _MemPtr, typename _Arg, typename... _Args>     struct __result_of_memfun_deref     : private __result_of_memfun_deref_impl     {       typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;     };   struct __result_of_memobj_ref_impl   {     template<typename _Fp, typename _Tp1>       static __result_of_success<decltype(       std::declval<_Tp1>().*std::declval<_Fp>()       ), __invoke_memobj_ref> _S_test(int);     template<typename, typename>       static __failure_type _S_test(...);   };   template<typename _MemPtr, typename _Arg>     struct __result_of_memobj_ref     : private __result_of_memobj_ref_impl     {       typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;     };   struct __result_of_memobj_deref_impl   {     template<typename _Fp, typename _Tp1>       static __result_of_success<decltype(       (*std::declval<_Tp1>()).*std::declval<_Fp>()       ), __invoke_memobj_deref> _S_test(int);     template<typename, typename>       static __failure_type _S_test(...);   };   template<typename _MemPtr, typename _Arg>     struct __result_of_memobj_deref     : private __result_of_memobj_deref_impl     {       typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;     };   template<typename _MemPtr, typename _Arg>     struct __result_of_memobj;   template<typename _Res, typename _Class, typename _Arg>     struct __result_of_memobj<_Res _Class::*, _Arg>     {       typedef typename remove_cv<typename remove_reference<         _Arg>::type>::type _Argval;       typedef _Res _Class::* _MemPtr;       typedef typename conditional<__or_<is_same<_Argval, _Class>,         is_base_of<_Class, _Argval>>::value,         __result_of_memobj_ref<_MemPtr, _Arg>,         __result_of_memobj_deref<_MemPtr, _Arg>       >::type::type type;     };   template<typename _MemPtr, typename _Arg, typename... _Args>     struct __result_of_memfun;   template<typename _Res, typename _Class, typename _Arg, typename... _Args>     struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>     {       typedef typename remove_cv<typename remove_reference<         _Arg>::type>::type _Argval;       typedef _Res _Class::* _MemPtr;       typedef typename conditional<__or_<is_same<_Argval, _Class>,         is_base_of<_Class, _Argval>>::value,         __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,         __result_of_memfun_deref<_MemPtr, _Arg, _Args...>       >::type::type type;     };   template<typename _Res, typename _Class, typename _Arg>     struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>>     : __result_of_memobj_ref<_Res _Class::*, _Arg&>     { };   template<typename _Res, typename _Class, typename _Arg>     struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>&>     : __result_of_memobj_ref<_Res _Class::*, _Arg&>     { };   template<typename _Res, typename _Class, typename _Arg>     struct __result_of_memobj<_Res _Class::*, const reference_wrapper<_Arg>&>     : __result_of_memobj_ref<_Res _Class::*, _Arg&>     { };   template<typename _Res, typename _Class, typename _Arg>     struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>&&>     : __result_of_memobj_ref<_Res _Class::*, _Arg&>     { };   template<typename _Res, typename _Class, typename _Arg>     struct __result_of_memobj<_Res _Class::*, const reference_wrapper<_Arg>&&>     : __result_of_memobj_ref<_Res _Class::*, _Arg&>     { };   template<typename _Res, typename _Class, typename _Arg, typename... _Args>     struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>, _Args...>     : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>     { };   template<typename _Res, typename _Class, typename _Arg, typename... _Args>     struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>&,          _Args...>     : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>     { };   template<typename _Res, typename _Class, typename _Arg, typename... _Args>     struct __result_of_memfun<_Res _Class::*, const reference_wrapper<_Arg>&,          _Args...>     : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>     { };   template<typename _Res, typename _Class, typename _Arg, typename... _Args>     struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>&&,          _Args...>     : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>     { };   template<typename _Res, typename _Class, typename _Arg, typename... _Args>     struct __result_of_memfun<_Res _Class::*, const reference_wrapper<_Arg>&&,          _Args...>     : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>     { };   template<bool, bool, typename _Functor, typename... _ArgTypes>     struct __result_of_impl     {       typedef __failure_type type;     };   template<typename _MemPtr, typename _Arg>     struct __result_of_impl<true, false, _MemPtr, _Arg>     : public __result_of_memobj<typename decay<_MemPtr>::type, _Arg>     { };   template<typename _MemPtr, typename _Arg, typename... _Args>     struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>     : public __result_of_memfun<typename decay<_MemPtr>::type, _Arg, _Args...>     { };   struct __result_of_other_impl   {     template<typename _Fn, typename... _Args>       static __result_of_success<decltype(       std::declval<_Fn>()(std::declval<_Args>()...)       ), __invoke_other> _S_test(int);     template<typename...>       static __failure_type _S_test(...);   };   template<typename _Functor, typename... _ArgTypes>     struct __result_of_impl<false, false, _Functor, _ArgTypes...>     : private __result_of_other_impl     {       typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;     };   template<typename _Functor, typename... _ArgTypes>     struct result_of<_Functor(_ArgTypes...)>     : public __result_of_impl<         is_member_object_pointer<           typename remove_reference<_Functor>::type         >::value,         is_member_function_pointer<           typename remove_reference<_Functor>::type         >::value,      _Functor, _ArgTypes...       >::type     { };   template<size_t _Len, size_t _Align =      __alignof__(typename __aligned_storage_msa<_Len>::__type)>     using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;   template <size_t _Len, typename... _Types>     using aligned_union_t = typename aligned_union<_Len, _Types...>::type;   template<typename _Tp>     using decay_t = typename decay<_Tp>::type;   template<bool _Cond, typename _Tp = void>     using enable_if_t = typename enable_if<_Cond, _Tp>::type;   template<bool _Cond, typename _Iftrue, typename _Iffalse>     using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;   template<typename... _Tp>     using common_type_t = typename common_type<_Tp...>::type;   template<typename _Tp>     using underlying_type_t = typename underlying_type<_Tp>::type;   template<typename _Tp>     using result_of_t = typename result_of<_Tp>::type;   template<typename...> using __void_t = void; 
# 2551 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/type_traits" 3
  template<typename _Default, typename _AlwaysVoid,     template<typename...> class _Op, typename... _Args>     struct __detector     {       using value_t = false_type;       using type = _Default;     };   template<typename _Default, template<typename...> class _Op,      typename... _Args>     struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>     {       using value_t = true_type;       using type = _Op<_Args...>;     };   template<typename _Default, template<typename...> class _Op,     typename... _Args>     using __detected_or = __detector<_Default, void, _Op, _Args...>;   template<typename _Default, template<typename...> class _Op,     typename... _Args>     using __detected_or_t       = typename __detected_or<_Default, _Op, _Args...>::type;   template<template<typename...> class _Default,     template<typename...> class _Op, typename... _Args>     using __detected_or_t_ =       __detected_or_t<_Default<_Args...>, _Op, _Args...>; 
# 2601 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/type_traits" 3
  template <typename _Tp>     struct __is_swappable;   template <typename _Tp>     struct __is_nothrow_swappable;   template<typename _Tp>     inline     typename enable_if<__and_<is_move_constructible<_Tp>,          is_move_assignable<_Tp>>::value>::type     swap(_Tp&, _Tp&)     noexcept(__and_<is_nothrow_move_constructible<_Tp>,              is_nothrow_move_assignable<_Tp>>::value);   template<typename _Tp, size_t _Nm>     inline     typename enable_if<__is_swappable<_Tp>::value>::type     swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])     noexcept(__is_nothrow_swappable<_Tp>::value);   namespace __swappable_details {     using std::swap;     struct __do_is_swappable_impl     {       template<typename _Tp, typename                = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>         static true_type __test(int);       template<typename>         static false_type __test(...);     };     struct __do_is_nothrow_swappable_impl     {       template<typename _Tp>         static __bool_constant<           noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))         > __test(int);       template<typename>         static false_type __test(...);     };   }   template<typename _Tp>     struct __is_swappable_impl     : public __swappable_details::__do_is_swappable_impl     {       typedef decltype(__test<_Tp>(0)) type;     };   template<typename _Tp>     struct __is_nothrow_swappable_impl     : public __swappable_details::__do_is_nothrow_swappable_impl     {       typedef decltype(__test<_Tp>(0)) type;     };   template<typename _Tp>     struct __is_swappable     : public __is_swappable_impl<_Tp>::type     { };   template<typename _Tp>     struct __is_nothrow_swappable     : public __is_nothrow_swappable_impl<_Tp>::type     { }; }
# 18 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/RootingAPI.h" 2
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/jspubtd.h" 1
# 15 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/jspubtd.h"
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/EnumeratedArray.h" 1
# 12 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/EnumeratedArray.h"
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Array.h" 1
# 15 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Array.h"
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/ReverseIterator.h" 1
# 17 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/ReverseIterator.h"
namespace mozilla { template<typename IteratorT> class ReverseIterator { public:   template<typename Iterator>   explicit ReverseIterator(Iterator aIter)  ;   template<typename Iterator>                ReverseIterator(const ReverseIterator<Iterator>& aOther)  ;   decltype(*DeclVal<IteratorT>()) operator*() const   {     IteratorT tmp = mCurrent;     return *--tmp;   }   ReverseIterator& operator++() { --mCurrent; return *this; }   ReverseIterator& operator--() { ++mCurrent; return *this; }   ReverseIterator operator++(int) { auto ret = *this; mCurrent--; return ret; }   ReverseIterator operator--(int) { auto ret = *this; mCurrent++; return ret; }   template<typename Iterator1, typename Iterator2>   friend bool operator==(const ReverseIterator<Iterator1>& aIter1,                          const ReverseIterator<Iterator2>& aIter2);   template<typename Iterator1, typename Iterator2>   friend bool operator!=(const ReverseIterator<Iterator1>& aIter1,                          const ReverseIterator<Iterator2>& aIter2);   ;   ;   ;   ; private:   IteratorT mCurrent; };  ;  ;  ;  ;  ;  ; namespace detail { template<typename IteratorT> class IteratorRange { public:   typedef IteratorT iterator;   typedef IteratorT const_iterator;   typedef ReverseIterator<IteratorT> reverse_iterator;   typedef ReverseIterator<IteratorT> const_reverse_iterator;     ;     ;                     reverse_iterator rend() const { return reverse_iterator(mIterBegin); }   const_reverse_iterator crend() const { return rend(); } private:   IteratorT mIterBegin;   IteratorT mIterEnd; }; } template<typename Range> detail::IteratorRange<typename Range::reverse_iterator> Reversed(Range& aRange) {   return {aRange.rbegin(), aRange.rend()}; } template<typename Range> detail::IteratorRange<typename Range::const_reverse_iterator> Reversed(const Range& aRange) {   return {aRange.rbegin(), aRange.rend()}; } }
# 16 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Array.h" 2
# 1 "/usr/local/bin/../lib/clang/3.9.1/include/stddef.h" 1 3
# 18 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Array.h" 2
namespace mozilla { template<typename T, size_t Length> class Array {   T mArr[Length]; public:   Array() {}   template <typename... Args>                Array(Args&&... aArgs)     : mArr{mozilla::Forward<Args>(aArgs)...}   {     static_assert(sizeof...(aArgs) == Length,                   "The number of arguments should be equal to the template parameter Length");   }   T& operator[](size_t aIndex)   {     do { static_assert(mozilla::detail::AssertionConditionType<decltype(aIndex < Length)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(aIndex < Length))), 0))) { MOZ_ReportAssertionFailure("aIndex < Length", "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Array.h", 39); do { } while (0); do { *((volatile int*) __null) = 39; ::abort(); } while (0); } } while (0);     return mArr[aIndex];   }   const T& operator[](size_t aIndex) const   {     do { static_assert(mozilla::detail::AssertionConditionType<decltype(aIndex < Length)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(aIndex < Length))), 0))) { MOZ_ReportAssertionFailure("aIndex < Length", "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Array.h", 45); do { } while (0); do { *((volatile int*) __null) = 45; ::abort(); } while (0); } } while (0);     return mArr[aIndex];   }   bool operator==(const Array<T, Length>& aOther) const   {     for (size_t i = 0; i < Length; i++) {       if (mArr[i] != aOther[i]) {         return false;       }     }     return true;   }   typedef T* iterator;   typedef const T* const_iterator;   typedef ReverseIterator<T*> reverse_iterator;   typedef ReverseIterator<const T*> const_reverse_iterator;   iterator begin() { return mArr; }   const_iterator begin() const { return mArr; }   const_iterator cbegin() const { return begin(); }   iterator end() { return mArr + Length; }   const_iterator end() const { return mArr + Length; }                      }; template<typename T> class Array<T, 0> { public:       }; }
# 13 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/EnumeratedArray.h" 2
namespace mozilla { 
# 41 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/EnumeratedArray.h"
template<typename IndexType,          IndexType SizeAsEnumValue,          typename ValueType> class EnumeratedArray { public:   static const size_t kSize = size_t(SizeAsEnumValue); private:   typedef Array<ValueType, kSize> ArrayType;   ArrayType mArray; public:   EnumeratedArray() {}   template <typename... Args>                EnumeratedArray(Args&&... aArgs)     : mArray{mozilla::Forward<Args>(aArgs)...}   {}   explicit EnumeratedArray(const EnumeratedArray& aOther)   {     for (size_t i = 0; i < kSize; i++) {       mArray[i] = aOther.mArray[i];     }   }   EnumeratedArray(EnumeratedArray&& aOther)   {     for (size_t i = 0; i < kSize; i++) {       mArray[i] = Move(aOther.mArray[i]);     }   }   ValueType& operator[](IndexType aIndex)   {     return mArray[size_t(aIndex)];   }   const ValueType& operator[](IndexType aIndex) const   {     return mArray[size_t(aIndex)];   }   typedef typename ArrayType::iterator iterator;   typedef typename ArrayType::const_iterator const_iterator;   typedef typename ArrayType::reverse_iterator reverse_iterator;   typedef typename ArrayType::const_reverse_iterator const_reverse_iterator;   iterator begin() { return mArray.begin(); }   const_iterator begin() const { return mArray.begin(); }   const_iterator cbegin() const { return mArray.cbegin(); }   iterator end() { return mArray.end(); }                         }; }
# 16 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/jspubtd.h" 2
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/PodOperations.h" 1
# 13 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Alignment.h"
# 1 "/usr/local/bin/../lib/clang/3.9.1/include/stddef.h" 1 3
# 14 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Alignment.h" 2
namespace mozilla { template<typename T> class AlignmentFinder {   struct Aligner   {     char mChar;     T mT;   }; public:   static const size_t alignment = sizeof(Aligner) - sizeof(T); }; 
# 64 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Alignment.h"
template<size_t Align> struct AlignedElem; template<> struct AlignedElem<1> {   uint8_t elem __attribute__((aligned(1))); }; template<> struct AlignedElem<2> {   uint8_t elem __attribute__((aligned(2))); }; template<> struct AlignedElem<4> {   uint8_t elem __attribute__((aligned(4))); }; template<> struct AlignedElem<8> {   uint8_t elem __attribute__((aligned(8))); }; template<> struct AlignedElem<16> {   uint8_t elem __attribute__((aligned(16))); }; template<typename T> struct AlignedStorage2 {   union U   {     char mBytes[sizeof(T)];     uint64_t mDummy;   } u;                }; }
# 20 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/PodOperations.h" 2
# 1 "/usr/include/string.h" 1 3 4
# 27 "/usr/include/string.h" 3 4
extern "C" { 
# 1 "/usr/local/bin/../lib/clang/3.9.1/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4
# 656 "/usr/include/string.h" 3 4
}
# 24 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/PodOperations.h" 2
namespace mozilla { template<typename T> static void PodZero(T* aT) ; template<typename T> static void PodZero(T* aT, size_t aNElem) ; 
# 57 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/PodOperations.h"
template<typename T, size_t N> static void PodZero(T (&aT)[N]) = delete; template<typename T, size_t N> static void PodZero(T (&aT)[N], size_t aNElem) = delete; template <class T, size_t N> static void PodArrayZero(T (&aT)[N]) ; template <typename T, size_t N> static void PodArrayZero(Array<T, N>& aArr) ; template<typename T> static void PodAssign(T* aDst, const T* aSrc) ; template<typename T> static void PodCopy(T* aDst, const T* aSrc, size_t aNElem) ;  ;  ;  ;  ;  ; }
# 15 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Casting.h"
# 1 "/usr/local/bin/../lib/clang/3.9.1/include/limits.h" 1 3
# 37 "/usr/local/bin/../lib/clang/3.9.1/include/limits.h" 3
# 1 "/usr/include/limits.h" 1 3 4
# 143 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/exception" 1 3
# 34 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/exception" 3
#pragma GCC visibility push(default)
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/atomic_lockfree_defines.h" 1 3
# 34 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/atomic_lockfree_defines.h" 3
# 39 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/exception" 2 3
extern "C++" { namespace std { 
# 60 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/exception" 3
  class exception   {   public:     exception() noexcept { }     virtual ~exception() noexcept;     virtual const char*     what() const noexcept;   };   class bad_exception : public exception   {   public:     bad_exception() noexcept { }     virtual ~bad_exception() noexcept;     virtual const char*     what() const noexcept;   };   typedef void (*terminate_handler) ();   typedef void (*unexpected_handler) ();   terminate_handler set_terminate(terminate_handler) noexcept;   terminate_handler get_terminate() noexcept;   void terminate() noexcept __attribute__ ((__noreturn__));   unexpected_handler set_unexpected(unexpected_handler) noexcept;   unexpected_handler get_unexpected() noexcept;   void unexpected() __attribute__ ((__noreturn__)); 
# 129 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/exception" 3
  bool uncaught_exception() noexcept __attribute__ ((__pure__)); 
# 138 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/exception" 3
} namespace __gnu_cxx { 
# 160 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/exception" 3
  void __verbose_terminate_handler(); } }
#pragma GCC visibility pop
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/exception_ptr.h" 1 3
# 34 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/exception_defines.h" 1 3
# 38 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/exception_ptr.h" 2 3
extern "C++" { namespace std {   class type_info;   namespace __exception_ptr   {     class exception_ptr;   }   using __exception_ptr::exception_ptr;   exception_ptr current_exception() noexcept;   void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));   namespace __exception_ptr   {     using std::rethrow_exception;     class exception_ptr     {       void* _M_exception_object;       explicit exception_ptr(void* __e) noexcept;       void _M_addref() noexcept;       void _M_release() noexcept;       void *_M_get() const noexcept __attribute__ ((__pure__));       friend exception_ptr std::current_exception() noexcept;       friend void std::rethrow_exception(exception_ptr);     public:       exception_ptr() noexcept;       exception_ptr(const exception_ptr&) noexcept;       exception_ptr(nullptr_t) noexcept       : _M_exception_object(0)       { }       exception_ptr(exception_ptr&& __o) noexcept       : _M_exception_object(__o._M_exception_object)       { __o._M_exception_object = 0; } 
# 113 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/exception_ptr.h" 3
      exception_ptr&       operator=(const exception_ptr&) noexcept;       exception_ptr&       operator=(exception_ptr&& __o) noexcept       {         exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);         return *this;       }       ~exception_ptr() noexcept;       void       swap(exception_ptr&) noexcept; 
# 140 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/exception_ptr.h" 3
      explicit operator bool() const       ;       friend bool       operator==(const exception_ptr&, const exception_ptr&)  noexcept __attribute__ ((__pure__));       const class std::type_info*       __cxa_exception_type() const noexcept  __attribute__ ((__pure__));     };     bool     operator==(const exception_ptr&, const exception_ptr&)       noexcept __attribute__ ((__pure__));     bool     operator!=(const exception_ptr&, const exception_ptr&)       noexcept __attribute__ ((__pure__));      void     swap(exception_ptr& __lhs, exception_ptr& __rhs)     ;   }   template<typename _Ex>     exception_ptr     make_exception_ptr(_Ex __ex) noexcept     {       try  {    throw __ex;  }       catch(...)  {    return current_exception();  }     }   template<typename _Ex>     exception_ptr     copy_exception(_Ex __ex) noexcept __attribute__ ((__deprecated__));   template<typename _Ex>     exception_ptr     copy_exception(_Ex __ex) noexcept     { return std::make_exception_ptr<_Ex>(__ex); } } }
#pragma GCC visibility pop
# 171 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/exception" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/nested_exception.h" 1 3
# 33 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/nested_exception.h" 3
#pragma GCC visibility push(default)
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/move.h" 1 3
# 34 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/move.h" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/concept_check.h" 1 3
# 34 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/concept_check.h" 3
# 35 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/move.h" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _Tp>     inline _Tp*     __addressof(_Tp& __r) noexcept     {       return reinterpret_cast<_Tp*>  (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));     } }
 namespace std __attribute__ ((__visibility__ ("default"))) { 
# 74 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/move.h" 3
  template<typename _Tp>     constexpr _Tp&&     forward(typename std::remove_reference<_Tp>::type& __t) noexcept     { return static_cast<_Tp&&>(__t); }   template<typename _Tp>     constexpr _Tp&&     forward(typename std::remove_reference<_Tp>::type&& __t) noexcept     {       static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"       " substituting _Tp is an lvalue reference type");       return static_cast<_Tp&&>(__t);     }   template<typename _Tp>     constexpr typename std::remove_reference<_Tp>::type&&     move(_Tp&& __t) noexcept     { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }   template<typename _Tp>     struct __move_if_noexcept_cond     : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,                     is_copy_constructible<_Tp>>::type { }; 
# 118 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/move.h" 3
  template<typename _Tp>     constexpr typename     conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type     move_if_noexcept(_Tp& __x) noexcept     { return std::move(__x); } 
# 133 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/move.h" 3
  template<typename _Tp>     inline _Tp*     addressof(_Tp& __r) noexcept     { return std::__addressof(__r); }   template <typename _Tp, typename _Up = _Tp>     inline _Tp     __exchange(_Tp& __obj, _Up&& __new_val)     {       _Tp __old_val = std::move(__obj);       __obj = std::forward<_Up>(__new_val);       return __old_val;     } }
# 159 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) { 
# 174 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/move.h" 3
  template<typename _Tp>     inline     typename enable_if<__and_<is_move_constructible<_Tp>,          is_move_assignable<_Tp>>::value>::type     swap(_Tp& __a, _Tp& __b)     noexcept(__and_<is_nothrow_move_constructible<_Tp>,              is_nothrow_move_assignable<_Tp>>::value)     {       _Tp __tmp = std::move(__a);       __a = std::move(__b);       __b = std::move(__tmp);     }   template<typename _Tp, size_t _Nm>     inline     typename enable_if<__is_swappable<_Tp>::value>::type     swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])     noexcept(__is_nothrow_swappable<_Tp>::value)     {       for (size_t __n = 0; __n < _Nm; ++__n)  swap(__a[__n], __b[__n]);     } }
extern "C++" { namespace std {   class bad_alloc : public exception   {   public:     bad_alloc() throw() ;     virtual ~bad_alloc() throw();     virtual const char* what() const throw();   };   class bad_array_new_length : public bad_alloc   {   public:     bad_array_new_length() throw() ;;     virtual ~bad_array_new_length() throw();        };   struct nothrow_t   {        };   extern const nothrow_t nothrow;   typedef void (*new_handler)();      new_handler get_new_handler() noexcept; } 
# 116 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/new" 3
void* operator new(std::size_t)   __attribute__((__externally_visible__)); void* operator new[](std::size_t)   __attribute__((__externally_visible__)); void operator delete(void*) noexcept   __attribute__((__externally_visible__)); void operator delete[](void*) noexcept   __attribute__((__externally_visible__)); void* operator new(std::size_t, const std::nothrow_t&) noexcept   __attribute__((__externally_visible__)); void* operator new[](std::size_t, const std::nothrow_t&) noexcept   __attribute__((__externally_visible__)); void operator delete(void*, const std::nothrow_t&) noexcept   __attribute__((__externally_visible__)); void operator delete[](void*, const std::nothrow_t&) noexcept   __attribute__((__externally_visible__)); 
# 146 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/new" 3
inline void* operator new(std::size_t, void* __p) noexcept { return __p; } inline void* operator new[](std::size_t, void* __p) noexcept { return __p; } inline void operator delete (void*, void*) noexcept { } inline void operator delete[](void*, void*) noexcept { } }
#pragma GCC visibility pop
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TemplateLib.h" 1
# 21 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TemplateLib.h"
# 1 "/usr/local/bin/../lib/clang/3.9.1/include/stddef.h" 1 3
# 22 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TemplateLib.h" 2
namespace mozilla { namespace tl { template<size_t Size, size_t... Rest> struct Min {   static constexpr size_t value =     Size < Min<Rest...>::value     ? Size     : Min<Rest...>::value; }; template<size_t Size> struct Min<Size> {   static constexpr size_t value = Size; }; template<size_t Size, size_t... Rest> struct Max {   static constexpr size_t value =     Size > Max<Rest...>::value     ? Size     : Max<Rest...>::value; }; template<size_t Size> struct Max<Size> {   static constexpr size_t value = Size; }; template<size_t I> struct FloorLog2 {   static const size_t value = 1 + FloorLog2<I / 2>::value; }; template<> struct FloorLog2<0> { }; template<> struct FloorLog2<1> { static const size_t value = 0; }; template<size_t I> struct CeilingLog2 {   static const size_t value = FloorLog2<2 * I - 1>::value; }; template<size_t I> struct RoundUpPow2 {   static const size_t value = size_t(1) << CeilingLog2<I>::value; }; template<> struct RoundUpPow2<0> {   static const size_t value = 1; }; template<typename T> struct BitSize {   static const size_t value = sizeof(T) * 8; }; template<size_t N> struct NBitMask {   static const size_t checkPrecondition =     0 / size_t(N < BitSize<size_t>::value);   static const size_t value = (size_t(1) << N) - 1 + checkPrecondition; }; template<> struct NBitMask<BitSize<size_t>::value> {   static const size_t value = size_t(-1); }; template<size_t N> struct MulOverflowMask {   static const size_t value =     ~NBitMask<BitSize<size_t>::value - CeilingLog2<N>::value>::value; }; template<> struct MulOverflowMask<0> { }; template<> struct MulOverflowMask<1> { static const size_t value = 0; }; 
# 138 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TemplateLib.h"
template<bool...> struct And; template<> struct And<> : public TrueType { }; template<bool C1, bool... Cn> struct And<C1, Cn...>   : public Conditional<C1, And<Cn...>, FalseType>::Type { }; } }
# 16 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Variant.h" 2
namespace mozilla { template<typename... Ts> class Variant; namespace detail { template <typename...> struct FirstTypeIsInRest; template <typename First> struct FirstTypeIsInRest<First> : FalseType {}; template <typename First, typename Second, typename... Rest> struct FirstTypeIsInRest<First, Second, Rest...> {   static constexpr bool value =     IsSame<First, Second>::value ||     FirstTypeIsInRest<First, Rest...>::value; }; template <typename...> struct TypesAreDistinct; template <> struct TypesAreDistinct<> : TrueType { }; template<typename First, typename... Rest> struct TypesAreDistinct<First, Rest...> {   static constexpr bool value =     !FirstTypeIsInRest<First, Rest...>::value &&     TypesAreDistinct<Rest...>::value; }; template<typename Needle, typename... Haystack> struct IsVariant; template<typename Needle> struct IsVariant<Needle> : FalseType {}; template<typename Needle, typename... Haystack> struct IsVariant<Needle, Needle, Haystack...> : TrueType {}; template<typename Needle, typename T, typename... Haystack> struct IsVariant<Needle, T, Haystack...> : public IsVariant<Needle, Haystack...> { }; template<typename T, typename... Variants> struct SelectVariantTypeHelper; template<typename T> struct SelectVariantTypeHelper<T> { }; template<typename T, typename... Variants> struct SelectVariantTypeHelper<T, T, Variants...> {   typedef T Type; }; template<typename T, typename... Variants> struct SelectVariantTypeHelper<T, const T, Variants...> {   typedef const T Type; }; template<typename T, typename... Variants> struct SelectVariantTypeHelper<T, const T&, Variants...> {   typedef const T& Type; }; template<typename T, typename... Variants> struct SelectVariantTypeHelper<T, T&&, Variants...> {   typedef T&& Type; }; template<typename T, typename Head, typename... Variants> struct SelectVariantTypeHelper<T, Head, Variants...>   : public SelectVariantTypeHelper<T, Variants...> { }; template <typename T, typename... Variants> struct SelectVariantType   : public SelectVariantTypeHelper<typename RemoveConst<typename RemoveReference<T>::Type>::Type,                                    Variants...> { }; template<typename... Ts> struct VariantTag { private:   static const size_t TypeCount = sizeof...(Ts); public:   using Type =     typename Conditional<TypeCount < 3,                          bool,                          typename Conditional<TypeCount < (1 << 8),                                               uint_fast8_t,                                               size_t                                               >::Type                          >::Type; }; template<typename Tag, size_t N, typename T, typename U, typename Next, bool isMatch> struct TagHelper; template<typename Tag, size_t N, typename T, typename U, typename Next> struct TagHelper<Tag, N, T, U, Next, false> {    }; template<typename Tag, size_t N, typename T, typename U, typename Next> struct TagHelper<Tag, N, T, U, Next, true> {    }; template<typename Tag, size_t N, typename... Ts> struct VariantImplementation; template<typename Tag, size_t N, typename T> struct VariantImplementation<Tag, N, T> {    ;    ;    ;   template<typename Variant>   static void destroy(Variant& aV) ;   template<typename Variant>   static bool   equal(const Variant& aLhs, const Variant& aRhs) ;   template<typename Matcher, typename ConcreteVariant>   static auto   match(Matcher&& aMatcher, ConcreteVariant& aV)     -> decltype(aMatcher.match(aV.template as<T>()))   {     return aMatcher.match(aV.template as<T>());   } }; template<typename Tag, size_t N, typename T, typename... Ts> struct VariantImplementation<Tag, N, T, Ts...> {   using Next = VariantImplementation<Tag, N + 1, Ts...>;   template<typename U>   static Tag tag() ;   template<typename Variant>   static void copyConstruct(void* aLhs, const Variant& aRhs) ;   template<typename Variant>   static void moveConstruct(void* aLhs, Variant&& aRhs) ;   template<typename Variant>   static void destroy(Variant& aV) ;   template<typename Variant>   static bool equal(const Variant& aLhs, const Variant& aRhs) ;   template<typename Matcher, typename ConcreteVariant>   static auto   match(Matcher&& aMatcher, ConcreteVariant& aV)     -> decltype(aMatcher.match(aV.template as<T>()))   {     if (aV.template is<T>()) {       return aMatcher.match(aV.template as<T>());     } else { 
# 278 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Variant.h"
      return Next::match(aMatcher, aV);     }   } }; template <typename T> struct AsVariantTemporary {   explicit AsVariantTemporary(const T& aValue)    ;       ;                  typename RemoveConst<typename RemoveReference<T>::Type>::Type mValue; }; } 
# 447 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Variant.h"
template<typename... Ts> class Variant {      using Tag = typename detail::VariantTag<Ts...>::Type;   using Impl = detail::VariantImplementation<Tag, 0, Ts...>;   static constexpr size_t RawDataAlignment = tl::Max<alignof(Ts)...>::value;   static constexpr size_t RawDataSize = tl::Max<sizeof(Ts)...>::value;   alignas(RawDataAlignment) unsigned char rawData[RawDataSize];   Tag tag;       public:       ;       ;                  ;      template<typename T>   bool is() const ;   bool operator==(const Variant& aRhs) const ;   bool operator!=(const Variant& aRhs) const ;   template<typename T>   T& as() ;   template<typename T>   const T& as() const ;   template<typename T>   T extract() ;   template<typename Matcher>   auto   match(Matcher&& aMatcher) const     -> decltype(Impl::match(aMatcher, *this))   {     return Impl::match(aMatcher, *this);   }   template<typename Matcher>   auto   match(Matcher&& aMatcher)     -> decltype(Impl::match(aMatcher, *this))   {     return Impl::match(aMatcher, *this);   } }; 
# 642 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Variant.h"
template<typename T> detail::AsVariantTemporary<T> AsVariant(T&& aValue) ; }
# 18 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Result.h" 2
namespace mozilla { struct Ok {}; template <typename E> class GenericErrorResult; template <typename V, typename E> class Result; namespace detail { enum class PackingStrategy {   Variant,   NullIsOk,   LowBitTagIsError,   PackedVariant, }; template <typename V, typename E, PackingStrategy Strategy> class ResultImplementation; template <typename V, typename E> class ResultImplementation<V, E, PackingStrategy::Variant> {   mozilla::Variant<V, E> mStorage; public:   explicit ResultImplementation(V aValue) : mStorage(aValue) {}   explicit ResultImplementation(E aErrorValue) : mStorage(aErrorValue) {}   bool isOk() const { return mStorage.template is<V>(); }   V unwrap() const { return mStorage.template as<V>(); }   E unwrapErr() const { return mStorage.template as<E>(); } }; template <typename V, typename E> class ResultImplementation<V, E&, PackingStrategy::Variant> {   mozilla::Variant<V, E*> mStorage; public:   explicit ResultImplementation(V aValue) : mStorage(aValue) {}   explicit ResultImplementation(E& aErrorValue) : mStorage(&aErrorValue) {}   bool isOk() const { return mStorage.template is<V>(); }   V unwrap() const { return mStorage.template as<V>(); }   E& unwrapErr() const { return *mStorage.template as<E*>(); } }; template <typename V, typename E> class ResultImplementation<V, E&, PackingStrategy::NullIsOk> {   E* mErrorValue; public:   explicit ResultImplementation(V) : mErrorValue(nullptr) {}   explicit ResultImplementation(E& aErrorValue) : mErrorValue(&aErrorValue) {}   bool isOk() const { return mErrorValue == nullptr; }   V unwrap() const { return V(); }   E& unwrapErr() const { return *mErrorValue; } }; template <typename V, typename E> class ResultImplementation<V*, E&, PackingStrategy::LowBitTagIsError> {   uintptr_t mBits; public:   explicit ResultImplementation(V* aValue)     : mBits(reinterpret_cast<uintptr_t>(aValue))   {     do { static_assert(mozilla::detail::AssertionConditionType<decltype((uintptr_t(aValue) % mozilla::AlignmentFinder<V>::alignment) == 0)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!((uintptr_t(aValue) % mozilla::AlignmentFinder<V>::alignment) == 0))), 0))) { MOZ_ReportAssertionFailure("(uintptr_t(aValue) % mozilla::AlignmentFinder<V>::alignment) == 0" " (" "Result value pointers must not be misaligned" ")", "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Result.h", 112); do { } while (0); do { *((volatile int*) __null) = 112; ::abort(); } while (0); } } while (0);   }   explicit ResultImplementation(E& aErrorValue)     : mBits(reinterpret_cast<uintptr_t>(&aErrorValue) | 1)   {     do { static_assert(mozilla::detail::AssertionConditionType<decltype((uintptr_t(&aErrorValue) % mozilla::AlignmentFinder<E>::alignment) == 0)>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!((uintptr_t(&aErrorValue) % mozilla::AlignmentFinder<E>::alignment) == 0))), 0))) { MOZ_ReportAssertionFailure("(uintptr_t(&aErrorValue) % mozilla::AlignmentFinder<E>::alignment) == 0" " (" "Result errors must not be misaligned" ")", "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Result.h", 118); do { } while (0); do { *((volatile int*) __null) = 118; ::abort(); } while (0); } } while (0);   }   bool isOk() const { return (mBits & 1) == 0; }   V* unwrap() const { return reinterpret_cast<V*>(mBits); }   E& unwrapErr() const { return *reinterpret_cast<E*>(mBits ^ 1); } }; template<typename V, typename E> struct IsPackableVariant {   struct VEbool {       V v;       E e;       bool ok;   };   struct EVbool {       E e;       V v;       bool ok;   };   using Impl = typename Conditional<sizeof(VEbool) <= sizeof(EVbool),                                     VEbool, EVbool>::Type;   static const bool value = sizeof(Impl) <= sizeof(uintptr_t); }; template <typename V, typename E> class ResultImplementation<V, E, PackingStrategy::PackedVariant> {   using Impl = typename IsPackableVariant<V, E>::Impl;   Impl data; public:   explicit ResultImplementation(V aValue)   {     data.v = aValue;     data.ok = true;   }   explicit ResultImplementation(E aErrorValue)   {     data.e = aErrorValue;     data.ok = false;   }   bool isOk() const { return data.ok; }   V unwrap() const { return data.v; }   E unwrapErr() const { return data.e; } }; template<typename T> struct UnusedZero {   static const bool value = false; }; template<typename T> struct UnusedZero<T&> {   static const bool value = true; }; template <typename T> struct HasFreeLSB { static const bool value = false; }; template <typename T> struct HasFreeLSB<T*> {   static const bool value = (mozilla::AlignmentFinder<T>::alignment & 1) == 0; }; template <typename T> struct HasFreeLSB<T&> {   static const bool value = HasFreeLSB<T*>::value; }; template <typename V, typename E> struct SelectResultImpl {   static const PackingStrategy value =       (IsEmpty<V>::value && UnusedZero<E>::value)     ? PackingStrategy::NullIsOk     : (detail::HasFreeLSB<V>::value && detail::HasFreeLSB<E>::value)     ? PackingStrategy::LowBitTagIsError     : (IsDefaultConstructible<V>::value && IsDefaultConstructible<E>::value &&        IsPackableVariant<V, E>::value)     ? PackingStrategy::PackedVariant     : PackingStrategy::Variant;   using Type = detail::ResultImplementation<V, E, value>; }; template <typename T> struct IsResult : FalseType { }; template <typename V, typename E> struct IsResult<Result<V, E>> : TrueType { }; } 
# 263 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Result.h"
template <typename V, typename E> class Result final {   using Impl = typename detail::SelectResultImpl<V, E>::Type;   Impl mImpl; public:                Result(V aValue)  ;   explicit Result(E aErrorValue)  ;   template <typename E2>                Result(const GenericErrorResult<E2>& aErrorResult)    ;   Result(const Result&) = default;   Result& operator=(const Result&) = default;   bool isOk() const ;   bool isErr() const ;   V unwrap() const ;   E unwrapErr() const ; 
# 340 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Result.h"
  template<typename F>   auto map(F f) const -> Result<decltype(f(*((V*) nullptr))), E> {       using RetResult = Result<decltype(f(*((V*) nullptr))), E>;       return isOk() ? RetResult(f(unwrap())) : RetResult(unwrapErr());   } 
# 374 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Result.h"
  template<       typename F,       typename = typename EnableIf<           detail::IsResult<decltype((*((F*) nullptr))(*((V*) nullptr)))>::value       >::Type   >   auto andThen(F f) const -> decltype(f(*((V*) nullptr))) {       return isOk() ? f(unwrap()) : GenericErrorResult<E>(unwrapErr());   } }; template <typename E> class GenericErrorResult {   E mErrorValue;   template<typename V, typename E2> friend class Result; public:   explicit GenericErrorResult(E aErrorValue)  ; }; template <typename E>  GenericErrorResult<E> Err(E&& aErrorValue) ; }
# 120 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/Result.h" 2
namespace mozilla { namespace detail { enum StorageType { AsBase, AsMember }; 
# 29 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Pair.h"
template<typename A, typename B,          detail::StorageType =            IsEmpty<A>::value ? detail::AsBase : detail::AsMember,          detail::StorageType =            IsEmpty<B>::value && !IsBaseOf<A, B>::value && !IsBaseOf<B, A>::value            ? detail::AsBase            : detail::AsMember> struct PairHelper; template<typename A, typename B> struct PairHelper<A, B, AsMember, AsMember> { protected:   template<typename AArg, typename BArg>   PairHelper(AArg&& aA, BArg&& aB)    ;   A& first() ;             private:   A mFirstA;   B mSecondB; }; template<typename A, typename B> struct PairHelper<A, B, AsMember, AsBase> : private B { protected:       ;               void swap(PairHelper& aOther)   {     Swap(mFirstA, aOther.mFirstA);     Swap(static_cast<B&>(*this), static_cast<B&>(aOther));   } private:   A mFirstA; }; template<typename A, typename B> struct PairHelper<A, B, AsBase, AsMember> : private A { protected:                   private:   B mSecondB; }; template<typename A, typename B> struct PairHelper<A, B, AsBase, AsBase> : private A, private B { protected:       ;                }; } 
# 151 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Pair.h"
template<typename A, typename B> struct Pair   : private detail::PairHelper<A, B> {   typedef typename detail::PairHelper<A, B> Base; public:       ;               using Base::first;   using Base::second;   void swap(Pair& aOther) ; }; template<typename A, class B> void Swap(Pair<A, B>& aX, Pair<A, B>& aY) ; 
# 205 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Pair.h"
template<typename A, typename B> Pair<typename RemoveCV<typename RemoveReference<A>::Type>::Type,      typename RemoveCV<typename RemoveReference<B>::Type>::Type> MakePair(A&& aA, B&& aB) ; }
# 17 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/UniquePtr.h" 2
namespace mozilla { template<typename T> class DefaultDelete; template<typename T, class D = DefaultDelete<T>> class UniquePtr; }
 namespace mozilla { namespace detail { struct HasPointerTypeHelper {   template <class U> static double Test(...);   template <class U> static char Test(typename U::pointer* = 0); }; template <class T> class HasPointerType : public IntegralConstant<bool, sizeof(HasPointerTypeHelper::Test<T>(0)) == 1> { }; template <class T, class D, bool = HasPointerType<D>::value> struct PointerTypeImpl {   typedef typename D::pointer Type; }; template <class T, class D> struct PointerTypeImpl<T, D, false> {   typedef T* Type; }; template <class T, class D> struct PointerType {   typedef typename PointerTypeImpl<T, typename RemoveReference<D>::Type>::Type Type; }; } 
# 187 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/UniquePtr.h"
template<typename T, class D> class UniquePtr { public:   typedef T ElementType;   typedef D DeleterType;   typedef typename detail::PointerType<T, DeleterType>::Type Pointer; private:   Pair<Pointer, DeleterType> mTuple;   Pointer& ptr() ;   const Pointer& ptr() const ;       public:   constexpr UniquePtr()     : mTuple(static_cast<Pointer>(nullptr), DeleterType())   {     static_assert(!IsPointer<D>::value, "must provide a deleter instance");     static_assert(!IsReference<D>::value, "must provide a deleter instance");   }       
# 254 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/UniquePtr.h"
                                   Pointer get() const ;            void reset(Pointer aPtr = Pointer())   ;   void swap(UniquePtr& aOther)   ;   UniquePtr(const UniquePtr& aOther) = delete;   void operator=(const UniquePtr& aOther) = delete; }; template<typename T, class D> class UniquePtr<T[], D> { public:   typedef T* Pointer;   typedef T ElementType;   typedef D DeleterType; private:   Pair<Pointer, DeleterType> mTuple; public:   constexpr UniquePtr()     : mTuple(static_cast<Pointer>(nullptr), DeleterType())   {     static_assert(!IsPointer<D>::value, "must provide a deleter instance");     static_assert(!IsReference<D>::value, "must provide a deleter instance");   }   explicit UniquePtr(Pointer aPtr)    ;   template<typename U>   UniquePtr(U&& aU,             typename EnableIf<IsPointer<U>::value &&                               IsConvertible<U, Pointer>::value,                               int>::Type aDummy = 0)   = delete;   UniquePtr(Pointer aPtr,             typename Conditional<IsReference<D>::value,                                  D,                                  const D&>::Type aD1)    ;   UniquePtr(Pointer aPtr,             typename RemoveReference<D>::Type&& aD2)    ;   template<typename U, typename V>   UniquePtr(U&& aU, V&& aV,             typename EnableIf<IsPointer<U>::value &&                               IsConvertible<U, Pointer>::value,                               int>::Type aDummy = 0)   = delete;   UniquePtr(UniquePtr&& aOther)    ;   UniquePtr(decltype(nullptr))     : mTuple(nullptr, DeleterType())   {     static_assert(!IsPointer<D>::value, "must provide a deleter instance");     static_assert(!IsReference<D>::value, "must provide a deleter instance");   }   ~UniquePtr() { reset(nullptr); }   UniquePtr& operator=(UniquePtr&& aOther)   {     reset(aOther.release());     get_deleter() = Forward<DeleterType>(aOther.get_deleter());     return *this;   }   UniquePtr& operator=(decltype(nullptr))   {     reset();     return *this;   }   explicit operator bool() const { return get() != nullptr; }   T& operator[](decltype(sizeof(int)) aIndex) const { return get()[aIndex]; }   Pointer get() const { return mTuple.first(); }   DeleterType& get_deleter() { return mTuple.second(); }   const DeleterType& get_deleter() const { return mTuple.second(); }   __attribute__ ((warn_unused_result)) Pointer release()   ;   void reset(Pointer aPtr = Pointer())   ;   void reset(decltype(nullptr))   ;   template<typename U>   void reset(U) = delete;   void swap(UniquePtr& aOther) ;   UniquePtr(const UniquePtr& aOther) = delete;   void operator=(const UniquePtr& aOther) = delete; }; 
# 513 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/UniquePtr.h"
template<typename T> class DefaultDelete { public:   constexpr DefaultDelete() {}   template<typename U>                DefaultDelete(const DefaultDelete<U>& aOther,                              typename EnableIf<mozilla::IsConvertible<U*, T*>::value,                                                int>::Type aDummy = 0)   ;   void operator()(T* aPtr) const   ; }; template<typename T> class DefaultDelete<T[]> { public:   constexpr DefaultDelete() {}   void operator()(T* aPtr) const   ;   template<typename U>   void operator()(U* aPtr) const = delete; }; template<typename T, class D> void Swap(UniquePtr<T, D>& aX, UniquePtr<T, D>& aY) ; template<typename T, class D, typename U, class E> bool operator==(const UniquePtr<T, D>& aX, const UniquePtr<U, E>& aY) ; template<typename T, class D, typename U, class E> bool operator!=(const UniquePtr<T, D>& aX, const UniquePtr<U, E>& aY) ; template<typename T, class D> bool operator==(const UniquePtr<T, D>& aX, decltype(nullptr)) ; template<typename T, class D> bool operator==(decltype(nullptr), const UniquePtr<T, D>& aX) ; template<typename T, class D> bool operator!=(const UniquePtr<T, D>& aX, decltype(nullptr)) ; template<typename T, class D> bool operator!=(decltype(nullptr), const UniquePtr<T, D>& aX) ; namespace detail { template<typename T> struct UniqueSelector {   typedef UniquePtr<T> SingleObject; }; template<typename T> struct UniqueSelector<T[]> {   typedef UniquePtr<T[]> UnknownBound; }; template<typename T, decltype(sizeof(int)) N> struct UniqueSelector<T[N]> {   typedef UniquePtr<T[N]> KnownBound; }; } 
# 676 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/UniquePtr.h"
template<typename T, typename... Args> typename detail::UniqueSelector<T>::SingleObject MakeUnique(Args&&... aArgs) ; template<typename T> typename detail::UniqueSelector<T>::UnknownBound MakeUnique(decltype(sizeof(int)) aN) {   typedef typename RemoveExtent<T>::Type ArrayType;   return UniquePtr<T>(new ArrayType[aN]()); } template<typename T, typename... Args> typename detail::UniqueSelector<T>::KnownBound MakeUnique(Args&&... aArgs) = delete; }
# 11 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/TraceKind.h" 2
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/TypeDecls.h" 1
# 20 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/TypeDecls.h"
# 1 "/usr/local/bin/../lib/clang/3.9.1/include/stddef.h" 1 3
# 21 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/TypeDecls.h" 2
struct JSContext;
 class JSFunction;
 class JSObject;
 class JSScript;
 class JSString;
 class JSAddonId;
 struct jsid;
 namespace JS { typedef unsigned char Latin1Char; class Symbol; class Value; template <typename T> class Handle; template <typename T> class MutableHandle; template <typename T> class Rooted; template <typename T> class PersistentRooted; typedef Handle<JSFunction*> HandleFunction; typedef Handle<jsid> HandleId; typedef Handle<JSObject*> HandleObject; typedef Handle<JSScript*> HandleScript; typedef Handle<JSString*> HandleString; typedef Handle<JS::Symbol*> HandleSymbol; typedef Handle<Value> HandleValue; typedef MutableHandle<JSFunction*> MutableHandleFunction; typedef MutableHandle<jsid> MutableHandleId; typedef MutableHandle<JSObject*> MutableHandleObject; typedef MutableHandle<JSScript*> MutableHandleScript; typedef MutableHandle<JSString*> MutableHandleString; typedef MutableHandle<JS::Symbol*> MutableHandleSymbol; typedef MutableHandle<Value> MutableHandleValue; typedef Rooted<JSObject*> RootedObject; typedef Rooted<JSFunction*> RootedFunction; typedef Rooted<JSScript*> RootedScript; typedef Rooted<JSString*> RootedString; typedef Rooted<JS::Symbol*> RootedSymbol; typedef Rooted<jsid> RootedId; typedef Rooted<JS::Value> RootedValue; typedef PersistentRooted<JSFunction*> PersistentRootedFunction; typedef PersistentRooted<jsid> PersistentRootedId; typedef PersistentRooted<JSObject*> PersistentRootedObject; typedef PersistentRooted<JSScript*> PersistentRootedScript; typedef PersistentRooted<JSString*> PersistentRootedString; typedef PersistentRooted<JS::Symbol*> PersistentRootedSymbol; typedef PersistentRooted<Value> PersistentRootedValue; }
# 13 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/TraceKind.h" 2
namespace js { class BaseShape; class LazyScript; class ObjectGroup; class RegExpShared; class Shape; class Scope; namespace jit { class JitCode; } }
 namespace JS { 
# 38 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/TraceKind.h"
enum class TraceKind {     Object = 0x00,     String = 0x02,     Symbol = 0x03,     Script = 0x01,     Shape = 0x04,     ObjectGroup = 0x05,     Null = 0x06,     BaseShape = 0x0F,     JitCode = 0x1F,     LazyScript = 0x2F,     Scope = 0x3F,     RegExpShared = 0x4F }; const static uintptr_t OutOfLineTraceKindMask = 0x07; static_assert(uintptr_t(JS::TraceKind::BaseShape) & OutOfLineTraceKindMask, "mask bits are set"); static_assert(uintptr_t(JS::TraceKind::JitCode) & OutOfLineTraceKindMask, "mask bits are set"); static_assert(uintptr_t(JS::TraceKind::LazyScript) & OutOfLineTraceKindMask, "mask bits are set"); static_assert(uintptr_t(JS::TraceKind::Scope) & OutOfLineTraceKindMask, "mask bits are set"); static_assert(uintptr_t(JS::TraceKind::RegExpShared) & OutOfLineTraceKindMask, "mask bits are set"); template <typename T> struct MapTypeToTraceKind {     static const JS::TraceKind kind = T::TraceKind; }; 
# 102 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/TraceKind.h"
template <> struct MapTypeToTraceKind<js::BaseShape> { static const JS::TraceKind kind = JS::TraceKind::BaseShape; }; template <> struct MapTypeToTraceKind<js::jit::JitCode> { static const JS::TraceKind kind = JS::TraceKind::JitCode; }; template <> struct MapTypeToTraceKind<js::LazyScript> { static const JS::TraceKind kind = JS::TraceKind::LazyScript; }; template <> struct MapTypeToTraceKind<js::Scope> { static const JS::TraceKind kind = JS::TraceKind::Scope; }; template <> struct MapTypeToTraceKind<JSObject> { static const JS::TraceKind kind = JS::TraceKind::Object; }; template <> struct MapTypeToTraceKind<js::ObjectGroup> { static const JS::TraceKind kind = JS::TraceKind::ObjectGroup; }; template <> struct MapTypeToTraceKind<JSScript> { static const JS::TraceKind kind = JS::TraceKind::Script; }; template <> struct MapTypeToTraceKind<js::Shape> { static const JS::TraceKind kind = JS::TraceKind::Shape; }; template <> struct MapTypeToTraceKind<JSString> { static const JS::TraceKind kind = JS::TraceKind::String; }; template <> struct MapTypeToTraceKind<JS::Symbol> { static const JS::TraceKind kind = JS::TraceKind::Symbol; }; template <> struct MapTypeToTraceKind<js::RegExpShared> { static const JS::TraceKind kind = JS::TraceKind::RegExpShared; };; enum class RootKind : int8_t { BaseShape, JitCode, LazyScript, Scope, Object, ObjectGroup, Script, Shape, String, Symbol, RegExpShared,     Id,     Value,     Traceable,     Limit }; template <TraceKind traceKind> struct MapTraceKindToRootKind {}; template <> struct MapTraceKindToRootKind<JS::TraceKind::BaseShape> { static const JS::RootKind kind = JS::RootKind::BaseShape; }; template <> struct MapTraceKindToRootKind<JS::TraceKind::JitCode> { static const JS::RootKind kind = JS::RootKind::JitCode; }; template <> struct MapTraceKindToRootKind<JS::TraceKind::LazyScript> { static const JS::RootKind kind = JS::RootKind::LazyScript; }; template <> struct MapTraceKindToRootKind<JS::TraceKind::Scope> { static const JS::RootKind kind = JS::RootKind::Scope; }; template <> struct MapTraceKindToRootKind<JS::TraceKind::Object> { static const JS::RootKind kind = JS::RootKind::Object; }; template <> struct MapTraceKindToRootKind<JS::TraceKind::ObjectGroup> { static const JS::RootKind kind = JS::RootKind::ObjectGroup; }; template <> struct MapTraceKindToRootKind<JS::TraceKind::Script> { static const JS::RootKind kind = JS::RootKind::Script; }; template <> struct MapTraceKindToRootKind<JS::TraceKind::Shape> { static const JS::RootKind kind = JS::RootKind::Shape; }; template <> struct MapTraceKindToRootKind<JS::TraceKind::String> { static const JS::RootKind kind = JS::RootKind::String; }; template <> struct MapTraceKindToRootKind<JS::TraceKind::Symbol> { static const JS::RootKind kind = JS::RootKind::Symbol; }; template <> struct MapTraceKindToRootKind<JS::TraceKind::RegExpShared> { static const JS::RootKind kind = JS::RootKind::RegExpShared; }; template <typename T> struct MapTypeToRootKind {     static const JS::RootKind kind = JS::RootKind::Traceable; }; template <typename T> struct MapTypeToRootKind<T*> {     static const JS::RootKind kind =         JS::MapTraceKindToRootKind<JS::MapTypeToTraceKind<T>::kind>::kind; }; template <typename T> struct MapTypeToRootKind<mozilla::UniquePtr<T>> {     static const JS::RootKind kind = JS::MapTypeToRootKind<T>::kind; }; template <> struct MapTypeToRootKind<JS::Value> {     static const JS::RootKind kind = JS::RootKind::Value; }; template <> struct MapTypeToRootKind<jsid> {     static const JS::RootKind kind = JS::RootKind::Id; }; template <> struct MapTypeToRootKind<JSFunction*> : public MapTypeToRootKind<JSObject*> {}; 
# 183 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/TraceKind.h"
template <typename F, typename... Args> auto DispatchTraceKindTyped(F f, JS::TraceKind traceKind, Args&&... args)   -> decltype(f. template operator()<JSObject>(mozilla::Forward<Args>(args)...)) {     switch (traceKind) {       case JS::TraceKind::BaseShape: return f. template operator()<js::BaseShape>(mozilla::Forward<Args>(args)...); case JS::TraceKind::JitCode: return f. template operator()<js::jit::JitCode>(mozilla::Forward<Args>(args)...); case JS::TraceKind::LazyScript: return f. template operator()<js::LazyScript>(mozilla::Forward<Args>(args)...); case JS::TraceKind::Scope: return f. template operator()<js::Scope>(mozilla::Forward<Args>(args)...); case JS::TraceKind::Object: return f. template operator()<JSObject>(mozilla::Forward<Args>(args)...); case JS::TraceKind::ObjectGroup: return f. template operator()<js::ObjectGroup>(mozilla::Forward<Args>(args)...); case JS::TraceKind::Script: return f. template operator()<JSScript>(mozilla::Forward<Args>(args)...); case JS::TraceKind::Shape: return f. template operator()<js::Shape>(mozilla::Forward<Args>(args)...); case JS::TraceKind::String: return f. template operator()<JSString>(mozilla::Forward<Args>(args)...); case JS::TraceKind::Symbol: return f. template operator()<JS::Symbol>(mozilla::Forward<Args>(args)...); case JS::TraceKind::RegExpShared: return f. template operator()<js::RegExpShared>(mozilla::Forward<Args>(args)...);;       default:           do { MOZ_ReportCrash("" "Invalid trace kind in DispatchTraceKindTyped.", "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/TraceKind.h", 195); do { } while (0); do { *((volatile int*) __null) = 195; ::abort(); } while (0); } while (0);     } } template <typename F, typename... Args> auto DispatchTraceKindTyped(F f, void* thing, JS::TraceKind traceKind, Args&&... args)   -> decltype(f(static_cast<JSObject*>(nullptr), mozilla::Forward<Args>(args)...)) {     switch (traceKind) {       case JS::TraceKind::BaseShape: return f(static_cast<js::BaseShape*>(thing), mozilla::Forward<Args>(args)...); case JS::TraceKind::JitCode: return f(static_cast<js::jit::JitCode*>(thing), mozilla::Forward<Args>(args)...); case JS::TraceKind::LazyScript: return f(static_cast<js::LazyScript*>(thing), mozilla::Forward<Args>(args)...); case JS::TraceKind::Scope: return f(static_cast<js::Scope*>(thing), mozilla::Forward<Args>(args)...); case JS::TraceKind::Object: return f(static_cast<JSObject*>(thing), mozilla::Forward<Args>(args)...); case JS::TraceKind::ObjectGroup: return f(static_cast<js::ObjectGroup*>(thing), mozilla::Forward<Args>(args)...); case JS::TraceKind::Script: return f(static_cast<JSScript*>(thing), mozilla::Forward<Args>(args)...); case JS::TraceKind::Shape: return f(static_cast<js::Shape*>(thing), mozilla::Forward<Args>(args)...); case JS::TraceKind::String: return f(static_cast<JSString*>(thing), mozilla::Forward<Args>(args)...); case JS::TraceKind::Symbol: return f(static_cast<JS::Symbol*>(thing), mozilla::Forward<Args>(args)...); case JS::TraceKind::RegExpShared: return f(static_cast<js::RegExpShared*>(thing), mozilla::Forward<Args>(args)...);;       default:           do { MOZ_ReportCrash("" "Invalid trace kind in DispatchTraceKindTyped.", "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/TraceKind.h", 212); do { } while (0); do { *((volatile int*) __null) = 212; ::abort(); } while (0); } while (0);     } } }
# 24 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/jspubtd.h" 2
namespace JS { class AutoIdVector; class CallArgs; template <typename T> class Rooted; class CompileOptions; class ReadOnlyCompileOptions; class OwningCompileOptions; class TransitiveCompileOptions; class CompartmentOptions; class Value; struct Zone; }
 enum JSVersion {     JSVERSION_ECMA_3 = 148,     JSVERSION_1_6 = 160,     JSVERSION_1_7 = 170,     JSVERSION_1_8 = 180,     JSVERSION_ECMA_5 = 185,     JSVERSION_DEFAULT = 0,     JSVERSION_UNKNOWN = -1,     JSVERSION_LATEST = JSVERSION_ECMA_5 };
 enum JSType {     JSTYPE_UNDEFINED,     JSTYPE_OBJECT,     JSTYPE_FUNCTION,     JSTYPE_STRING,     JSTYPE_NUMBER,     JSTYPE_BOOLEAN,     JSTYPE_NULL,     JSTYPE_SYMBOL,     JSTYPE_LIMIT };
 enum JSProtoKey {     JSProto_Null = 0, JSProto_Object = 1, JSProto_Function = 2, JSProto_Array = 3, JSProto_Boolean = 4, JSProto_JSON = 5, JSProto_Date = 6, JSProto_Math = 7, JSProto_Number = 8, JSProto_String = 9, JSProto_RegExp = 10, JSProto_Error = 11, JSProto_InternalError = 12, JSProto_EvalError = 13, JSProto_RangeError = 14, JSProto_ReferenceError = 15, JSProto_SyntaxError = 16, JSProto_TypeError = 17, JSProto_URIError = 18, JSProto_DebuggeeWouldRun = 19, JSProto_CompileError = 20, JSProto_LinkError = 21, JSProto_RuntimeError = 22, JSProto_Iterator = 23, JSProto_StopIteration = 24, JSProto_ArrayBuffer = 25, JSProto_Int8Array = 26, JSProto_Uint8Array = 27, JSProto_Int16Array = 28, JSProto_Uint16Array = 29, JSProto_Int32Array = 30, JSProto_Uint32Array = 31, JSProto_Float32Array = 32, JSProto_Float64Array = 33, JSProto_Uint8ClampedArray = 34, JSProto_Proxy = 35, JSProto_WeakMap = 36, JSProto_Map = 37, JSProto_Set = 38, JSProto_DataView = 39, JSProto_Symbol = 40, JSProto_SharedArrayBuffer = 41, JSProto_Intl = 42, JSProto_TypedObject = 43, JSProto_Reflect = 44, JSProto_SIMD = 45, JSProto_WeakSet = 46, JSProto_TypedArray = 47, JSProto_Atomics = 48, JSProto_SavedFrame = 49, JSProto_WebAssembly = 50, JSProto_WasmModule = 51, JSProto_WasmInstance = 52, JSProto_WasmMemory = 53, JSProto_WasmTable = 54, JSProto_Promise = 55,     JSProto_LIMIT };
 struct JSClass;
 struct JSCompartment;
 struct JSCrossCompartmentCall;
 struct JSPropertyName;
 struct JSPropertySpec;
 struct JSRuntime;
 struct JSSecurityCallbacks;
 struct JSStructuredCloneCallbacks;
 struct JSStructuredCloneReader;
 struct JSStructuredCloneWriter;
 class JSTracer;
 class JSFlatString;
 typedef bool (*JSInitCallback)(void);
 template<typename T> struct JSConstScalarSpec;
 typedef JSConstScalarSpec<double> JSConstDoubleSpec;
 typedef JSConstScalarSpec<int32_t> JSConstIntegerSpec;
 typedef void (* JSTraceDataOp)(JSTracer* trc, void* data);
 namespace js { namespace gc { class AutoTraceSession; class StoreBuffer; } class CooperatingContext;   ;  bool CurrentThreadCanAccessRuntime(const JSRuntime* rt);   }
 namespace JS { class AutoEnterCycleCollection; class AutoAssertOnBarrier; struct PropertyDescriptor; typedef void (*OffThreadCompileCallback)(void* token, void* callbackData); enum class HeapState {     Idle,     Tracing,     MajorCollecting,     MinorCollecting,     CycleCollecting };       static bool CurrentThreadIsHeapCollecting() ;  class AutoEnterCycleCollection {   public:           }; class RootingContext; class AutoGCRooter {   public:                                 protected:     AutoGCRooter * const down; 
# 242 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/jspubtd.h"
    ptrdiff_t tag_;     enum {         VALARRAY = -2,         PARSER = -3,         VALVECTOR = -10,         IDVECTOR = -11,         OBJVECTOR = -14,         IONMASM = -19,         WRAPVECTOR = -20,         WRAPPER = -21,         CUSTOM = -26     };                  private:     AutoGCRooter ** const stackTop;           }; template <> struct MapTypeToRootKind<void*> {     static const RootKind kind = RootKind::Traceable; }; using RootedListHeads = mozilla::EnumeratedArray<RootKind, RootKind::Limit,                                                  Rooted<void*>*>; enum StackKind {     StackForSystemCode,     StackForTrustedScript,     StackForUntrustedScript,     StackKindCount }; class RootingContext {     RootedListHeads stackRoots_;     template <typename T> friend class JS::Rooted;     JS::AutoGCRooter* autoGCRooters_;     friend class JS::AutoGCRooter;   public:                  protected:     JSCompartment* compartment_;     JS::Zone* zone_;   public:     uintptr_t nativeStackLimit[StackKindCount];                    ; }; }
# 70 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/utility" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_pair.h" 1 3
# 65 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_pair.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) { 
# 76 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_pair.h" 3
  struct piecewise_construct_t {  };   constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();   template<typename...>     class tuple;   template<std::size_t...>     struct _Index_tuple;   template <bool, typename _T1, typename _T2>     struct _PCC     {       template <typename _U1, typename _U2>       static constexpr bool _ConstructiblePair()       {  return __and_<is_constructible<_T1, const _U1&>,         is_constructible<_T2, const _U2&>>::value;       }       template <typename _U1, typename _U2>       static constexpr bool _ImplicitlyConvertiblePair()       {  return __and_<is_convertible<const _U1&, _T1>,         is_convertible<const _U2&, _T2>>::value;       }       template <typename _U1, typename _U2>       static constexpr bool _MoveConstructiblePair()       {  return __and_<is_constructible<_T1, _U1&&>,         is_constructible<_T2, _U2&&>>::value;       }       template <typename _U1, typename _U2>       static constexpr bool _ImplicitlyMoveConvertiblePair()       {  return __and_<is_convertible<_U1&&, _T1>,         is_convertible<_U2&&, _T2>>::value;       }       template <bool __implicit, typename _U1, typename _U2>       static constexpr bool _CopyMovePair()       {  using __do_converts = __and_<is_convertible<const _U1&, _T1>,       is_convertible<_U2&&, _T2>>;  using __converts = typename conditional<__implicit,            __do_converts,            __not_<__do_converts>>::type;  return __and_<is_constructible<_T1, const _U1&>,         is_constructible<_T2, _U2&&>,         __converts         >::value;       }       template <bool __implicit, typename _U1, typename _U2>       static constexpr bool _MoveCopyPair()       {  using __do_converts = __and_<is_convertible<_U1&&, _T1>,       is_convertible<const _U2&, _T2>>;  using __converts = typename conditional<__implicit,            __do_converts,            __not_<__do_converts>>::type;  return __and_<is_constructible<_T1, _U1&&>,         is_constructible<_T2, const _U2&&>,         __converts         >::value;       }   };   template <typename _T1, typename _T2>     struct _PCC<false, _T1, _T2>     {       template <typename _U1, typename _U2>       static constexpr bool _ConstructiblePair()       {  return false;       }       template <typename _U1, typename _U2>       static constexpr bool _ImplicitlyConvertiblePair()       {  return false;       }       template <typename _U1, typename _U2>       static constexpr bool _MoveConstructiblePair()       {  return false;       }       template <typename _U1, typename _U2>       static constexpr bool _ImplicitlyMoveConvertiblePair()       {  return false;       }   }; 
# 189 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>     struct pair     {       typedef _T1 first_type;       typedef _T2 second_type;       _T1 first;       _T2 second;       template <typename _U1 = _T1,                 typename _U2 = _T2,                 typename enable_if<__and_<                                      __is_implicitly_default_constructible<_U1>,                                      __is_implicitly_default_constructible<_U2>>                                    ::value, bool>::type = true>       constexpr pair()       : first(), second() { }       template <typename _U1 = _T1,                 typename _U2 = _T2,                 typename enable_if<__and_<                        is_default_constructible<_U1>,                        is_default_constructible<_U2>,                        __not_<                          __and_<__is_implicitly_default_constructible<_U1>,                                 __is_implicitly_default_constructible<_U2>>>>                                    ::value, bool>::type = false>       explicit constexpr pair()       : first(), second() { } 
# 233 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_pair.h" 3
      using _PCCP = _PCC<true, _T1, _T2>;       template<typename _U1 = _T1, typename _U2=_T2, typename         enable_if<_PCCP::template       _ConstructiblePair<_U1, _U2>()                   && _PCCP::template       _ImplicitlyConvertiblePair<_U1, _U2>(),                          bool>::type=true>       constexpr pair(const _T1& __a, const _T2& __b)       : first(__a), second(__b) { }        template<typename _U1 = _T1, typename _U2=_T2, typename   enable_if<_PCCP::template        _ConstructiblePair<_U1, _U2>()                    && !_PCCP::template        _ImplicitlyConvertiblePair<_U1, _U2>(),                          bool>::type=false>       explicit constexpr pair(const _T1& __a, const _T2& __b)       : first(__a), second(__b) { } 
# 261 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_pair.h" 3
      template <typename _U1, typename _U2>         using _PCCFP = _PCC<!is_same<_T1, _U1>::value        || !is_same<_T2, _U2>::value,        _T1, _T2>;       template<typename _U1, typename _U2, typename         enable_if<_PCCFP<_U1, _U2>::template       _ConstructiblePair<_U1, _U2>()                   && _PCCFP<_U1, _U2>::template       _ImplicitlyConvertiblePair<_U1, _U2>(),      bool>::type=true>         constexpr pair(const pair<_U1, _U2>& __p)         : first(__p.first), second(__p.second) { }       template<typename _U1, typename _U2, typename         enable_if<_PCCFP<_U1, _U2>::template       _ConstructiblePair<_U1, _U2>()     && !_PCCFP<_U1, _U2>::template       _ImplicitlyConvertiblePair<_U1, _U2>(),                          bool>::type=false>  explicit constexpr pair(const pair<_U1, _U2>& __p)  : first(__p.first), second(__p.second) { }       constexpr pair(const pair&) = default;       constexpr pair(pair&&) = default;       template<typename _U1, typename         enable_if<_PCCP::template       _MoveCopyPair<true, _U1, _T2>(),                          bool>::type=true>        constexpr pair(_U1&& __x, const _T2& __y)        : first(std::forward<_U1>(__x)), second(__y) { }       template<typename _U1, typename         enable_if<_PCCP::template       _MoveCopyPair<false, _U1, _T2>(),                          bool>::type=false>        explicit constexpr pair(_U1&& __x, const _T2& __y)        : first(std::forward<_U1>(__x)), second(__y) { }       template<typename _U2, typename         enable_if<_PCCP::template       _CopyMovePair<true, _T1, _U2>(),                          bool>::type=true>        constexpr pair(const _T1& __x, _U2&& __y)        : first(__x), second(std::forward<_U2>(__y)) { }              template<typename _U1, typename _U2, typename         enable_if<_PCCP::template       _MoveConstructiblePair<_U1, _U2>()      && _PCCP::template       _ImplicitlyMoveConvertiblePair<_U1, _U2>(),                          bool>::type=true>  constexpr pair(_U1&& __x, _U2&& __y)  : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }       template<typename _U1, typename _U2, typename         enable_if<_PCCP::template       _MoveConstructiblePair<_U1, _U2>()      && !_PCCP::template       _ImplicitlyMoveConvertiblePair<_U1, _U2>(),                          bool>::type=false>  explicit constexpr pair(_U1&& __x, _U2&& __y)  : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }       template<typename _U1, typename _U2, typename         enable_if<_PCCFP<_U1, _U2>::template       _MoveConstructiblePair<_U1, _U2>()      && _PCCFP<_U1, _U2>::template       _ImplicitlyMoveConvertiblePair<_U1, _U2>(),                          bool>::type=true>  constexpr pair(pair<_U1, _U2>&& __p)  : first(std::forward<_U1>(__p.first)),    second(std::forward<_U2>(__p.second)) { }       template<typename _U1, typename _U2, typename         enable_if<_PCCFP<_U1, _U2>::template       _MoveConstructiblePair<_U1, _U2>()      && !_PCCFP<_U1, _U2>::template       _ImplicitlyMoveConvertiblePair<_U1, _U2>(),                          bool>::type=false>  explicit constexpr pair(pair<_U1, _U2>&& __p)  : first(std::forward<_U1>(__p.first)),    second(std::forward<_U2>(__p.second)) { }       ;       pair&       operator=(typename conditional<   __and_<is_copy_assignable<_T1>,          is_copy_assignable<_T2>>::value,   const pair&, const __nonesuch&>::type __p)       {  first = __p.first;  second = __p.second;  return *this;       }       pair&       operator=(typename conditional<   __not_<__and_<is_copy_assignable<_T1>,                 is_copy_assignable<_T2>>>::value,   const pair&, const __nonesuch&>::type __p) = delete;       pair&       operator=(typename conditional<   __and_<is_move_assignable<_T1>,          is_move_assignable<_T2>>::value,   pair&&, __nonesuch&&>::type __p)       noexcept(__and_<is_nothrow_move_assignable<_T1>,                is_nothrow_move_assignable<_T2>>::value)       {  first = std::forward<first_type>(__p.first);  second = std::forward<second_type>(__p.second);  return *this;       }       template<typename _U1, typename _U2>       typename enable_if<__and_<is_assignable<_T1&, const _U1&>,     is_assignable<_T2&, const _U2&>>::value,     pair&>::type  operator=(const pair<_U1, _U2>& __p)  {    first = __p.first;    second = __p.second;    return *this;  }       template<typename _U1, typename _U2>       typename enable_if<__and_<is_assignable<_T1&, _U1&&>,     is_assignable<_T2&, _U2&&>>::value,     pair&>::type  operator=(pair<_U1, _U2>&& __p)  {    first = std::forward<_U1>(__p.first);    second = std::forward<_U2>(__p.second);    return *this;  }       void       swap(pair& __p)       noexcept(__is_nothrow_swappable<_T1>::value                && __is_nothrow_swappable<_T2>::value)       {  using std::swap;  swap(first, __p.first);  swap(second, __p.second);       }     private:       template<typename... _Args1, std::size_t... _Indexes1,                typename... _Args2, std::size_t... _Indexes2>         pair(tuple<_Args1...>&, tuple<_Args2...>&,              _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);     };   template<typename _T1, typename _T2>     inline constexpr bool     operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)     { return __x.first == __y.first && __x.second == __y.second; }   template<typename _T1, typename _T2>     inline constexpr bool     operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)     { return __x.first < __y.first       || (!(__y.first < __x.first) && __x.second < __y.second); }   template<typename _T1, typename _T2>     inline constexpr bool     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)     { return !(__x == __y); }   template<typename _T1, typename _T2>     inline constexpr bool     operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)     { return __y < __x; }   template<typename _T1, typename _T2>     inline constexpr bool     operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)     { return !(__y < __x); }   template<typename _T1, typename _T2>     inline constexpr bool     operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)     { return !(__x < __y); }   template<typename _T1, typename _T2>     inline void     swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)     noexcept(noexcept(__x.swap(__y)))     { __x.swap(__y); } 
# 490 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>     constexpr pair<typename __decay_and_strip<_T1>::__type,                    typename __decay_and_strip<_T2>::__type>     make_pair(_T1&& __x, _T2&& __y)     {       typedef typename __decay_and_strip<_T1>::__type __ds_type1;       typedef typename __decay_and_strip<_T2>::__type __ds_type2;       typedef pair<__ds_type1, __ds_type2> __pair_type;       return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));     } 
# 510 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_pair.h" 3
}
# 71 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/utility" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/initializer_list" 1 3
# 34 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/initializer_list" 3
#pragma GCC visibility push(default)
namespace std {   template<class _E>     class initializer_list     {     public:       typedef _E value_type;       typedef const _E& reference;       typedef const _E& const_reference;       typedef size_t size_type;       typedef const _E* iterator;       typedef const _E* const_iterator;     private:       iterator _M_array;       size_type _M_len;       constexpr initializer_list(const_iterator __a, size_type __l)       : _M_array(__a), _M_len(__l) { }     public:       constexpr initializer_list() noexcept       : _M_array(0), _M_len(0) { }       constexpr size_type       size() const noexcept { return _M_len; }       constexpr const_iterator       begin() const noexcept { return _M_array; }       constexpr const_iterator       end() const noexcept { return begin() + size(); }     };   template<class _Tp>     constexpr const _Tp*     begin(initializer_list<_Tp> __ils) noexcept     { return __ils.begin(); }   template<class _Tp>     constexpr const _Tp*     end(initializer_list<_Tp> __ils) noexcept     { return __ils.end(); } }
#pragma GCC visibility pop
# 77 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/utility" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _Tp>     struct tuple_size;   template<typename _Tp>     struct tuple_size<const _Tp>     : integral_constant<size_t, tuple_size<_Tp>::value> { };   template<typename _Tp>     struct tuple_size<volatile _Tp>     : integral_constant<size_t, tuple_size<_Tp>::value> { };   template<typename _Tp>     struct tuple_size<const volatile _Tp>     : integral_constant<size_t, tuple_size<_Tp>::value> { };   template<std::size_t __i, typename _Tp>     struct tuple_element;   template<std::size_t __i, typename _Tp>     using __tuple_element_t = typename tuple_element<__i, _Tp>::type;   template<std::size_t __i, typename _Tp>     struct tuple_element<__i, const _Tp>     {       typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;     };   template<std::size_t __i, typename _Tp>     struct tuple_element<__i, volatile _Tp>     {       typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;     };   template<std::size_t __i, typename _Tp>     struct tuple_element<__i, const volatile _Tp>     {       typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;     };   template<std::size_t __i, typename _Tp>     using tuple_element_t = typename tuple_element<__i, _Tp>::type;   template<typename>     struct __is_tuple_like_impl : false_type     { };   template<typename _T1, typename _T2>     struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type     { };   template<class _Tp1, class _Tp2>     struct tuple_size<std::pair<_Tp1, _Tp2>>     : public integral_constant<std::size_t, 2> { };   template<class _Tp1, class _Tp2>     struct tuple_element<0, std::pair<_Tp1, _Tp2>>     { typedef _Tp1 type; };   template<class _Tp1, class _Tp2>     struct tuple_element<1, std::pair<_Tp1, _Tp2>>     { typedef _Tp2 type; };   template<std::size_t _Int>     struct __pair_get;   template<>     struct __pair_get<0>     {       template<typename _Tp1, typename _Tp2>         static constexpr _Tp1&         __get(std::pair<_Tp1, _Tp2>& __pair) noexcept         { return __pair.first; }       template<typename _Tp1, typename _Tp2>         static constexpr _Tp1&&         __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept         { return std::forward<_Tp1>(__pair.first); }       template<typename _Tp1, typename _Tp2>         static constexpr const _Tp1&         __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept         { return __pair.first; }     };   template<>     struct __pair_get<1>     {       template<typename _Tp1, typename _Tp2>         static constexpr _Tp2&         __get(std::pair<_Tp1, _Tp2>& __pair) noexcept         { return __pair.second; }       template<typename _Tp1, typename _Tp2>         static constexpr _Tp2&&         __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept         { return std::forward<_Tp2>(__pair.second); }       template<typename _Tp1, typename _Tp2>         static constexpr const _Tp2&         __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept         { return __pair.second; }     };   template<std::size_t _Int, class _Tp1, class _Tp2>     constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&     get(std::pair<_Tp1, _Tp2>& __in) noexcept     { return __pair_get<_Int>::__get(__in); }   template<std::size_t _Int, class _Tp1, class _Tp2>     constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&     get(std::pair<_Tp1, _Tp2>&& __in) noexcept     { return __pair_get<_Int>::__move_get(std::move(__in)); }   template<std::size_t _Int, class _Tp1, class _Tp2>     constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&     get(const std::pair<_Tp1, _Tp2>& __in) noexcept     { return __pair_get<_Int>::__const_get(__in); }   template <typename _Tp, typename _Up>     constexpr _Tp&     get(pair<_Tp, _Up>& __p) noexcept     { return __p.first; }   template <typename _Tp, typename _Up>     constexpr const _Tp&     get(const pair<_Tp, _Up>& __p) noexcept     { return __p.first; }   template <typename _Tp, typename _Up>     constexpr _Tp&&     get(pair<_Tp, _Up>&& __p) noexcept     { return std::move(__p.first); }   template <typename _Tp, typename _Up>     constexpr _Tp&     get(pair<_Up, _Tp>& __p) noexcept     { return __p.second; }   template <typename _Tp, typename _Up>     constexpr const _Tp&     get(const pair<_Up, _Tp>& __p) noexcept     { return __p.second; }   template <typename _Tp, typename _Up>     constexpr _Tp&&     get(pair<_Up, _Tp>&& __p) noexcept     { return std::move(__p.second); }   template <typename _Tp, typename _Up = _Tp>     inline _Tp     exchange(_Tp& __obj, _Up&& __new_val)     { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }   template<size_t... _Indexes> struct _Index_tuple { };   template<typename _Itup1, typename _Itup2> struct _Itup_cat;   template<size_t... _Ind1, size_t... _Ind2>     struct _Itup_cat<_Index_tuple<_Ind1...>, _Index_tuple<_Ind2...>>     {       using __type = _Index_tuple<_Ind1..., (_Ind2 + sizeof...(_Ind1))...>;     };   template<size_t _Num>     struct _Build_index_tuple     : _Itup_cat<typename _Build_index_tuple<_Num / 2>::__type,   typename _Build_index_tuple<_Num - _Num / 2>::__type>     { };   template<>     struct _Build_index_tuple<1>     {       typedef _Index_tuple<0> __type;     };   template<>     struct _Build_index_tuple<0>     {       typedef _Index_tuple<> __type;     };   template<typename _Tp, _Tp... _Idx>     struct integer_sequence     {       typedef _Tp value_type;       static constexpr size_t size() { return sizeof...(_Idx); }     };   template<typename _Tp, _Tp _Num,     typename _ISeq = typename _Build_index_tuple<_Num>::__type>     struct _Make_integer_sequence;   template<typename _Tp, _Tp _Num, size_t... _Idx>     struct _Make_integer_sequence<_Tp, _Num, _Index_tuple<_Idx...>>     {       static_assert( _Num >= 0,        "Cannot make integer sequence of negative length" );       typedef integer_sequence<_Tp, static_cast<_Tp>(_Idx)...> __type;     };   template<typename _Tp, _Tp _Num>     using make_integer_sequence       = typename _Make_integer_sequence<_Tp, _Num>::__type;   template<size_t... _Idx>     using index_sequence = integer_sequence<size_t, _Idx...>;   template<size_t _Num>     using make_index_sequence = make_integer_sequence<size_t, _Num>;   template<typename... _Types>     using index_sequence_for = make_index_sequence<sizeof...(_Types)>; }
# 61 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/algorithm" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algobase.h" 1 3
# 60 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algobase.h" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/functexcept.h" 1 3
# 42 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/functexcept.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {   void   __throw_bad_exception(void) __attribute__((__noreturn__));   void   __throw_bad_alloc(void) __attribute__((__noreturn__));   void   __throw_bad_cast(void) __attribute__((__noreturn__));   void   __throw_bad_typeid(void) __attribute__((__noreturn__));   void   __throw_logic_error(const char*) __attribute__((__noreturn__));   void   __throw_domain_error(const char*) __attribute__((__noreturn__));   void   __throw_invalid_argument(const char*) __attribute__((__noreturn__));   void   __throw_length_error(const char*) __attribute__((__noreturn__));   void   __throw_out_of_range(const char*) __attribute__((__noreturn__));   void   __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))     __attribute__((__format__(__gnu_printf__, 1, 2)));                         }
# 61 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algobase.h" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/cpp_type_traits.h" 1 3
# 36 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/cpp_type_traits.h" 3
# 67 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/cpp_type_traits.h" 3
extern "C++" { namespace std __attribute__ ((__visibility__ ("default"))) {   struct __true_type { };   struct __false_type { };   template<bool>     struct __truth_type     { typedef __false_type __type; };   template<>     struct __truth_type<true>     { typedef __true_type __type; };   template<class _Sp, class _Tp>     struct __traitor     {       enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };       typedef typename __truth_type<__value>::__type __type;     };   template<typename, typename>     struct __are_same     {       enum { __value = 0 };       typedef __false_type __type;     };   template<typename _Tp>     struct __are_same<_Tp, _Tp>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<typename _Tp>     struct __is_void     {       enum { __value = 0 };       typedef __false_type __type;     };   template<>     struct __is_void<void>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<typename _Tp>     struct __is_integer     {       enum { __value = 0 };       typedef __false_type __type;     };   template<>     struct __is_integer<bool>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<char>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<signed char>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<unsigned char>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<wchar_t>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<char16_t>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<char32_t>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<short>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<unsigned short>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<int>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<unsigned int>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<long>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<unsigned long>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<long long>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_integer<unsigned long long>     {       enum { __value = 1 };       typedef __true_type __type;     }; 
# 278 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/cpp_type_traits.h" 3
  template<typename _Tp>     struct __is_floating     {       enum { __value = 0 };       typedef __false_type __type;     };   template<>     struct __is_floating<float>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_floating<double>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_floating<long double>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<typename _Tp>     struct __is_pointer     {       enum { __value = 0 };       typedef __false_type __type;     };   template<typename _Tp>     struct __is_pointer<_Tp*>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<typename _Tp>     struct __is_arithmetic     : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >     { };   template<typename _Tp>     struct __is_scalar     : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >     { };   template<typename _Tp>     struct __is_char     {       enum { __value = 0 };       typedef __false_type __type;     };   template<>     struct __is_char<char>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_char<wchar_t>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<typename _Tp>     struct __is_byte     {       enum { __value = 0 };       typedef __false_type __type;     };   template<>     struct __is_byte<char>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_byte<signed char>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<>     struct __is_byte<unsigned char>     {       enum { __value = 1 };       typedef __true_type __type;     };   template<typename _Tp>     struct __is_move_iterator     {       enum { __value = 0 };       typedef __false_type __type;     };    } }
# 62 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algobase.h" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ext/type_traits.h" 1 3
# 33 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ext/type_traits.h" 3
extern "C++" { namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {   template<bool, typename>     struct __enable_if     { };   template<typename _Tp>     struct __enable_if<true, _Tp>     { typedef _Tp __type; };   template<bool _Cond, typename _Iftrue, typename _Iffalse>     struct __conditional_type     { typedef _Iftrue __type; };   template<typename _Iftrue, typename _Iffalse>     struct __conditional_type<false, _Iftrue, _Iffalse>     { typedef _Iffalse __type; };   template<typename _Tp>     struct __add_unsigned     {     private:       typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;     public:       typedef typename __if_type::__type __type;     };   template<>     struct __add_unsigned<char>     { typedef unsigned char __type; };   template<>     struct __add_unsigned<signed char>     { typedef unsigned char __type; };   template<>     struct __add_unsigned<short>     { typedef unsigned short __type; };   template<>     struct __add_unsigned<int>     { typedef unsigned int __type; };   template<>     struct __add_unsigned<long>     { typedef unsigned long __type; };   template<>     struct __add_unsigned<long long>     { typedef unsigned long long __type; };   template<>     struct __add_unsigned<bool>;   template<>     struct __add_unsigned<wchar_t>;   template<typename _Tp>     struct __remove_unsigned     {     private:       typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;     public:       typedef typename __if_type::__type __type;     };   template<>     struct __remove_unsigned<char>     { typedef signed char __type; };   template<>     struct __remove_unsigned<unsigned char>     { typedef signed char __type; };   template<>     struct __remove_unsigned<unsigned short>     { typedef short __type; };   template<>     struct __remove_unsigned<unsigned int>     { typedef int __type; };   template<>     struct __remove_unsigned<unsigned long>     { typedef long __type; };   template<>     struct __remove_unsigned<unsigned long long>     { typedef long long __type; };   template<>     struct __remove_unsigned<bool>;   template<>     struct __remove_unsigned<wchar_t>;   template<typename _Type>      bool     __is_null_pointer(_Type* __ptr)     ;   template<typename _Type>      bool     __is_null_pointer(_Type)     ;    bool   __is_null_pointer(std::nullptr_t)   ;   template<typename _Tp, bool = std::__is_integer<_Tp>::__value>     struct __promote     { typedef double __type; };   template<typename _Tp>     struct __promote<_Tp, false>     { };   template<>     struct __promote<long double>     { typedef long double __type; };   template<>     struct __promote<double>     { typedef double __type; };   template<>     struct __promote<float>     { typedef float __type; };   template<typename _Tp, typename _Up,            typename _Tp2 = typename __promote<_Tp>::__type,            typename _Up2 = typename __promote<_Up>::__type>     struct __promote_2     {       typedef __typeof__(_Tp2() + _Up2()) __type;     };   template<typename _Tp, typename _Up, typename _Vp,            typename _Tp2 = typename __promote<_Tp>::__type,            typename _Up2 = typename __promote<_Up>::__type,            typename _Vp2 = typename __promote<_Vp>::__type>     struct __promote_3     {       typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;     };   template<typename _Tp, typename _Up, typename _Vp, typename _Wp,            typename _Tp2 = typename __promote<_Tp>::__type,            typename _Up2 = typename __promote<_Up>::__type,            typename _Vp2 = typename __promote<_Vp>::__type,            typename _Wp2 = typename __promote<_Wp>::__type>     struct __promote_4     {       typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;     }; } }
# 63 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algobase.h" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ext/numeric_traits.h" 1 3
# 33 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ext/numeric_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) { 
# 54 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ext/numeric_traits.h" 3
  template<typename _Value>     struct __numeric_traits_integer     {       static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);       static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);       static const bool __is_signed = ((_Value)(-1) < 0);       static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));     };   template<typename _Value>     const _Value __numeric_traits_integer<_Value>::__min;   template<typename _Value>     const _Value __numeric_traits_integer<_Value>::__max;   template<typename _Value>     const bool __numeric_traits_integer<_Value>::__is_signed;   template<typename _Value>     const int __numeric_traits_integer<_Value>::__digits; 
# 99 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ext/numeric_traits.h" 3
  template<typename _Value>     struct __numeric_traits_floating     {       static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);       static const bool __is_signed = true;       static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);       static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);     };   template<typename _Value>     const int __numeric_traits_floating<_Value>::__max_digits10;   template<typename _Value>     const bool __numeric_traits_floating<_Value>::__is_signed;   template<typename _Value>     const int __numeric_traits_floating<_Value>::__digits10;   template<typename _Value>     const int __numeric_traits_floating<_Value>::__max_exponent10;   template<typename _Value>     struct __numeric_traits     : public __conditional_type<std::__is_integer<_Value>::__value,     __numeric_traits_integer<_Value>,     __numeric_traits_floating<_Value> >::__type     { }; }
# 64 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algobase.h" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator_base_types.h" 1 3
# 63 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator_base_types.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) { 
# 89 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };   struct output_iterator_tag { };   struct forward_iterator_tag : public input_iterator_tag { };   struct bidirectional_iterator_tag : public forward_iterator_tag { };   struct random_access_iterator_tag : public bidirectional_iterator_tag { }; 
# 116 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,            typename _Pointer = _Tp*, typename _Reference = _Tp&>     struct iterator     {       typedef _Category iterator_category;       typedef _Tp value_type;       typedef _Distance difference_type;       typedef _Pointer pointer;       typedef _Reference reference;     }; 
# 143 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator, typename = __void_t<>>     struct __iterator_traits { };   template<typename _Iterator>     struct __iterator_traits<_Iterator,         __void_t<typename _Iterator::iterator_category,           typename _Iterator::value_type,           typename _Iterator::difference_type,           typename _Iterator::pointer,           typename _Iterator::reference>>     {       typedef typename _Iterator::iterator_category iterator_category;       typedef typename _Iterator::value_type value_type;       typedef typename _Iterator::difference_type difference_type;       typedef typename _Iterator::pointer pointer;       typedef typename _Iterator::reference reference;     };   template<typename _Iterator>     struct iterator_traits     : public __iterator_traits<_Iterator> { }; 
# 177 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>     struct iterator_traits<_Tp*>     {       typedef random_access_iterator_tag iterator_category;       typedef _Tp value_type;       typedef ptrdiff_t difference_type;       typedef _Tp* pointer;       typedef _Tp& reference;     };   template<typename _Tp>     struct iterator_traits<const _Tp*>     {       typedef random_access_iterator_tag iterator_category;       typedef _Tp value_type;       typedef ptrdiff_t difference_type;       typedef const _Tp* pointer;       typedef const _Tp& reference;     };   template<typename _Iter>      typename iterator_traits<_Iter>::iterator_category     __iterator_category(const _Iter&)     ; 
# 230 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator_base_types.h" 3
  template<typename _InIter>     using _RequireInputIter = typename       enable_if<is_convertible<typename   iterator_traits<_InIter>::iterator_category,           input_iterator_tag>::value>::type; }
# 66 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algobase.h" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator_base_funcs.h" 1 3
# 63 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator_base_funcs.h" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/debug/assertions.h" 1 3
# 66 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator_base_funcs.h" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) {   template <typename> struct _List_iterator;   template <typename> struct _List_const_iterator;   template<typename _InputIterator>      typename iterator_traits<_InputIterator>::difference_type     __distance(_InputIterator __first, _InputIterator __last,                input_iterator_tag)     ;   template<typename _RandomAccessIterator>      typename iterator_traits<_RandomAccessIterator>::difference_type     __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,                random_access_iterator_tag)     ;   template<typename _Tp>     ptrdiff_t     __distance(std::_List_iterator<_Tp>,         std::_List_iterator<_Tp>,         input_iterator_tag);   template<typename _Tp>     ptrdiff_t     __distance(std::_List_const_iterator<_Tp>,         std::_List_const_iterator<_Tp>,         input_iterator_tag); 
# 133 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>      typename iterator_traits<_InputIterator>::difference_type     distance(_InputIterator __first, _InputIterator __last)     ;   template<typename _InputIterator, typename _Distance>      void     __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)     ;   template<typename _BidirectionalIterator, typename _Distance>      void     __advance(_BidirectionalIterator& __i, _Distance __n,        bidirectional_iterator_tag)     ;   template<typename _RandomAccessIterator, typename _Distance>      void     __advance(_RandomAccessIterator& __i, _Distance __n,               random_access_iterator_tag)     ; 
# 192 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>      void     advance(_InputIterator& __i, _Distance __n)     ;   template<typename _ForwardIterator>      _ForwardIterator     next(_ForwardIterator __x, typename   iterator_traits<_ForwardIterator>::difference_type __n = 1)     ;   template<typename _BidirectionalIterator>      _BidirectionalIterator     prev(_BidirectionalIterator __x, typename   iterator_traits<_BidirectionalIterator>::difference_type __n = 1)     ; }
# 67 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algobase.h" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator.h" 1 3
# 66 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator.h" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ptr_traits.h" 1 3
# 37 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ptr_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {   class __undefined;   template<typename _Tp>     struct __get_first_arg     { using type = __undefined; };   template<template<typename, typename...> class _Template, typename _Tp,            typename... _Types>     struct __get_first_arg<_Template<_Tp, _Types...>>     { using type = _Tp; };   template<typename _Tp>     using __get_first_arg_t = typename __get_first_arg<_Tp>::type;   template<typename _Tp, typename _Up>     struct __replace_first_arg     { using type = __undefined; };   template<template<typename, typename...> class _Template, typename _Up,            typename _Tp, typename... _Types>     struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>     { using type = _Template<_Up, _Types...>; };   template<typename _Tp, typename _Up>     using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;   template<typename _Tp>     using __make_not_void       = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;   template<typename _Ptr>     struct pointer_traits     {     private:       template<typename _Tp>  using __element_type = typename _Tp::element_type;       template<typename _Tp>  using __difference_type = typename _Tp::difference_type;       template<typename _Tp, typename _Up>  using __rebind = typename _Tp::template rebind<_Up>;     public:       using pointer = _Ptr;       using element_type  = __detected_or_t_<__get_first_arg_t, __element_type, _Ptr>;       using difference_type  = __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;       template<typename _Up>         using rebind    = __detected_or_t_<__replace_first_arg_t, __rebind, _Ptr, _Up>;       static _Ptr       pointer_to(__make_not_void<element_type>& __e)       ;       static_assert(!is_same<element_type, __undefined>::value,    "pointer type defines element_type or is like SomePointer<T, Args>");       static_assert(!is_same<rebind<element_type>, __undefined>::value,    "pointer type defines rebind<U> or is like SomePointer<T, Args>");     };   template<typename _Tp>     struct pointer_traits<_Tp*>     {       typedef _Tp* pointer;       typedef _Tp element_type;       typedef ptrdiff_t difference_type;       template<typename _Up>         using rebind = _Up*;       static pointer       pointer_to(__make_not_void<element_type>& __r) noexcept       { return std::addressof(__r); }     };   template<typename _Ptr, typename _Tp>     using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>; }
# 67 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator.h" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) { 
# 96 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator.h" 3
  template<typename _Iterator>     class reverse_iterator     : public iterator<typename iterator_traits<_Iterator>::iterator_category,         typename iterator_traits<_Iterator>::value_type,         typename iterator_traits<_Iterator>::difference_type,         typename iterator_traits<_Iterator>::pointer,                       typename iterator_traits<_Iterator>::reference>     {     protected:       _Iterator current;       typedef iterator_traits<_Iterator> __traits_type;     public:       typedef _Iterator iterator_type;       typedef typename __traits_type::difference_type difference_type;       typedef typename __traits_type::pointer pointer;       typedef typename __traits_type::reference reference;       reverse_iterator()  ;       explicit       reverse_iterator(iterator_type __x)  ;       reverse_iterator(const reverse_iterator& __x)  ;       template<typename _Iter>         reverse_iterator(const reverse_iterator<_Iter>& __x)  ;       iterator_type       base() const       ; 
# 160 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator.h" 3
                                       }; 
# 616 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator.h" 3
       ; 
# 635 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator.h" 3
  template<typename _Container>     class insert_iterator     : public iterator<output_iterator_tag, void, void, void, void>     {     protected:       _Container* container;       typename _Container::iterator iter;     public:       typedef _Container container_type;        
# 686 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator.h" 3
                                       }; 
# 730 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>      insert_iterator<_Container>     inserter(_Container& __x, _Iterator __i)     ; }
 namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) { 
# 754 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator.h" 3
  using std::iterator_traits;   using std::iterator;   template<typename _Iterator, typename _Container>     class __normal_iterator     {     protected:       _Iterator _M_current;       typedef iterator_traits<_Iterator> __traits_type;     public:       typedef _Iterator iterator_type;       typedef typename __traits_type::iterator_category iterator_category;       typedef typename __traits_type::value_type value_type;       typedef typename __traits_type::difference_type difference_type;       typedef typename __traits_type::reference reference;       typedef typename __traits_type::pointer pointer;       constexpr __normal_iterator() noexcept       : _M_current(_Iterator()) { }       explicit       __normal_iterator(const _Iterator& __i) noexcept       : _M_current(__i) { }       template<typename _Iter>         __normal_iterator(const __normal_iterator<_Iter,      typename __enable_if<               (std::__are_same<_Iter, typename _Container::pointer>::__value),         _Container>::__type>& __i) noexcept         : _M_current(__i.base()) { }       reference       operator*() const noexcept       { return *_M_current; }       pointer       operator->() const noexcept       { return _M_current; }       __normal_iterator&       operator++() noexcept       {  ++_M_current;  return *this;       }       __normal_iterator       operator++(int) noexcept       { return __normal_iterator(_M_current++); }       __normal_iterator&       operator--() noexcept       {  --_M_current;  return *this;       }       __normal_iterator       operator--(int) noexcept       { return __normal_iterator(_M_current--); }       reference       operator[](difference_type __n) const noexcept       { return _M_current[__n]; }       __normal_iterator&       operator+=(difference_type __n) noexcept       { _M_current += __n; return *this; }       __normal_iterator       operator+(difference_type __n) const noexcept       { return __normal_iterator(_M_current + __n); }       __normal_iterator&       operator-=(difference_type __n) noexcept       { _M_current -= __n; return *this; }       __normal_iterator       operator-(difference_type __n) const noexcept       { return __normal_iterator(_M_current - __n); }       const _Iterator&       base() const noexcept       { return _M_current; }     }; 
# 854 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>     inline bool     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,         const __normal_iterator<_IteratorR, _Container>& __rhs)     noexcept     { return __lhs.base() == __rhs.base(); }   template<typename _Iterator, typename _Container>     inline bool     operator==(const __normal_iterator<_Iterator, _Container>& __lhs,         const __normal_iterator<_Iterator, _Container>& __rhs)     noexcept     { return __lhs.base() == __rhs.base(); }   template<typename _IteratorL, typename _IteratorR, typename _Container>     inline bool     operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,         const __normal_iterator<_IteratorR, _Container>& __rhs)     noexcept     { return __lhs.base() != __rhs.base(); }   template<typename _Iterator, typename _Container>     inline bool     operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,         const __normal_iterator<_Iterator, _Container>& __rhs)     noexcept     { return __lhs.base() != __rhs.base(); }   template<typename _IteratorL, typename _IteratorR, typename _Container>     inline bool     operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,        const __normal_iterator<_IteratorR, _Container>& __rhs)     noexcept     { return __lhs.base() < __rhs.base(); }   template<typename _Iterator, typename _Container>     inline bool     operator<(const __normal_iterator<_Iterator, _Container>& __lhs,        const __normal_iterator<_Iterator, _Container>& __rhs)     noexcept     { return __lhs.base() < __rhs.base(); }   template<typename _IteratorL, typename _IteratorR, typename _Container>     inline bool     operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,        const __normal_iterator<_IteratorR, _Container>& __rhs)     noexcept     { return __lhs.base() > __rhs.base(); }   template<typename _Iterator, typename _Container>     inline bool     operator>(const __normal_iterator<_Iterator, _Container>& __lhs,        const __normal_iterator<_Iterator, _Container>& __rhs)     noexcept     { return __lhs.base() > __rhs.base(); }   template<typename _IteratorL, typename _IteratorR, typename _Container>     inline bool     operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,         const __normal_iterator<_IteratorR, _Container>& __rhs)     noexcept     { return __lhs.base() <= __rhs.base(); }   template<typename _Iterator, typename _Container>     inline bool     operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,         const __normal_iterator<_Iterator, _Container>& __rhs)     noexcept     { return __lhs.base() <= __rhs.base(); }   template<typename _IteratorL, typename _IteratorR, typename _Container>     inline bool     operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,         const __normal_iterator<_IteratorR, _Container>& __rhs)     noexcept     { return __lhs.base() >= __rhs.base(); }   template<typename _Iterator, typename _Container>     inline bool     operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,         const __normal_iterator<_Iterator, _Container>& __rhs)     noexcept     { return __lhs.base() >= __rhs.base(); }   template<typename _IteratorL, typename _IteratorR, typename _Container>     inline auto     operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,        const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept     -> decltype(__lhs.base() - __rhs.base())     { return __lhs.base() - __rhs.base(); }   template<typename _Iterator, typename _Container>     inline typename __normal_iterator<_Iterator, _Container>::difference_type     operator-(const __normal_iterator<_Iterator, _Container>& __lhs,        const __normal_iterator<_Iterator, _Container>& __rhs)     noexcept     { return __lhs.base() - __rhs.base(); }   template<typename _Iterator, typename _Container>     inline __normal_iterator<_Iterator, _Container>     operator+(typename __normal_iterator<_Iterator, _Container>::difference_type        __n, const __normal_iterator<_Iterator, _Container>& __i)     noexcept     { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); } }
 namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _Iterator, typename _Container>     _Iterator     __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)     ; }
 namespace std __attribute__ ((__visibility__ ("default"))) { 
# 1006 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_iterator.h" 3
  template<typename _Iterator>     class move_iterator     {     protected:       _Iterator _M_current;       typedef iterator_traits<_Iterator> __traits_type;       typedef typename __traits_type::reference __base_ref;     public:       typedef _Iterator iterator_type;       typedef typename __traits_type::iterator_category iterator_category;       typedef typename __traits_type::value_type value_type;       typedef typename __traits_type::difference_type difference_type;       typedef _Iterator pointer;       typedef typename conditional<is_reference<__base_ref>::value,     typename remove_reference<__base_ref>::type&&,     __base_ref>::type reference;       move_iterator()  ;       explicit       move_iterator(iterator_type __i)  ;       template<typename _Iter>  move_iterator(const move_iterator<_Iter>& __i)  ;       iterator_type       base() const       ;       reference       operator*() const       ;                                                                           };        ;        ;        ;        ;        ;        ;        ;        ;   template<typename _IteratorL, typename _IteratorR>      bool     operator>(const move_iterator<_IteratorL>& __x,        const move_iterator<_IteratorR>& __y)     ;   template<typename _Iterator>      bool     operator>(const move_iterator<_Iterator>& __x,        const move_iterator<_Iterator>& __y)     ;   template<typename _IteratorL, typename _IteratorR>      bool     operator>=(const move_iterator<_IteratorL>& __x,         const move_iterator<_IteratorR>& __y)     ;   template<typename _Iterator>      bool     operator>=(const move_iterator<_Iterator>& __x,         const move_iterator<_Iterator>& __y)     ;   template<typename _IteratorL, typename _IteratorR>     inline auto     operator-(const move_iterator<_IteratorL>& __x,        const move_iterator<_IteratorR>& __y)     -> decltype(__x.base() - __y.base())     { return __x.base() - __y.base(); }   template<typename _Iterator>     inline auto     operator-(const move_iterator<_Iterator>& __x,        const move_iterator<_Iterator>& __y)     -> decltype(__x.base() - __y.base())     { return __x.base() - __y.base(); }   template<typename _Iterator>      move_iterator<_Iterator>     operator+(typename move_iterator<_Iterator>::difference_type __n,        const move_iterator<_Iterator>& __x)     ;   template<typename _Iterator>      move_iterator<_Iterator>     make_move_iterator(_Iterator __i)     ;   template<typename _Iterator, typename _ReturnType     = typename conditional<__move_if_noexcept_cond       <typename iterator_traits<_Iterator>::value_type>::value,                 _Iterator, move_iterator<_Iterator>>::type>     inline _ReturnType     __make_move_if_noexcept_iterator(_Iterator __i)     { return _ReturnType(__i); }   template<typename _Tp, typename _ReturnType     = typename conditional<__move_if_noexcept_cond<_Tp>::value,       const _Tp*, move_iterator<_Tp*>>::type>     inline _ReturnType     __make_move_if_noexcept_iterator(_Tp* __i)     { return _ReturnType(__i); }   template<typename _Iterator>     auto     __niter_base(move_iterator<_Iterator> __it)     -> decltype(make_move_iterator(__niter_base(__it.base())))     { return make_move_iterator(__niter_base(__it.base())); }   template<typename _Iterator>     struct __is_move_iterator<move_iterator<_Iterator> >     {       enum { __value = 1 };       typedef __true_type __type;     };   template<typename _Iterator>     auto     __miter_base(move_iterator<_Iterator> __it)     -> decltype(__miter_base(__it.base()))     { return __miter_base(__it.base()); } }
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/predefined_ops.h" 1 3
# 33 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/predefined_ops.h" 3
namespace __gnu_cxx { namespace __ops {   struct _Iter_less_iter   {     template<typename _Iterator1, typename _Iterator2>       constexpr       bool       operator()(_Iterator1 __it1, _Iterator2 __it2) const       { return *__it1 < *__it2; }   };   constexpr   inline _Iter_less_iter   __iter_less_iter()   { return _Iter_less_iter(); }   struct _Iter_less_val   {     template<typename _Iterator, typename _Value>       bool       operator()(_Iterator __it, _Value& __val) const       ;     };    _Iter_less_val   __iter_less_val()   ;    _Iter_less_val   __iter_comp_val(_Iter_less_iter)   ;   struct _Val_less_iter   {     template<typename _Value, typename _Iterator>       bool       operator()(_Value& __val, _Iterator __it) const       ;     };    _Val_less_iter   __val_less_iter()   ;    _Val_less_iter   __val_comp_iter(_Iter_less_iter)   ;   struct _Iter_equal_to_iter   {     template<typename _Iterator1, typename _Iterator2>       bool       operator()(_Iterator1 __it1, _Iterator2 __it2) const       ;     };    _Iter_equal_to_iter   __iter_equal_to_iter()   ;   struct _Iter_equal_to_val   {     template<typename _Iterator, typename _Value>       bool       operator()(_Iterator __it, _Value& __val) const       ;     };    _Iter_equal_to_val   __iter_equal_to_val()   ;    _Iter_equal_to_val   __iter_comp_val(_Iter_equal_to_iter)   ;   template<typename _Compare>     struct _Iter_comp_iter     {       _Compare _M_comp;       constexpr       _Iter_comp_iter(_Compare __comp)  : _M_comp(__comp)       { }       template<typename _Iterator1, typename _Iterator2>         constexpr         bool         operator()(_Iterator1 __it1, _Iterator2 __it2)         { return bool(_M_comp(*__it1, *__it2)); }     };   template<typename _Compare>     constexpr     inline _Iter_comp_iter<_Compare>     __iter_comp_iter(_Compare __comp)     { return _Iter_comp_iter<_Compare>(__comp); }   template<typename _Compare>     struct _Iter_comp_val     {       _Compare _M_comp;       _Iter_comp_val(_Compare __comp)  : _M_comp(__comp)       { }       template<typename _Iterator, typename _Value>  bool  operator()(_Iterator __it, _Value& __val)  { return bool(_M_comp(*__it, __val)); }     };   template<typename _Compare>    inline _Iter_comp_val<_Compare>     __iter_comp_val(_Compare __comp)     { return _Iter_comp_val<_Compare>(__comp); }   template<typename _Compare>     inline _Iter_comp_val<_Compare>     __iter_comp_val(_Iter_comp_iter<_Compare> __comp)     { return _Iter_comp_val<_Compare>(__comp._M_comp); }   template<typename _Compare>     struct _Val_comp_iter     {       _Compare _M_comp;       _Val_comp_iter(_Compare __comp)  : _M_comp(__comp)       { }       template<typename _Value, typename _Iterator>  bool  operator()(_Value& __val, _Iterator __it)  { return bool(_M_comp(__val, *__it)); }     };   template<typename _Compare>     inline _Val_comp_iter<_Compare>     __val_comp_iter(_Compare __comp)     { return _Val_comp_iter<_Compare>(__comp); }   template<typename _Compare>     inline _Val_comp_iter<_Compare>     __val_comp_iter(_Iter_comp_iter<_Compare> __comp)     { return _Val_comp_iter<_Compare>(__comp._M_comp); }   template<typename _Value>     struct _Iter_equals_val     {       _Value& _M_value;       _Iter_equals_val(_Value& __value)  : _M_value(__value)       { }       template<typename _Iterator>  bool  operator()(_Iterator __it)  { return *__it == _M_value; }     };   template<typename _Value>     inline _Iter_equals_val<_Value>     __iter_equals_val(_Value& __val)     { return _Iter_equals_val<_Value>(__val); }   template<typename _Iterator1>     struct _Iter_equals_iter     {       typename std::iterator_traits<_Iterator1>::reference _M_ref;       _Iter_equals_iter(_Iterator1 __it1)  : _M_ref(*__it1)       { }       template<typename _Iterator2>  bool  operator()(_Iterator2 __it2)  { return *__it2 == _M_ref; }     };   template<typename _Iterator>     inline _Iter_equals_iter<_Iterator>     __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)     { return _Iter_equals_iter<_Iterator>(__it); }   template<typename _Predicate>     struct _Iter_pred     {       _Predicate _M_pred;       _Iter_pred(_Predicate __pred)  : _M_pred(__pred)       { }       template<typename _Iterator>  bool  operator()(_Iterator __it)  { return bool(_M_pred(*__it)); }     };   template<typename _Predicate>     inline _Iter_pred<_Predicate>     __pred_iter(_Predicate __pred)     { return _Iter_pred<_Predicate>(__pred); }   template<typename _Compare, typename _Value>     struct _Iter_comp_to_val     {       _Compare _M_comp;       _Value& _M_value;       _Iter_comp_to_val(_Compare __comp, _Value& __value)  : _M_comp(__comp), _M_value(__value)       { }       template<typename _Iterator>  bool  operator()(_Iterator __it)  { return bool(_M_comp(*__it, _M_value)); }     };   template<typename _Compare, typename _Value>     _Iter_comp_to_val<_Compare, _Value>     __iter_comp_val(_Compare __comp, _Value &__val)     { return _Iter_comp_to_val<_Compare, _Value>(__comp, __val); }   template<typename _Compare, typename _Iterator1>     struct _Iter_comp_to_iter     {       _Compare _M_comp;       typename std::iterator_traits<_Iterator1>::reference _M_ref;       _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)  : _M_comp(__comp), _M_ref(*__it1)       { }       template<typename _Iterator2>  bool  operator()(_Iterator2 __it2)  { return bool(_M_comp(*__it2, _M_ref)); }     };   template<typename _Compare, typename _Iterator>     inline _Iter_comp_to_iter<_Compare, _Iterator>     __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)     { return _Iter_comp_to_iter<_Compare, _Iterator>(__comp._M_comp, __it); }   template<typename _Predicate>     struct _Iter_negate     {       _Predicate _M_pred;       _Iter_negate(_Predicate __pred)  : _M_pred(__pred)       { }       template<typename _Iterator>  bool  operator()(_Iterator __it)  { return !bool(_M_pred(*__it)); }     };   template<typename _Predicate>     inline _Iter_negate<_Predicate>     __negate(_Iter_pred<_Predicate> __pred)     { return _Iter_negate<_Predicate>(__pred._M_pred); } } }
# 72 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algobase.h" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) { 
# 118 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>      _OI     copy(_II __first, _II __last, _OI __result)     ; 
# 477 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>      _OI     move(_II __first, _II __last, _OI __result)     ;   template<bool, bool, typename>     struct __copy_move_backward     {       template<typename _BI1, typename _BI2>         static _BI2         __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         ;     };   template<typename _Category>     struct __copy_move_backward<true, false, _Category>     {       template<typename _BI1, typename _BI2>         static _BI2         __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         ;     };   template<>     struct __copy_move_backward<false, false, random_access_iterator_tag>     {                ;     };   template<>     struct __copy_move_backward<true, false, random_access_iterator_tag>     {                ;     };   template<bool _IsMove>     struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>     {                ;     };        ;        ; 
# 620 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algobase.h" 3
       ; 
# 656 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algobase.h" 3
       ;   inline constexpr int   __lg(int __n)   { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }   inline constexpr unsigned   __lg(unsigned __n)   { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }   inline constexpr long   __lg(long __n)   { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }   inline constexpr unsigned long   __lg(unsigned long __n)   { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }   inline constexpr long long   __lg(long long __n)   { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }   inline constexpr unsigned long long   __lg(unsigned long long __n)   { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); } 
# 1039 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algobase.h" 3
       ; 
# 1071 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algobase.h" 3
       ; 
# 1104 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algobase.h" 3
# 517 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_heap.h" 3
       ; 
# 530 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_heap.h" 3
       ; }
# 62 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_tempbuf.h" 1 3
# 60 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_tempbuf.h" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_construct.h" 1 3
# 61 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_construct.h" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ext/alloc_traits.h" 1 3
# 33 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ext/alloc_traits.h" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/alloc_traits.h" 1 3
# 35 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/alloc_traits.h" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/memoryfwd.h" 1 3
# 47 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/memoryfwd.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) { 
# 63 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/memoryfwd.h" 3
  template<typename>     class allocator;   template<>     class allocator<void>;   template<typename, typename>     struct uses_allocator; }
# 36 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/alloc_traits.h" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) {   struct __allocator_traits_base   {     template<typename _Alloc, typename _Up>       using __rebind = typename _Alloc::template rebind<_Up>::other;   protected:     template<typename _Tp>       using __pointer = typename _Tp::pointer;     template<typename _Tp>       using __c_pointer = typename _Tp::const_pointer;     template<typename _Tp>       using __v_pointer = typename _Tp::void_pointer;     template<typename _Tp>       using __cv_pointer = typename _Tp::const_void_pointer;     template<typename _Tp>       using __diff_type = typename _Tp::difference_type;     template<typename _Tp>       using __size_type = typename _Tp::size_type;     template<typename _Tp>       using __pocca = typename _Tp::propagate_on_container_copy_assignment;     template<typename _Tp>       using __pocma = typename _Tp::propagate_on_container_move_assignment;     template<typename _Tp>       using __pocs = typename _Tp::propagate_on_container_swap;     template<typename _Tp>       using __equal = typename _Tp::is_always_equal;   };   template<typename _Alloc, typename _Up>     using __alloc_rebind = __detected_or_t_<__replace_first_arg_t,          __allocator_traits_base::__rebind,          _Alloc, _Up>;   template<typename _Alloc>     struct allocator_traits : __allocator_traits_base     {       typedef _Alloc allocator_type;       typedef typename _Alloc::value_type value_type;       using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;       using const_pointer  = __detected_or_t<__ptr_rebind<pointer, const value_type>,      __c_pointer, _Alloc>;       using void_pointer  = __detected_or_t<__ptr_rebind<pointer, void>, __v_pointer, _Alloc>;       using const_void_pointer  = __detected_or_t<__ptr_rebind<pointer, const void>, __cv_pointer,      _Alloc>;       using difference_type  = __detected_or_t<typename pointer_traits<pointer>::difference_type,      __diff_type, _Alloc>;       using size_type  = __detected_or_t<typename make_unsigned<difference_type>::type,      __size_type, _Alloc>;       using propagate_on_container_copy_assignment  = __detected_or_t<false_type, __pocca, _Alloc>;       using propagate_on_container_move_assignment  = __detected_or_t<false_type, __pocma, _Alloc>;       using propagate_on_container_swap  = __detected_or_t<false_type, __pocs, _Alloc>;       using is_always_equal  = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;       template<typename _Tp>  using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;       template<typename _Tp>  using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;       static_assert(!is_same<rebind_alloc<value_type>, __undefined>::value,    "allocator defines rebind or is like Alloc<T, Args>");     private:       template<typename _Alloc2>  static auto  _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)  -> decltype(__a.allocate(__n, __hint))  { return __a.allocate(__n, __hint); }       template<typename _Alloc2>  static pointer  _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)  { return __a.allocate(__n); }       template<typename _Tp, typename... _Args>  struct __construct_helper  {    template<typename _Alloc2,      typename = decltype(std::declval<_Alloc2*>()->construct(     std::declval<_Tp*>(), std::declval<_Args>()...))>      static true_type __test(int);    template<typename>      static false_type __test(...);    using type = decltype(__test<_Alloc>(0));  };       template<typename _Tp, typename... _Args>  using __has_construct    = typename __construct_helper<_Tp, _Args...>::type;       template<typename _Tp, typename... _Args>  static _Require<__has_construct<_Tp, _Args...>>  _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)  { __a.construct(__p, std::forward<_Args>(__args)...); }       template<typename _Tp, typename... _Args>  static  _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,           is_constructible<_Tp, _Args...>>>  _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)  { ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }       template<typename _Alloc2, typename _Tp>  static auto  _S_destroy(_Alloc2& __a, _Tp* __p, int)  -> decltype(__a.destroy(__p))  { __a.destroy(__p); }       template<typename _Alloc2, typename _Tp>  static void  _S_destroy(_Alloc2&, _Tp* __p, ...)  { __p->~_Tp(); }       template<typename _Alloc2>  static auto  _S_max_size(_Alloc2& __a, int)  -> decltype(__a.max_size())  { return __a.max_size(); }       template<typename _Alloc2>  static size_type  _S_max_size(_Alloc2&, ...)  {    return __gnu_cxx::__numeric_traits<size_type>::__max      / sizeof(value_type);  }       template<typename _Alloc2>  static auto  _S_select(_Alloc2& __a, int)  -> decltype(__a.select_on_container_copy_construction())  { return __a.select_on_container_copy_construction(); }       template<typename _Alloc2>  static _Alloc2  _S_select(_Alloc2& __a, ...)  { return __a; }     public: 
# 279 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/alloc_traits.h" 3
      static pointer       allocate(_Alloc& __a, size_type __n)       { return __a.allocate(__n); } 
# 294 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/alloc_traits.h" 3
      static pointer       allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)       { return _S_allocate(__a, __n, __hint, 0); } 
# 346 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/alloc_traits.h" 3
      static size_type max_size(const _Alloc& __a) noexcept       { return _S_max_size(__a, 0); } 
# 357 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/alloc_traits.h" 3
      static _Alloc       select_on_container_copy_construction(const _Alloc& __rhs)       { return _S_select(__rhs, 0); }     };   template<typename _Tp>     struct allocator_traits<allocator<_Tp>>     {       using allocator_type = allocator<_Tp>;       using value_type = _Tp;       using pointer = _Tp*;       using const_pointer = const _Tp*;       using void_pointer = void*;       using const_void_pointer = const void*;       using difference_type = std::ptrdiff_t;       using size_type = std::size_t;       using propagate_on_container_copy_assignment = false_type;       using propagate_on_container_move_assignment = true_type;       using propagate_on_container_swap = false_type;       using is_always_equal = true_type;       template<typename _Up>  using rebind_alloc = allocator<_Up>;       template<typename _Up>  using rebind_traits = allocator_traits<allocator<_Up>>; 
# 414 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/alloc_traits.h" 3
      static pointer       allocate(allocator_type& __a, size_type __n)       ; 
# 428 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/alloc_traits.h" 3
      static pointer       allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)       ; 
# 440 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/alloc_traits.h" 3
      static void       deallocate(allocator_type& __a, pointer __p, size_type __n)       ; 
# 452 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>  static void  construct(allocator_type& __a, _Up* __p, _Args&&... __args)  ; 
# 464 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/alloc_traits.h" 3
      template<typename _Up>  static void  destroy(allocator_type& __a, _Up* __p)  ;       static size_type       max_size(const allocator_type& __a) noexcept       { return __a.max_size(); }       static allocator_type       select_on_container_copy_construction(const allocator_type& __rhs)       { return __rhs; }     };   template<typename _Alloc>      void     __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)     ;   template<typename _Alloc>      void     __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)     ;   template<typename _Alloc>      void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)     ;   template<typename _Alloc>      _Alloc __alloc_on_copy(const _Alloc& __a)     ;   template<typename _Alloc>      void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)     ;   template<typename _Alloc>      void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)     ;   template<typename _Alloc>      void __alloc_on_move(_Alloc& __one, _Alloc& __two)     ;   template<typename _Alloc>      void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)     ;   template<typename _Alloc>      void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)     ;   template<typename _Alloc>      void __alloc_on_swap(_Alloc& __one, _Alloc& __two)     ;   template<typename _Alloc>     class __is_copy_insertable_impl     {       typedef allocator_traits<_Alloc> _Traits;       template<typename _Up, typename         = decltype(_Traits::construct(std::declval<_Alloc&>(),           std::declval<_Up*>(),           std::declval<const _Up&>()))>  static true_type  _M_select(int);       template<typename _Up>  static false_type  _M_select(...);     public:       typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;     };   template<typename _Alloc>     struct __is_copy_insertable     : __is_copy_insertable_impl<_Alloc>::type     { };   template<typename _Tp>     struct __is_copy_insertable<allocator<_Tp>>     : is_copy_constructible<_Tp>     { }; }
# 37 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ext/alloc_traits.h" 2 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) { template<typename _Alloc>   struct __alloc_traits   : std::allocator_traits<_Alloc>   {     typedef _Alloc allocator_type;     typedef std::allocator_traits<_Alloc> _Base_type;     typedef typename _Base_type::value_type value_type;     typedef typename _Base_type::pointer pointer;     typedef typename _Base_type::const_pointer const_pointer;     typedef typename _Base_type::size_type size_type;     typedef typename _Base_type::difference_type difference_type;     typedef value_type& reference;     typedef const value_type& const_reference;     using _Base_type::allocate;     using _Base_type::deallocate;     using _Base_type::construct;     using _Base_type::destroy;     using _Base_type::max_size;   private:     template<typename _Ptr>       using __is_custom_pointer  = std::__and_<std::is_same<pointer, _Ptr>,         std::__not_<std::is_pointer<_Ptr>>>;   public:     template<typename _Ptr, typename... _Args>       static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type       construct(_Alloc& __a, _Ptr __p, _Args&&... __args)       ;     template<typename _Ptr>       static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type       destroy(_Alloc& __a, _Ptr __p)       ;     static _Alloc _S_select_on_copy(const _Alloc& __a)     ;     static void _S_on_swap(_Alloc& __a, _Alloc& __b)     ;     static constexpr bool _S_propagate_on_copy_assign()     { return _Base_type::propagate_on_container_copy_assignment::value; }     static constexpr bool _S_propagate_on_move_assign()     { return _Base_type::propagate_on_container_move_assignment::value; }     static constexpr bool _S_propagate_on_swap()     { return _Base_type::propagate_on_container_swap::value; }     static constexpr bool _S_always_equal()     { return _Base_type::is_always_equal::value; }     static constexpr bool _S_nothrow_move()     { return _S_propagate_on_move_assign() || _S_always_equal(); }     template<typename _Tp>       struct rebind       { typedef typename _Base_type::template rebind_alloc<_Tp> other; }; 
# 158 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ext/alloc_traits.h" 3
  }; }
# 62 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_construct.h" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _T1, typename... _Args>      void     _Construct(_T1* __p, _Args&&... __args)     ; 
# 90 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_construct.h" 3
  template<typename _Tp>      void     _Destroy(_Tp* __pointer)     ;   template<bool>     struct _Destroy_aux     {       template<typename _ForwardIterator>         static void         __destroy(_ForwardIterator __first, _ForwardIterator __last)  ;     };   template<>     struct _Destroy_aux<true>     {       template<typename _ForwardIterator>         static void         __destroy(_ForwardIterator, _ForwardIterator) ;     };   template<typename _ForwardIterator>      void     _Destroy(_ForwardIterator __first, _ForwardIterator __last)     ;   template<typename _ForwardIterator, typename _Allocator>     void     _Destroy(_ForwardIterator __first, _ForwardIterator __last,       _Allocator& __alloc)     ;   template<typename _ForwardIterator, typename _Tp>      void     _Destroy(_ForwardIterator __first, _ForwardIterator __last,       allocator<_Tp>&)     ; }
# 61 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_tempbuf.h" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) { 
# 83 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_tempbuf.h" 3
  template<typename _Tp>     pair<_Tp*, ptrdiff_t>     get_temporary_buffer(ptrdiff_t __len) noexcept     {       const ptrdiff_t __max =  __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);       if (__len > __max)  __len = __max;       while (__len > 0)  {    _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),        std::nothrow));    if (__tmp != 0)      return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);    __len /= 2;  }       return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);     } 
# 110 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_tempbuf.h" 3
  template<typename _Tp>     inline void     return_temporary_buffer(_Tp* __p)     { ::operator delete(__p, std::nothrow); }   template<typename _ForwardIterator, typename _Tp>     class _Temporary_buffer     {     public:       typedef _Tp value_type;       typedef value_type* pointer;       typedef pointer iterator;       typedef ptrdiff_t size_type;     protected:       size_type _M_original_len;       size_type _M_len;       pointer _M_buffer;     public:       size_type       size() const       { return _M_len; }       size_type       requested_size() const       { return _M_original_len; }       iterator       begin()       { return _M_buffer; }       iterator       end()       { return _M_buffer + _M_len; }       _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);       ~_Temporary_buffer()       {  std::_Destroy(_M_buffer, _M_buffer + _M_len);  std::return_temporary_buffer(_M_buffer);       }     private:       _Temporary_buffer(const _Temporary_buffer&);       void       operator=(const _Temporary_buffer&);     };   template<bool>     struct __uninitialized_construct_buf_dispatch     {       template<typename _Pointer, typename _ForwardIterator>         static void         __ucr(_Pointer __first, _Pointer __last,        _ForwardIterator __seed)         ;     };   template<>     struct __uninitialized_construct_buf_dispatch<true>     {       template<typename _Pointer, typename _ForwardIterator>         static void         __ucr(_Pointer, _Pointer, _ForwardIterator) ;     }; 
# 229 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_tempbuf.h" 3
  template<typename _Pointer, typename _ForwardIterator>      void     __uninitialized_construct_buf(_Pointer __first, _Pointer __last,       _ForwardIterator __seed)     ;   template<typename _ForwardIterator, typename _Tp>     _Temporary_buffer<_ForwardIterator, _Tp>::     _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)     : _M_original_len(std::distance(__first, __last)),       _M_len(0), _M_buffer(0)     {       try  {    std::pair<pointer, size_type> __p(std::get_temporary_buffer<          value_type>(_M_original_len));    _M_buffer = __p.first;    _M_len = __p.second;    if (_M_buffer)      std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,             __first);  }       catch(...)  {    std::return_temporary_buffer(_M_buffer);    _M_buffer = 0;    _M_len = 0;    throw;  }     } }
namespace std __attribute__ ((__visibility__ ("default"))) {   enum float_round_style   {     round_indeterminate = -1,     round_toward_zero = 0,     round_to_nearest = 1,     round_toward_infinity = 2,     round_toward_neg_infinity = 3   };   enum float_denorm_style   {     denorm_indeterminate = -1,     denorm_absent = 0,     denorm_present = 1   }; 
# 202 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/limits" 3
  struct __numeric_limits_base   {     static constexpr bool is_specialized = false;     static constexpr int digits = 0;     static constexpr int digits10 = 0;     static constexpr int max_digits10 = 0;     static constexpr bool is_signed = false;     static constexpr bool is_integer = false;     static constexpr bool is_exact = false;     static constexpr int radix = 0;     static constexpr int min_exponent = 0;     static constexpr int min_exponent10 = 0;     static constexpr int max_exponent = 0;     static constexpr int max_exponent10 = 0;     static constexpr bool has_infinity = false;     static constexpr bool has_quiet_NaN = false;     static constexpr bool has_signaling_NaN = false;     static constexpr float_denorm_style has_denorm = denorm_absent;     static constexpr bool has_denorm_loss = false;     static constexpr bool is_iec559 = false;     static constexpr bool is_bounded = false; 
# 288 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/limits" 3
    static constexpr bool is_modulo = false;     static constexpr bool traps = false;     static constexpr bool tinyness_before = false;     static constexpr float_round_style round_style =           round_toward_zero;   }; 
# 314 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/limits" 3
  template<typename _InputIterator, typename _RandomAccessIterator,     typename _Compare>      _RandomAccessIterator     partial_sort_copy(_InputIterator __first, _InputIterator __last,         _RandomAccessIterator __result_first,         _RandomAccessIterator __result_last,         _Compare __comp)     ;   template<typename _RandomAccessIterator, typename _Compare>     void     __unguarded_linear_insert(_RandomAccessIterator __last,          _Compare __comp)     ;   template<typename _RandomAccessIterator, typename _Compare>     void     __insertion_sort(_RandomAccessIterator __first,        _RandomAccessIterator __last, _Compare __comp)     ;   template<typename _RandomAccessIterator, typename _Compare>      void     __unguarded_insertion_sort(_RandomAccessIterator __first,           _RandomAccessIterator __last, _Compare __comp)     ;   enum { _S_threshold = 16 };   template<typename _RandomAccessIterator, typename _Compare>     void     __final_insertion_sort(_RandomAccessIterator __first,       _RandomAccessIterator __last, _Compare __comp)     ;   template<typename _RandomAccessIterator, typename _Compare>     _RandomAccessIterator     __unguarded_partition(_RandomAccessIterator __first,      _RandomAccessIterator __last,      _RandomAccessIterator __pivot, _Compare __comp)     ;   template<typename _RandomAccessIterator, typename _Compare>      _RandomAccessIterator     __unguarded_partition_pivot(_RandomAccessIterator __first,     _RandomAccessIterator __last, _Compare __comp)     ;   template<typename _RandomAccessIterator, typename _Compare>      void     __partial_sort(_RandomAccessIterator __first,      _RandomAccessIterator __middle,      _RandomAccessIterator __last,      _Compare __comp)     ;   template<typename _RandomAccessIterator, typename _Size, typename _Compare>     void     __introsort_loop(_RandomAccessIterator __first,        _RandomAccessIterator __last,        _Size __depth_limit, _Compare __comp)     ;   template<typename _RandomAccessIterator, typename _Compare>      void     __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,     _Compare __comp)     ;   template<typename _RandomAccessIterator, typename _Size, typename _Compare>     void     __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,     _RandomAccessIterator __last, _Size __depth_limit,     _Compare __comp)     ; 
# 2018 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
       ;   template<typename _ForwardIterator, typename _Tp, typename _Compare>     _ForwardIterator     __upper_bound(_ForwardIterator __first, _ForwardIterator __last,     const _Tp& __val, _Compare __comp)     ; 
# 2072 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
       ; 
# 2102 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
       ;   template<typename _InputIterator, typename _OutputIterator,     typename _Compare>     _OutputIterator     __move_merge(_InputIterator __first1, _InputIterator __last1,    _InputIterator __first2, _InputIterator __last2,    _OutputIterator __result, _Compare __comp)     ;   template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,     typename _Distance, typename _Compare>     void     __merge_sort_loop(_RandomAccessIterator1 __first,         _RandomAccessIterator1 __last,         _RandomAccessIterator2 __result, _Distance __step_size,         _Compare __comp)     ;   template<typename _RandomAccessIterator, typename _Distance,     typename _Compare>     void     __chunk_insertion_sort(_RandomAccessIterator __first,       _RandomAccessIterator __last,       _Distance __chunk_size, _Compare __comp)     ;   enum { _S_chunk_size = 7 };   template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>     void     __merge_sort_with_buffer(_RandomAccessIterator __first,         _RandomAccessIterator __last,         _Pointer __buffer, _Compare __comp)     ;   template<typename _RandomAccessIterator, typename _Pointer,     typename _Distance, typename _Compare>     void     __stable_sort_adaptive(_RandomAccessIterator __first,       _RandomAccessIterator __last,       _Pointer __buffer, _Distance __buffer_size,       _Compare __comp)     ;   template<typename _RandomAccessIterator, typename _Compare>     void     __inplace_stable_sort(_RandomAccessIterator __first,      _RandomAccessIterator __last, _Compare __comp)     ; 
# 2782 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,     typename _Compare>     bool     __includes(_InputIterator1 __first1, _InputIterator1 __last1,         _InputIterator2 __first2, _InputIterator2 __last2,         _Compare __comp)     ; 
# 2821 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
       ; 
# 2865 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>     inline void     nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,   _RandomAccessIterator __last, _Compare __comp)     {                                                     ;                                                    ;                                                                   ;       if (__first == __last || __nth == __last)  return;       std::__introselect(__first, __nth, __last,     std::__lg(__last - __first) * 2,     __gnu_cxx::__ops::__iter_comp_iter(__comp));     } 
# 4695 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>     inline void     sort(_RandomAccessIterator __first, _RandomAccessIterator __last)     {                                                      ;                                                      ;       std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());     } 
# 4725 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>     inline void     sort(_RandomAccessIterator __first, _RandomAccessIterator __last,   _Compare __comp)     {                                                      ;                                                                   ;       std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));     }   template<typename _InputIterator1, typename _InputIterator2,     typename _OutputIterator, typename _Compare>     _OutputIterator     __merge(_InputIterator1 __first1, _InputIterator1 __last1,      _InputIterator2 __first2, _InputIterator2 __last2,      _OutputIterator __result, _Compare __comp)     {       while (__first1 != __last1 && __first2 != __last2)  {    if (__comp(__first2, __first1))      {        *__result = *__first2;        ++__first2;      }    else      {        *__result = *__first1;        ++__first1;      }    ++__result;  }       return std::copy(__first2, __last2,          std::copy(__first1, __last1, __result));     } 
# 4786 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,     typename _OutputIterator>     inline _OutputIterator     merge(_InputIterator1 __first1, _InputIterator1 __last1,    _InputIterator2 __first2, _InputIterator2 __last2,    _OutputIterator __result)     { 
# 4803 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
                                                                ;                                                                 ;                                                         ;                                                         ;       return std::__merge(__first1, __last1,          __first2, __last2, __result,          __gnu_cxx::__ops::__iter_less_iter());     } 
# 4836 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,     typename _OutputIterator, typename _Compare>     inline _OutputIterator     merge(_InputIterator1 __first1, _InputIterator1 __last1,    _InputIterator2 __first2, _InputIterator2 __last2,    _OutputIterator __result, _Compare __comp)     { 
# 4853 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
                                                                             ;                                                                              ;                                                                      ;                                                                      ;       return std::__merge(__first1, __last1,     __first2, __last2, __result,     __gnu_cxx::__ops::__iter_comp_iter(__comp));     }   template<typename _RandomAccessIterator, typename _Compare>     inline void     __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,     _Compare __comp)     {       typedef typename iterator_traits<_RandomAccessIterator>::value_type  _ValueType;       typedef typename iterator_traits<_RandomAccessIterator>::difference_type  _DistanceType;       typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;       _TmpBuf __buf(__first, __last);       if (__buf.begin() == 0)  std::__inplace_stable_sort(__first, __last, __comp);       else  std::__stable_sort_adaptive(__first, __last, __buf.begin(),         _DistanceType(__buf.size()), __comp);     } 
# 4900 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>     inline void     stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)     {                                                      ;                                                      ;       std::__stable_sort(__first, __last,         __gnu_cxx::__ops::__iter_less_iter());     } 
# 4934 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>     inline void     stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,   _Compare __comp)     {                                                      ;                                                                   ;       std::__stable_sort(__first, __last,         __gnu_cxx::__ops::__iter_comp_iter(__comp));     }   template<typename _InputIterator1, typename _InputIterator2,     typename _OutputIterator,     typename _Compare>     _OutputIterator     __set_union(_InputIterator1 __first1, _InputIterator1 __last1,   _InputIterator2 __first2, _InputIterator2 __last2,   _OutputIterator __result, _Compare __comp)     {       while (__first1 != __last1 && __first2 != __last2)  {    if (__comp(__first1, __first2))      {        *__result = *__first1;        ++__first1;      }    else if (__comp(__first2, __first1))      {        *__result = *__first2;        ++__first2;      }    else      {        *__result = *__first1;        ++__first1;        ++__first2;      }    ++__result;  }       return std::copy(__first2, __last2,          std::copy(__first1, __last1, __result));     } 
# 5002 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,     typename _OutputIterator>     inline _OutputIterator     set_union(_InputIterator1 __first1, _InputIterator1 __last1,        _InputIterator2 __first2, _InputIterator2 __last2,        _OutputIterator __result)     { 
# 5022 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
                                                                ;                                                                 ;                                                         ;                                                         ;       return std::__set_union(__first1, __last1,     __first2, __last2, __result,     __gnu_cxx::__ops::__iter_less_iter());     } 
# 5051 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,     typename _OutputIterator, typename _Compare>     inline _OutputIterator     set_union(_InputIterator1 __first1, _InputIterator1 __last1,        _InputIterator2 __first2, _InputIterator2 __last2,        _OutputIterator __result, _Compare __comp)     { 
# 5071 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
                                                                             ;                                                                              ;                                                                      ;                                                                      ;       return std::__set_union(__first1, __last1,     __first2, __last2, __result,     __gnu_cxx::__ops::__iter_comp_iter(__comp));     }   template<typename _InputIterator1, typename _InputIterator2,     typename _OutputIterator,     typename _Compare>     _OutputIterator     __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,          _InputIterator2 __first2, _InputIterator2 __last2,          _OutputIterator __result, _Compare __comp)     {       while (__first1 != __last1 && __first2 != __last2)  if (__comp(__first1, __first2))    ++__first1;  else if (__comp(__first2, __first1))    ++__first2;  else    {      *__result = *__first1;      ++__first1;      ++__first2;      ++__result;    }       return __result;     } 
# 5121 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,     typename _OutputIterator>     inline _OutputIterator     set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,        _InputIterator2 __first2, _InputIterator2 __last2,        _OutputIterator __result)     { 
# 5139 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
                                                                ;                                                                 ;                                                         ;                                                         ;       return std::__set_intersection(__first1, __last1,          __first2, __last2, __result,          __gnu_cxx::__ops::__iter_less_iter());     } 
# 5169 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,     typename _OutputIterator, typename _Compare>     inline _OutputIterator     set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,        _InputIterator2 __first2, _InputIterator2 __last2,        _OutputIterator __result, _Compare __comp)     { 
# 5187 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
                                                                             ;                                                                              ;                                                                      ;                                                                      ;       return std::__set_intersection(__first1, __last1,     __first2, __last2, __result,     __gnu_cxx::__ops::__iter_comp_iter(__comp));     }   template<typename _InputIterator1, typename _InputIterator2,     typename _OutputIterator,     typename _Compare>     _OutputIterator     __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,        _InputIterator2 __first2, _InputIterator2 __last2,        _OutputIterator __result, _Compare __comp)     {       while (__first1 != __last1 && __first2 != __last2)  if (__comp(__first1, __first2))    {      *__result = *__first1;      ++__first1;      ++__result;    }  else if (__comp(__first2, __first1))    ++__first2;  else    {      ++__first1;      ++__first2;    }       return std::copy(__first1, __last1, __result);     } 
# 5241 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,     typename _OutputIterator>     inline _OutputIterator     set_difference(_InputIterator1 __first1, _InputIterator1 __last1,      _InputIterator2 __first2, _InputIterator2 __last2,      _OutputIterator __result)     { 
# 5259 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
                                                                ;                                                                 ;                                                         ;                                                         ;       return std::__set_difference(__first1, __last1,        __first2, __last2, __result,        __gnu_cxx::__ops::__iter_less_iter());     } 
# 5291 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,     typename _OutputIterator, typename _Compare>     inline _OutputIterator     set_difference(_InputIterator1 __first1, _InputIterator1 __last1,      _InputIterator2 __first2, _InputIterator2 __last2,      _OutputIterator __result, _Compare __comp)     { 
# 5309 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
                                                                             ;                                                                              ;                                                                      ;                                                                      ;       return std::__set_difference(__first1, __last1,        __first2, __last2, __result,        __gnu_cxx::__ops::__iter_comp_iter(__comp));     }   template<typename _InputIterator1, typename _InputIterator2,     typename _OutputIterator,     typename _Compare>     _OutputIterator     __set_symmetric_difference(_InputIterator1 __first1,           _InputIterator1 __last1,           _InputIterator2 __first2,           _InputIterator2 __last2,           _OutputIterator __result,           _Compare __comp)     {       while (__first1 != __last1 && __first2 != __last2)  if (__comp(__first1, __first2))    {      *__result = *__first1;      ++__first1;      ++__result;    }  else if (__comp(__first2, __first1))    {      *__result = *__first2;      ++__first2;      ++__result;    }  else    {      ++__first1;      ++__first2;    }       return std::copy(__first2, __last2,          std::copy(__first1, __last1, __result));     } 
# 5369 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,     typename _OutputIterator>     inline _OutputIterator     set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,         _InputIterator2 __first2, _InputIterator2 __last2,         _OutputIterator __result)     { 
# 5389 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
                                                                ;                                                                 ;                                                         ;                                                         ;       return std::__set_symmetric_difference(__first1, __last1,      __first2, __last2, __result,      __gnu_cxx::__ops::__iter_less_iter());     } 
# 5419 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,     typename _OutputIterator, typename _Compare>     inline _OutputIterator     set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,         _InputIterator2 __first2, _InputIterator2 __last2,         _OutputIterator __result,         _Compare __comp)     { 
# 5440 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
                                                                             ;                                                                              ;                                                                      ;                                                                      ;       return std::__set_symmetric_difference(__first1, __last1,     __first2, __last2, __result,     __gnu_cxx::__ops::__iter_comp_iter(__comp));     }   template<typename _ForwardIterator, typename _Compare>     constexpr     _ForwardIterator     __min_element(_ForwardIterator __first, _ForwardIterator __last,     _Compare __comp)     {       if (__first == __last)  return __first;       _ForwardIterator __result = __first;       while (++__first != __last)  if (__comp(__first, __result))    __result = __first;       return __result;     } 
# 5472 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator>     constexpr     _ForwardIterator     inline min_element(_ForwardIterator __first, _ForwardIterator __last)     {                                                      ;                                                      ;       return std::__min_element(__first, __last,     __gnu_cxx::__ops::__iter_less_iter());     } 
# 5497 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>     constexpr     inline _ForwardIterator     min_element(_ForwardIterator __first, _ForwardIterator __last,   _Compare __comp)     {                                                      ;                                                                   ;       return std::__min_element(__first, __last,     __gnu_cxx::__ops::__iter_comp_iter(__comp));     }   template<typename _ForwardIterator, typename _Compare>     constexpr     _ForwardIterator     __max_element(_ForwardIterator __first, _ForwardIterator __last,     _Compare __comp)     {       if (__first == __last) return __first;       _ForwardIterator __result = __first;       while (++__first != __last)  if (__comp(__result, __first))    __result = __first;       return __result;     } 
# 5536 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator>     constexpr     inline _ForwardIterator     max_element(_ForwardIterator __first, _ForwardIterator __last)     {                                                      ;                                                      ;       return std::__max_element(__first, __last,     __gnu_cxx::__ops::__iter_less_iter());     } 
# 5561 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>     constexpr     inline _ForwardIterator     max_element(_ForwardIterator __first, _ForwardIterator __last,   _Compare __comp)     {                                                      ;                                                                   ;       return std::__max_element(__first, __last,     __gnu_cxx::__ops::__iter_comp_iter(__comp));     } }
# 63 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/algorithm" 2 3
# 12 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TimeStamp.h" 2
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ostream" 1 3
# 37 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ostream" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ios" 1 3
# 37 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ios" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/iosfwd" 1 3
# 37 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/iosfwd" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stringfwd.h" 1 3
# 38 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stringfwd.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) { 
# 52 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stringfwd.h" 3
  template<class _CharT>     struct char_traits;   template<> struct char_traits<char>;   template<> struct char_traits<wchar_t>;   template<> struct char_traits<char16_t>;   template<> struct char_traits<char32_t>; namespace __cxx11 {   template<typename _CharT, typename _Traits = char_traits<_CharT>,            typename _Alloc = allocator<_CharT> >     class basic_string;   typedef basic_string<char> string;   typedef basic_string<wchar_t> wstring;   typedef basic_string<char16_t> u16string;   typedef basic_string<char32_t> u32string; } }
# 40 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/iosfwd" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/postypes.h" 1 3
# 39 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/postypes.h" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cwchar" 1 3
# 40 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cwchar" 3
# 1 "/usr/include/wchar.h" 1 3 4
# 45 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cwchar" 2 3
# 62 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cwchar" 3
namespace std {   using ::mbstate_t; }
# 135 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default"))) {   using ::wint_t;                           using ::getwc;                                       using ::vswprintf;                                 using ::wcslen;            using ::wcsrtombs;                           using ::wmemcmp;   using ::wmemcpy;   using ::wmemmove;   using ::wmemset;                     using ::wmemchr;    wchar_t*   wcschr(wchar_t* __p, wchar_t __c)   ;    wchar_t*   wcspbrk(wchar_t* __s1, const wchar_t* __s2)   ;    wchar_t*   wcsrchr(wchar_t* __p, wchar_t __c)   ;    wchar_t*   wcsstr(wchar_t* __s1, const wchar_t* __s2)   ;     }
 namespace __gnu_cxx {    
# 257 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cwchar" 3
      }
 namespace std {          }
# 277 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cwchar" 3
namespace std {                      }
# 41 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/postypes.h" 2 3
# 68 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) { 
# 88 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/postypes.h" 3
  typedef long streamoff; 
# 98 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/postypes.h" 3
  typedef ptrdiff_t streamsize; 
# 111 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/postypes.h" 3
  template<typename _StateT>     class fpos     {     private:       streamoff _M_off;       _StateT _M_state;     public:        
# 133 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/postypes.h" 3
                                                                   };        ;        ;   typedef fpos<mbstate_t> streampos;   typedef fpos<mbstate_t> wstreampos;   typedef fpos<mbstate_t> u16streampos;   typedef fpos<mbstate_t> u32streampos; }
# 41 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/iosfwd" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) { 
# 74 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/iosfwd" 3
  class ios_base;   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_ios;   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_streambuf;   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_istream;   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_ostream;   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_iostream; namespace __cxx11 {   template<typename _CharT, typename _Traits = char_traits<_CharT>,      typename _Alloc = allocator<_CharT> >     class basic_stringbuf;   template<typename _CharT, typename _Traits = char_traits<_CharT>,     typename _Alloc = allocator<_CharT> >     class basic_istringstream;   template<typename _CharT, typename _Traits = char_traits<_CharT>,     typename _Alloc = allocator<_CharT> >     class basic_ostringstream;   template<typename _CharT, typename _Traits = char_traits<_CharT>,     typename _Alloc = allocator<_CharT> >     class basic_stringstream; }   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_filebuf;   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_ifstream;   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_ofstream;   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class basic_fstream;   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class istreambuf_iterator;   template<typename _CharT, typename _Traits = char_traits<_CharT> >     class ostreambuf_iterator;   typedef basic_ios<char> ios;   typedef basic_streambuf<char> streambuf;   typedef basic_istream<char> istream;   typedef basic_ostream<char> ostream;   typedef basic_iostream<char> iostream;   typedef basic_stringbuf<char> stringbuf;   typedef basic_istringstream<char> istringstream;   typedef basic_ostringstream<char> ostringstream;   typedef basic_stringstream<char> stringstream;   typedef basic_filebuf<char> filebuf;   typedef basic_ifstream<char> ifstream;   typedef basic_ofstream<char> ofstream;   typedef basic_fstream<char> fstream;   typedef basic_ios<wchar_t> wios;   typedef basic_streambuf<wchar_t> wstreambuf;   typedef basic_istream<wchar_t> wistream;   typedef basic_ostream<wchar_t> wostream;   typedef basic_iostream<wchar_t> wiostream;   typedef basic_stringbuf<wchar_t> wstringbuf;   typedef basic_istringstream<wchar_t> wistringstream;   typedef basic_ostringstream<wchar_t> wostringstream;   typedef basic_stringstream<wchar_t> wstringstream;   typedef basic_filebuf<wchar_t> wfilebuf;   typedef basic_ifstream<wchar_t> wifstream;   typedef basic_ofstream<wchar_t> wofstream;   typedef basic_fstream<wchar_t> wfstream; }
# 39 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ios" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/char_traits.h" 1 3
# 38 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/char_traits.h" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cwchar" 1 3
# 40 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cwchar" 3
# 1 "/usr/include/wchar.h" 1 3 4
# 45 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cwchar" 2 3
# 42 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/char_traits.h" 2 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) { 
# 57 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/char_traits.h" 3
  template<typename _CharT>     struct _Char_types     {       typedef unsigned long int_type;       typedef std::streampos pos_type;       typedef std::streamoff off_type;       typedef std::mbstate_t state_type;     }; 
# 82 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/char_traits.h" 3
  template<typename _CharT>     struct char_traits     {       typedef _CharT char_type;       typedef typename _Char_types<_CharT>::int_type int_type;       typedef typename _Char_types<_CharT>::pos_type pos_type;       typedef typename _Char_types<_CharT>::off_type off_type;       typedef typename _Char_types<_CharT>::state_type state_type;              static constexpr bool       eq(const char_type& __c1, const char_type& __c2)       { return __c1 == __c2; }       static constexpr bool       lt(const char_type& __c1, const char_type& __c2)       { return __c1 < __c2; }       static int       compare(const char_type* __s1, const char_type* __s2, std::size_t __n);                            static char_type*       copy(char_type* __s1, const char_type* __s2, std::size_t __n);       static char_type*       assign(char_type* __s, std::size_t __n, char_type __a);       static constexpr char_type       to_char_type(const int_type& __c)       { return static_cast<char_type>(__c); }       static constexpr int_type       to_int_type(const char_type& __c)       { return static_cast<int_type>(__c); }       static constexpr bool       eq_int_type(const int_type& __c1, const int_type& __c2)       { return __c1 == __c2; }       static constexpr int_type       eof()       { return static_cast<int_type>(-1); }       static constexpr int_type       not_eof(const int_type& __c)       { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }     };                   }
 namespace std __attribute__ ((__visibility__ ("default"))) { 
# 226 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/char_traits.h" 3
  template<class _CharT>     struct char_traits : public __gnu_cxx::char_traits<_CharT>     { };   template<>     struct char_traits<char>     {       typedef char char_type;       typedef int int_type;       typedef streampos pos_type;       typedef streamoff off_type;       typedef mbstate_t state_type;       static void       assign(char_type& __c1, const char_type& __c2) noexcept       { __c1 = __c2; }       static constexpr bool       eq(const char_type& __c1, const char_type& __c2) noexcept       { return __c1 == __c2; }       static constexpr bool       lt(const char_type& __c1, const char_type& __c2) noexcept       {  return (static_cast<unsigned char>(__c1)   < static_cast<unsigned char>(__c2));       }       static int       compare(const char_type* __s1, const char_type* __s2, size_t __n)       {  if (__n == 0)    return 0;  return __builtin_memcmp(__s1, __s2, __n);       }       static size_t       length(const char_type* __s)       { return __builtin_strlen(__s); }       static const char_type*       find(const char_type* __s, size_t __n, const char_type& __a)       {  if (__n == 0)    return 0;  return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));       }       static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n)       {  if (__n == 0)    return __s1;  return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));       }       static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n)       {  if (__n == 0)    return __s1;  return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));       }       static char_type*       assign(char_type* __s, size_t __n, char_type __a)       {  if (__n == 0)    return __s;  return static_cast<char_type*>(__builtin_memset(__s, __a, __n));       }       static constexpr char_type       to_char_type(const int_type& __c) noexcept       { return static_cast<char_type>(__c); }       static constexpr int_type       to_int_type(const char_type& __c) noexcept       { return static_cast<int_type>(static_cast<unsigned char>(__c)); }       static constexpr bool       eq_int_type(const int_type& __c1, const int_type& __c2) noexcept       { return __c1 == __c2; }       static constexpr int_type       eof() noexcept       { return static_cast<int_type>(-1); }       static constexpr int_type       not_eof(const int_type& __c) noexcept       { return (__c == eof()) ? 0 : __c; }   };   template<>     struct char_traits<wchar_t>     {       typedef wchar_t char_type;       typedef wint_t int_type;       typedef streamoff off_type;       typedef wstreampos pos_type;       typedef mbstate_t state_type;       static void       assign(char_type& __c1, const char_type& __c2) noexcept       { __c1 = __c2; }       static constexpr bool       eq(const char_type& __c1, const char_type& __c2) noexcept       { return __c1 == __c2; }       static constexpr bool       lt(const char_type& __c1, const char_type& __c2) noexcept       { return __c1 < __c2; }       static int       compare(const char_type* __s1, const char_type* __s2, size_t __n)       {  if (__n == 0)    return 0;  return wmemcmp(__s1, __s2, __n);       }       static size_t       length(const char_type* __s)       { return wcslen(__s); }       static const char_type*       find(const char_type* __s, size_t __n, const char_type& __a)       {  if (__n == 0)    return 0;  return wmemchr(__s, __a, __n);       }       static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n)       {  if (__n == 0)    return __s1;  return wmemmove(__s1, __s2, __n);       }       static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n)       {  if (__n == 0)    return __s1;  return wmemcpy(__s1, __s2, __n);       }       static char_type*       assign(char_type* __s, size_t __n, char_type __a)       {  if (__n == 0)    return __s;  return wmemset(__s, __a, __n);       }       static constexpr char_type       to_char_type(const int_type& __c) noexcept       { return char_type(__c); }       static constexpr int_type       to_int_type(const char_type& __c) noexcept       { return int_type(__c); }       static constexpr bool       eq_int_type(const int_type& __c1, const int_type& __c2) noexcept       { return __c1 == __c2; }       static constexpr int_type       eof() noexcept       { return static_cast<int_type>((0xffffffffu)); }       static constexpr int_type       not_eof(const int_type& __c) noexcept       { return eq_int_type(__c, eof()) ? 0 : __c; }   }; }
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cstdint" 1 3
# 33 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cstdint" 3
# 46 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cstdint" 3
namespace std {   using ::int8_t;   using ::int16_t;   using ::int32_t;   using ::int64_t;   using ::int_fast8_t;   using ::int_fast16_t;   using ::int_fast32_t;   using ::int_fast64_t;   using ::int_least8_t;   using ::int_least16_t;   using ::int_least32_t;   using ::int_least64_t;   using ::intmax_t;   using ::intptr_t;   using ::uint8_t;   using ::uint16_t;   using ::uint32_t;   using ::uint64_t;   using ::uint_fast8_t;   using ::uint_fast16_t;   using ::uint_fast32_t;   using ::uint_fast64_t;   using ::uint_least8_t;   using ::uint_least16_t;   using ::uint_least32_t;   using ::uint_least64_t;   using ::uintmax_t;   using ::uintptr_t; }
# 421 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/char_traits.h" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) {   template<>     struct char_traits<char16_t>     {       typedef char16_t char_type;       typedef uint_least16_t int_type;       typedef streamoff off_type;       typedef u16streampos pos_type;       typedef mbstate_t state_type;       static void       assign(char_type& __c1, const char_type& __c2) noexcept       { __c1 = __c2; }       static constexpr bool       eq(const char_type& __c1, const char_type& __c2) noexcept       { return __c1 == __c2; }       static constexpr bool       lt(const char_type& __c1, const char_type& __c2) noexcept       { return __c1 < __c2; }       static int       compare(const char_type* __s1, const char_type* __s2, size_t __n)       {  for (size_t __i = 0; __i < __n; ++__i)    if (lt(__s1[__i], __s2[__i]))      return -1;    else if (lt(__s2[__i], __s1[__i]))      return 1;  return 0;       }       static size_t       length(const char_type* __s)       {  size_t __i = 0;  while (!eq(__s[__i], char_type()))    ++__i;  return __i;       }       static const char_type*       find(const char_type* __s, size_t __n, const char_type& __a)       {  for (size_t __i = 0; __i < __n; ++__i)    if (eq(__s[__i], __a))      return __s + __i;  return 0;       }       static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n)       {  if (__n == 0)    return __s1;  return (static_cast<char_type*>   (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));       }       static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n)       {  if (__n == 0)    return __s1;  return (static_cast<char_type*>   (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));       }       static char_type*       assign(char_type* __s, size_t __n, char_type __a)       {  for (size_t __i = 0; __i < __n; ++__i)    assign(__s[__i], __a);  return __s;       }       static constexpr char_type       to_char_type(const int_type& __c) noexcept       { return char_type(__c); }       static constexpr int_type       to_int_type(const char_type& __c) noexcept       { return int_type(__c); }       static constexpr bool       eq_int_type(const int_type& __c1, const int_type& __c2) noexcept       { return __c1 == __c2; }       static constexpr int_type       eof() noexcept       { return static_cast<int_type>(-1); }       static constexpr int_type       not_eof(const int_type& __c) noexcept       { return eq_int_type(__c, eof()) ? 0 : __c; }     };   template<>     struct char_traits<char32_t>     {       typedef char32_t char_type;       typedef uint_least32_t int_type;       typedef streamoff off_type;       typedef u32streampos pos_type;       typedef mbstate_t state_type;       static void       assign(char_type& __c1, const char_type& __c2) noexcept       { __c1 = __c2; }       static constexpr bool       eq(const char_type& __c1, const char_type& __c2) noexcept       { return __c1 == __c2; }       static constexpr bool       lt(const char_type& __c1, const char_type& __c2) noexcept       { return __c1 < __c2; }       static int       compare(const char_type* __s1, const char_type* __s2, size_t __n)       {  for (size_t __i = 0; __i < __n; ++__i)    if (lt(__s1[__i], __s2[__i]))      return -1;    else if (lt(__s2[__i], __s1[__i]))      return 1;  return 0;       }       static size_t       length(const char_type* __s)       {  size_t __i = 0;  while (!eq(__s[__i], char_type()))    ++__i;  return __i;       }       static const char_type*       find(const char_type* __s, size_t __n, const char_type& __a)       {  for (size_t __i = 0; __i < __n; ++__i)    if (eq(__s[__i], __a))      return __s + __i;  return 0;       }       static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n)       {  if (__n == 0)    return __s1;  return (static_cast<char_type*>   (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));       }       static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n)       {  if (__n == 0)    return __s1;  return (static_cast<char_type*>   (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));       }       static char_type*       assign(char_type* __s, size_t __n, char_type __a)       {  for (size_t __i = 0; __i < __n; ++__i)    assign(__s[__i], __a);  return __s;       }       static constexpr char_type       to_char_type(const int_type& __c) noexcept       { return char_type(__c); }       static constexpr int_type       to_int_type(const char_type& __c) noexcept       { return int_type(__c); }       static constexpr bool       eq_int_type(const int_type& __c1, const int_type& __c2) noexcept       { return __c1 == __c2; }       static constexpr int_type       eof() noexcept       { return static_cast<int_type>(-1); }       static constexpr int_type       not_eof(const int_type& __c) noexcept       { return eq_int_type(__c, eof()) ? 0 : __c; }     }; }
# 41 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ios" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/localefwd.h" 1 3
# 38 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/localefwd.h" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/x86_64-redhat-linux/bits/c++locale.h" 1 3
# 40 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/x86_64-redhat-linux/bits/c++locale.h" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/clocale" 1 3
# 40 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/clocale" 3
# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/local/bin/../lib/clang/3.9.1/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4
extern "C" { 
# 53 "/usr/include/locale.h" 3 4
struct lconv {   char *decimal_point;   char *thousands_sep;   char *grouping;   char *int_curr_symbol;   char *currency_symbol;   char *mon_decimal_point;   char *mon_thousands_sep;   char *mon_grouping;   char *positive_sign;   char *negative_sign;   char int_frac_digits;   char frac_digits;   char p_cs_precedes;   char p_sep_by_space;   char n_cs_precedes;   char n_sep_by_space;   char p_sign_posn;   char n_sign_posn;   char int_p_cs_precedes;   char int_p_sep_by_space;   char int_n_cs_precedes;   char int_n_sep_by_space;   char int_p_sign_posn;   char int_n_sign_posn; 
# 120 "/usr/include/locale.h" 3 4
}; ; ; 
# 151 "/usr/include/locale.h" 3 4
; 
# 186 "/usr/include/locale.h" 3 4
; ; extern __locale_t uselocale (__locale_t __dataset) throw (); }
# 43 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/clocale" 2 3
namespace std {   using ::lconv;       }
# 42 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/x86_64-redhat-linux/bits/c++locale.h" 2 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {   ; }
 namespace std __attribute__ ((__visibility__ ("default"))) {   typedef __locale_t __c_locale;     }
# 41 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/localefwd.h" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cctype" 1 3
# 40 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cctype" 3
# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4
extern "C" { 
# 46 "/usr/include/ctype.h" 3 4
enum {   _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),   _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),   _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),   _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),   _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),   _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),   _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),   _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),   _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),   _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),   _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),   _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8)) }; 
# 79 "/usr/include/ctype.h" 3 4
; ; extern const __int32_t **__ctype_toupper_loc (void)      throw () __attribute__ ((__const__)); 
# 110 "/usr/include/ctype.h" 3 4
extern int isalnum (int) throw (); extern int isalpha (int) throw (); ; ; ; ; ; ; ; ; ; ; ; 
# 136 "/usr/include/ctype.h" 3 4
; ; ; ; ; ; 
# 271 "/usr/include/ctype.h" 3 4
; ; ; ; ; ; ; ; ; ; ; ; ; ; ; ; 
# 347 "/usr/include/ctype.h" 3 4
}
# 43 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cctype" 2 3
# 62 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cctype" 3
namespace std {   using ::isalnum;   using ::isalpha;                                  }
 namespace std {    }
# 43 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/localefwd.h" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) { 
# 55 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/localefwd.h" 3
  class locale;   ;   template<typename _Facet>     const _Facet&     use_facet(const locale&);   template<typename _CharT>     bool     isspace(_CharT, const locale&);   template<typename _CharT>     bool     isprint(_CharT, const locale&);   template<typename _CharT>     bool     iscntrl(_CharT, const locale&);   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   ;   class ctype_base;   template<typename _CharT>     class ctype;   template<> class ctype<char>;   template<> class ctype<wchar_t>;   template<typename _CharT>     class ctype_byname;   class codecvt_base;   template<typename _InternT, typename _ExternT, typename _StateT>     class codecvt;   template<> class codecvt<char, char, mbstate_t>;   template<> class codecvt<wchar_t, char, mbstate_t>;   template<typename _InternT, typename _ExternT, typename _StateT>     class codecvt_byname;   template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >     class num_get;   template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >     class num_put; namespace __cxx11 {   template<typename _CharT> class numpunct;   template<typename _CharT> class numpunct_byname; } namespace __cxx11 {   template<typename _CharT>     class collate;   template<typename _CharT>     class collate_byname; }   class time_base; namespace __cxx11 {   template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >     class time_get;   template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >     class time_get_byname; }   template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >     class time_put;   template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >     class time_put_byname;   class money_base; namespace __cxx11 {   template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >     class money_get;   template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >     class money_put; } namespace __cxx11 {   template<typename _CharT, bool _Intl = false>     class moneypunct;   template<typename _CharT, bool _Intl = false>     class moneypunct_byname; }   class messages_base; namespace __cxx11 {   template<typename _CharT>     class messages;   template<typename _CharT>     class messages_byname; } }
# 42 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ios" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ios_base.h" 1 3
# 38 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ios_base.h" 3
struct sched_param   {     int __sched_priority;   };
 extern "C" { ; ; ; ; }
 struct __sched_param   {     int __sched_priority;   };
# 119 "/usr/include/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;
 typedef struct {   __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))]; }
 cpu_set_t;
# 202 "/usr/include/bits/sched.h" 3 4
extern "C" { ;  ; ; }
# 44 "/usr/include/sched.h" 2 3 4
extern "C" { ; ; ; ; ; ; ; ; 
# 118 "/usr/include/sched.h" 3 4
# 1111 "/usr/include/pthread.h" 3 4
; ; ;  ; ; 
# 1145 "/usr/include/pthread.h" 3 4
; 
# 1159 "/usr/include/pthread.h" 3 4
}
# 36 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/x86_64-redhat-linux/bits/gthr-default.h" 2 3
# 47 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/x86_64-redhat-linux/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
 typedef pthread_key_t __gthread_key_t;
 typedef pthread_once_t __gthread_once_t;
 typedef pthread_mutex_t __gthread_mutex_t;
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/x86_64-redhat-linux/bits/atomic_word.h" 1 3
# 32 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/x86_64-redhat-linux/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ext/atomicity.h" 2 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {      static void   __atomic_add(volatile _Atomic_word* __mem, int __val)   ; 
# 64 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ext/atomicity.h" 3
  static _Atomic_word   __exchange_and_add_single(_Atomic_word* __mem, int __val)   ;   static void   __atomic_add_single(_Atomic_word* __mem, int __val)   ;   static _Atomic_word   __attribute__ ((__unused__))   __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)   ;   static void   __attribute__ ((__unused__))   __atomic_add_dispatch(_Atomic_word* __mem, int __val)   ; }
# 40 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ios_base.h" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.h" 1 3
# 38 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.h" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/string" 1 3
# 37 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/string" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/allocator.h" 1 3
# 46 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/allocator.h" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/x86_64-redhat-linux/bits/c++allocator.h" 1 3
# 33 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/x86_64-redhat-linux/bits/c++allocator.h" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ext/new_allocator.h" 1 3
# 40 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ext/new_allocator.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {   using std::size_t;   using std::ptrdiff_t; 
# 57 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ext/new_allocator.h" 3
  template<typename _Tp>     class new_allocator     {     public:       typedef size_t size_type;       typedef ptrdiff_t difference_type;       typedef _Tp* pointer;       typedef const _Tp* const_pointer;       typedef _Tp& reference;       typedef const _Tp& const_reference;       typedef _Tp value_type;       template<typename _Tp1>         struct rebind         { typedef new_allocator<_Tp1> other; };       typedef std::true_type propagate_on_container_move_assignment;       new_allocator() noexcept { }       new_allocator(const new_allocator&) noexcept { }       template<typename _Tp1>         new_allocator(const new_allocator<_Tp1>&) noexcept { }       ~new_allocator() noexcept { }       pointer       address(reference __x) const noexcept       { return std::__addressof(__x); }       const_pointer       address(const_reference __x) const noexcept       { return std::__addressof(__x); }       pointer       allocate(size_type __n, const void* = 0)       {  if (__n > this->max_size())    std::__throw_bad_alloc();  return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));       }       void       deallocate(pointer __p, size_type)       { ::operator delete(__p); }       size_type       max_size() const noexcept       { return size_t(-1) / sizeof(_Tp); }       template<typename _Up, typename... _Args>         void         construct(_Up* __p, _Args&&... __args)  { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }       template<typename _Up>         void         destroy(_Up* __p) { __p->~_Up(); } 
# 135 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ext/new_allocator.h" 3
    };   template<typename _Tp>      bool     operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)     ;   template<typename _Tp>      bool     operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)     ; }
# 34 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/x86_64-redhat-linux/bits/c++allocator.h" 2 3
namespace std { 
# 47 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/x86_64-redhat-linux/bits/c++allocator.h" 3
  template<typename _Tp>     using __allocator_base = __gnu_cxx::new_allocator<_Tp>; }
# 47 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/allocator.h" 2 3
# 57 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) { 
# 67 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/allocator.h" 3
  template<>     class allocator<void>     {     public:       typedef size_t size_type;       typedef ptrdiff_t difference_type;       typedef void* pointer;       typedef const void* const_pointer;       typedef void value_type;       template<typename _Tp1>         struct rebind         { typedef allocator<_Tp1> other; };       typedef true_type propagate_on_container_move_assignment;       typedef true_type is_always_equal;       template<typename _Up, typename... _Args>  void  construct(_Up* __p, _Args&&... __args)  ;       template<typename _Up>  void  destroy(_Up* __p) ;     }; 
# 107 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/allocator.h" 3
  template<typename _Tp>     class allocator: public __allocator_base<_Tp>     {    public:       typedef size_t size_type;       typedef ptrdiff_t difference_type;       typedef _Tp* pointer;       typedef const _Tp* const_pointer;       typedef _Tp& reference;       typedef const _Tp& const_reference;       typedef _Tp value_type;       template<typename _Tp1>         struct rebind         { typedef allocator<_Tp1> other; };       typedef true_type propagate_on_container_move_assignment;       typedef true_type is_always_equal;       allocator() throw() ;       allocator(const allocator& __a) throw()  ;       template<typename _Tp1>         allocator(const allocator<_Tp1>&) throw() ;       ~allocator() throw() ;     };   template<typename _T1, typename _T2>     inline bool     operator==(const allocator<_T1>&, const allocator<_T2>&)     noexcept     { return true; }   template<typename _Tp>     inline bool     operator==(const allocator<_Tp>&, const allocator<_Tp>&)     noexcept     { return true; }   template<typename _T1, typename _T2>     inline bool     operator!=(const allocator<_T1>&, const allocator<_T2>&)     noexcept     { return false; }   template<typename _Tp>     inline bool     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)     noexcept     { return false; }   extern template class allocator<char>;   extern template class allocator<wchar_t>;   template<typename _Alloc, bool = __is_empty(_Alloc)>     struct __alloc_swap     { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };   template<typename _Alloc>     struct __alloc_swap<_Alloc, false>     {       static void       _S_do_it(_Alloc& __one, _Alloc& __two) noexcept       {  if (__one != __two)    swap(__one, __two);       }     };   template<typename _Alloc, bool = __is_empty(_Alloc)>     struct __alloc_neq     {       static bool       _S_do_it(const _Alloc&, const _Alloc&)       ;     };   template<typename _Alloc>     struct __alloc_neq<_Alloc, false>     {       static bool       _S_do_it(const _Alloc& __one, const _Alloc& __two)       ;     };   template<typename _Tp, bool     = __or_<is_copy_constructible<typename _Tp::value_type>,             is_nothrow_move_constructible<typename _Tp::value_type>>::value>     struct __shrink_to_fit_aux     { static bool _S_do_it(_Tp&) noexcept { return false; } };   template<typename _Tp>     struct __shrink_to_fit_aux<_Tp, true>     {       static bool       _S_do_it(_Tp& __c) noexcept       {  try    {      _Tp(__make_move_if_noexcept_iterator(__c.begin()),   __make_move_if_noexcept_iterator(__c.end()),   __c.get_allocator()).swap(__c);      return true;    }  catch(...)    { return false; }       }     }; }
# 42 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/string" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ostream_insert.h" 1 3
# 37 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ostream_insert.h" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _CharT, typename _Traits>      void     __ostream_write(basic_ostream<_CharT, _Traits>& __out,       const _CharT* __s, streamsize __n)     ;   template<typename _CharT, typename _Traits>      void     __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)     ;   template<typename _CharT, typename _Traits>     basic_ostream<_CharT, _Traits>&     __ostream_insert(basic_ostream<_CharT, _Traits>& __out,        const _CharT* __s, streamsize __n)     ;   extern template ostream& __ostream_insert(ostream&, const char*, streamsize);   extern template wostream& __ostream_insert(wostream&, const wchar_t*,           streamsize); }
# 45 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/string" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_function.h" 1 3
# 63 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) { 
# 104 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>     struct unary_function     {       typedef _Arg argument_type;       typedef _Result result_type;     };   template<typename _Arg1, typename _Arg2, typename _Result>     struct binary_function     {       typedef _Arg1 first_argument_type;       typedef _Arg2 second_argument_type;       typedef _Result result_type;     }; 
# 144 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_function.h" 3
  struct __is_transparent;   template<typename _Tp = void>     struct plus;   template<typename _Tp = void>     struct minus;   template<typename _Tp = void>     struct multiplies;   template<typename _Tp = void>     struct divides;   template<typename _Tp = void>     struct modulus;   template<typename _Tp = void>     struct negate;   template<typename _Tp>     struct plus : public binary_function<_Tp, _Tp, _Tp>     {       constexpr       _Tp       operator()(const _Tp& __x, const _Tp& __y) const       { return __x + __y; }     };   template<typename _Tp>     struct minus : public binary_function<_Tp, _Tp, _Tp>     {       constexpr       _Tp       operator()(const _Tp& __x, const _Tp& __y) const       { return __x - __y; }     };   template<typename _Tp>     struct multiplies : public binary_function<_Tp, _Tp, _Tp>     {       constexpr       _Tp       operator()(const _Tp& __x, const _Tp& __y) const       { return __x * __y; }     };   template<typename _Tp>     struct divides : public binary_function<_Tp, _Tp, _Tp>     {       constexpr       _Tp       operator()(const _Tp& __x, const _Tp& __y) const       { return __x / __y; }     };   template<typename _Tp>     struct modulus : public binary_function<_Tp, _Tp, _Tp>     {       constexpr       _Tp       operator()(const _Tp& __x, const _Tp& __y) const       { return __x % __y; }     };   template<typename _Tp>     struct negate : public unary_function<_Tp, _Tp>     {       constexpr       _Tp       operator()(const _Tp& __x) const       { return -__x; }     };   template<>     struct plus<void>     {       template <typename _Tp, typename _Up>  constexpr  auto  operator()(_Tp&& __t, _Up&& __u) const  noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))  -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))  { return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }       typedef __is_transparent is_transparent;     };   template<>     struct minus<void>     {       template <typename _Tp, typename _Up>  constexpr  auto  operator()(_Tp&& __t, _Up&& __u) const  noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))  -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))  { return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }       typedef __is_transparent is_transparent;     };   template<>     struct multiplies<void>     {       template <typename _Tp, typename _Up>  constexpr  auto  operator()(_Tp&& __t, _Up&& __u) const  noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))  -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))  { return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }       typedef __is_transparent is_transparent;     };   template<>     struct divides<void>     {       template <typename _Tp, typename _Up>  constexpr  auto  operator()(_Tp&& __t, _Up&& __u) const  noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))  -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))  { return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }       typedef __is_transparent is_transparent;     };   template<>     struct modulus<void>     {       template <typename _Tp, typename _Up>  constexpr  auto  operator()(_Tp&& __t, _Up&& __u) const  noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))  -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))  { return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }       typedef __is_transparent is_transparent;     };   template<>     struct negate<void>     {       template <typename _Tp>  constexpr  auto  operator()(_Tp&& __t) const  noexcept(noexcept(-std::forward<_Tp>(__t)))  -> decltype(-std::forward<_Tp>(__t))  { return -std::forward<_Tp>(__t); }       typedef __is_transparent is_transparent;     }; 
# 330 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_function.h" 3
  template<typename _Tp = void>     struct equal_to;   template<typename _Tp = void>     struct not_equal_to;   template<typename _Tp = void>     struct greater;   template<typename _Tp = void>     struct less;   template<typename _Tp = void>     struct greater_equal;   template<typename _Tp = void>     struct less_equal;   template<typename _Tp>     struct equal_to : public binary_function<_Tp, _Tp, bool>     {       constexpr       bool       operator()(const _Tp& __x, const _Tp& __y) const       { return __x == __y; }     };   template<typename _Tp>     struct not_equal_to : public binary_function<_Tp, _Tp, bool>     {       constexpr       bool       operator()(const _Tp& __x, const _Tp& __y) const       { return __x != __y; }     };   template<typename _Tp>     struct greater : public binary_function<_Tp, _Tp, bool>     {       constexpr       bool       operator()(const _Tp& __x, const _Tp& __y) const       { return __x > __y; }     };   template<typename _Tp>     struct less : public binary_function<_Tp, _Tp, bool>     {       constexpr       bool       operator()(const _Tp& __x, const _Tp& __y) const       { return __x < __y; }     };   template<typename _Tp>     struct greater_equal : public binary_function<_Tp, _Tp, bool>     {       constexpr       bool       operator()(const _Tp& __x, const _Tp& __y) const       { return __x >= __y; }     };   template<typename _Tp>     struct less_equal : public binary_function<_Tp, _Tp, bool>     {       constexpr       bool       operator()(const _Tp& __x, const _Tp& __y) const       { return __x <= __y; }     };   template<>     struct equal_to<void>     {       template <typename _Tp, typename _Up>  constexpr  auto  operator()(_Tp&& __t, _Up&& __u) const  noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))  -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))  { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }       typedef __is_transparent is_transparent;     };   template<>     struct not_equal_to<void>     {       template <typename _Tp, typename _Up>  constexpr  auto  operator()(_Tp&& __t, _Up&& __u) const  noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))  -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))  { return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }       typedef __is_transparent is_transparent;     };   template<>     struct greater<void>     {       template <typename _Tp, typename _Up>  constexpr  auto  operator()(_Tp&& __t, _Up&& __u) const  noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))  -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))  { return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }       typedef __is_transparent is_transparent;     };   template<>     struct less<void>     {       template <typename _Tp, typename _Up>  constexpr  auto  operator()(_Tp&& __t, _Up&& __u) const  noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))  -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))  { return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }       typedef __is_transparent is_transparent;     };   template<>     struct greater_equal<void>     {       template <typename _Tp, typename _Up>  constexpr  auto  operator()(_Tp&& __t, _Up&& __u) const  noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))  -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))  { return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }       typedef __is_transparent is_transparent;     };   template<>     struct less_equal<void>     {       template <typename _Tp, typename _Up>  constexpr  auto  operator()(_Tp&& __t, _Up&& __u) const  noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))  -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))  { return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }       typedef __is_transparent is_transparent;     }; 
# 937 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>     class mem_fun_t : public unary_function<_Tp*, _Ret>     {     public:                   private:       _Ret (_Tp::*_M_f)();     };   template<typename _Ret, typename _Tp>     class const_mem_fun_t : public unary_function<const _Tp*, _Ret>     {     public:                   private:       _Ret (_Tp::*_M_f)() const;     };   template<typename _Ret, typename _Tp>     class mem_fun_ref_t : public unary_function<_Tp, _Ret>     {     public:                   private:       _Ret (_Tp::*_M_f)();   };   template<typename _Ret, typename _Tp>     class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>     {     public:                   private:       _Ret (_Tp::*_M_f)() const;     };   template<typename _Ret, typename _Tp, typename _Arg>     class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>     {     public:                   private:       _Ret (_Tp::*_M_f)(_Arg);     };   template<typename _Ret, typename _Tp, typename _Arg>     class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>     {     public:                   private:       _Ret (_Tp::*_M_f)(_Arg) const;     };   template<typename _Ret, typename _Tp, typename _Arg>     class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>     {     public:                   private:       _Ret (_Tp::*_M_f)(_Arg);     };   template<typename _Ret, typename _Tp, typename _Arg>     class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>     {     public:                   private:       _Ret (_Tp::*_M_f)(_Arg) const;     };        ;        ;        ;        ;        ;        ;        ;        ; }
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/backward/binders.h" 1 3
# 60 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_string.h" 1 3
# 38 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_string.h" 3
# 47 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_string.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) { namespace __cxx11 { 
# 71 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>     class basic_string     {       typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template  rebind<_CharT>::other _Char_alloc_type;       typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;     public:       typedef _Traits traits_type;       typedef typename _Traits::char_type value_type;       typedef _Char_alloc_type allocator_type;       typedef typename _Alloc_traits::size_type size_type;       typedef typename _Alloc_traits::difference_type difference_type;       typedef typename _Alloc_traits::reference reference;       typedef typename _Alloc_traits::const_reference const_reference;       typedef typename _Alloc_traits::pointer pointer;       typedef typename _Alloc_traits::const_pointer const_pointer;       typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;       typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>        const_iterator;       typedef std::reverse_iterator<const_iterator> const_reverse_iterator;       typedef std::reverse_iterator<iterator> reverse_iterator;       static const size_type npos = static_cast<size_type>(-1);     private:       typedef const_iterator __const_iterator;       struct _Alloc_hider : allocator_type       {  _Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())  ;  pointer _M_p;       };       _Alloc_hider _M_dataplus;       size_type _M_string_length;       enum { _S_local_capacity = 15 / sizeof(_CharT) };       union       {  _CharT _M_local_buf[_S_local_capacity + 1];  size_type _M_allocated_capacity;       };       void       _M_data(pointer __p)       ;       void       _M_length(size_type __length)       ;       pointer       _M_data() const       ;       pointer       _M_local_data()       ;       const_pointer       _M_local_data() const       ;       void       _M_capacity(size_type __capacity)       ;       void       _M_set_length(size_type __n)       ;       bool       _M_is_local() const       ;       pointer       _M_create(size_type&, size_type);       void       _M_dispose()       ;       void       _M_destroy(size_type __size) throw()       ;       template<typename _InIterator>         void         _M_construct_aux(_InIterator __beg, _InIterator __end,     std::__false_type)  ;       template<typename _Integer>         void         _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)  ;       void       _M_construct_aux_2(size_type __req, _CharT __c)       ;       template<typename _InIterator>         void         _M_construct(_InIterator __beg, _InIterator __end)  ;       template<typename _InIterator>         void         _M_construct(_InIterator __beg, _InIterator __end,        std::input_iterator_tag);       template<typename _FwdIterator>         void         _M_construct(_FwdIterator __beg, _FwdIterator __end,        std::forward_iterator_tag);       void       _M_construct(size_type __req, _CharT __c);       allocator_type&       _M_get_allocator()       ;       const allocator_type&       _M_get_allocator() const       ;     private: 
# 258 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_string.h" 3
      size_type       _M_check(size_type __pos, const char* __s) const       ;       void       _M_check_length(size_type __n1, size_type __n2, const char* __s) const       ;       size_type       _M_limit(size_type __pos, size_type __off) const noexcept       {  const bool __testoff = __off < this->size() - __pos;  return __testoff ? __off : this->size() - __pos;       }       bool       _M_disjunct(const _CharT* __s) const noexcept       {  return (less<const _CharT*>()(__s, _M_data())   || less<const _CharT*>()(_M_data() + this->size(), __s));       }       static void       _S_copy(_CharT* __d, const _CharT* __s, size_type __n)       {  if (__n == 1)    traits_type::assign(*__d, *__s);  else    traits_type::copy(__d, __s, __n);       }       static void       _S_move(_CharT* __d, const _CharT* __s, size_type __n)       {  if (__n == 1)    traits_type::assign(*__d, *__s);  else    traits_type::move(__d, __s, __n);       }       static void       _S_assign(_CharT* __d, size_type __n, _CharT __c)       {  if (__n == 1)    traits_type::assign(*__d, __c);  else    traits_type::assign(__d, __n, __c);       }       template<class _Iterator>         static void         _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)         {    for (; __k1 != __k2; ++__k1, (void)++__p)      traits_type::assign(*__p, *__k1);  }       static void       _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept       { _S_copy_chars(__p, __k1.base(), __k2.base()); }       static void       _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)       noexcept       { _S_copy_chars(__p, __k1.base(), __k2.base()); }       static void       _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept       { _S_copy(__p, __k1, __k2 - __k1); }       static void       _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)       noexcept       { _S_copy(__p, __k1, __k2 - __k1); }       static int       _S_compare(size_type __n1, size_type __n2) noexcept       {  const difference_type __d = difference_type(__n1 - __n2);  if (__d > __gnu_cxx::__numeric_traits<int>::__max)    return __gnu_cxx::__numeric_traits<int>::__max;  else if (__d < __gnu_cxx::__numeric_traits<int>::__min)    return __gnu_cxx::__numeric_traits<int>::__min;  else    return int(__d);       }       void       _M_assign(const basic_string& __rcs);       void       _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,   size_type __len2);       void       _M_erase(size_type __pos, size_type __n);     public:       basic_string()       noexcept(is_nothrow_default_constructible<_Alloc>::value)       : _M_dataplus(_M_local_data())       { _M_set_length(0); }       explicit       basic_string(const _Alloc& __a) noexcept       : _M_dataplus(_M_local_data(), __a)       { _M_set_length(0); }       basic_string(const basic_string& __str)       : _M_dataplus(_M_local_data(),       _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))       { _M_construct(__str._M_data(), __str._M_data() + __str.length()); } 
# 410 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,      size_type __n = npos)       : _M_dataplus(_M_local_data())       {  const _CharT* __start = __str._M_data()    + __str._M_check(__pos, "basic_string::basic_string");  _M_construct(__start, __start + __str._M_limit(__pos, __n));       } 
# 426 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,      size_type __n, const _Alloc& __a)       : _M_dataplus(_M_local_data(), __a)       {  const _CharT* __start    = __str._M_data() + __str._M_check(__pos, "string::string");  _M_construct(__start, __start + __str._M_limit(__pos, __n));       } 
# 599 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_string.h" 3
      basic_string&       operator=(_CharT __c)       {  this->assign(1, __c);  return *this;       } 
# 617 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_string.h" 3
      basic_string&       operator=(basic_string&& __str)       noexcept(_Alloc_traits::_S_nothrow_move())       {  if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()      && !_Alloc_traits::_S_always_equal()      && _M_get_allocator() != __str._M_get_allocator())    {      _M_destroy(_M_allocated_capacity);      _M_data(_M_local_data());      _M_set_length(0);    }  std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());  if (!__str._M_is_local()      && (_Alloc_traits::_S_propagate_on_move_assign()        || _Alloc_traits::_S_always_equal()))    {      pointer __data = nullptr;      size_type __capacity;      if (!_M_is_local())        {   if (_Alloc_traits::_S_always_equal())     {       __data = _M_data();       __capacity = _M_allocated_capacity;     }   else     _M_destroy(_M_allocated_capacity);        }      _M_data(__str._M_data());      _M_length(__str.length());      _M_capacity(__str._M_allocated_capacity);      if (__data)        {   __str._M_data(__data);   __str._M_capacity(__capacity);        }      else        __str._M_data(__str._M_local_buf);    }  else      assign(__str);  __str.clear();  return *this;       }       basic_string&       operator=(initializer_list<_CharT> __l)       {  this->assign(__l.begin(), __l.size());  return *this;       }       iterator       begin() noexcept       { return iterator(_M_data()); }       const_iterator       begin() const noexcept       { return const_iterator(_M_data()); }       iterator       end() noexcept       { return iterator(_M_data() + this->size()); }       const_iterator       end() const noexcept       { return const_iterator(_M_data() + this->size()); }       reverse_iterator       rbegin() noexcept       { return reverse_iterator(this->end()); }       const_reverse_iterator       rbegin() const noexcept       { return const_reverse_iterator(this->end()); }       reverse_iterator       rend() noexcept       { return reverse_iterator(this->begin()); }       const_reverse_iterator       rend() const noexcept       { return const_reverse_iterator(this->begin()); }       const_iterator       cbegin() const noexcept       { return const_iterator(this->_M_data()); }       const_iterator       cend() const noexcept       { return const_iterator(this->_M_data() + this->size()); }       const_reverse_iterator       crbegin() const noexcept       { return const_reverse_iterator(this->end()); }       const_reverse_iterator       crend() const noexcept       { return const_reverse_iterator(this->begin()); }     public:       size_type       size() const noexcept       { return _M_string_length; }       size_type       length() const noexcept       { return _M_string_length; }       size_type       max_size() const noexcept       { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; } 
# 813 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_string.h" 3
      void       resize(size_type __n, _CharT __c); 
# 1976 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_string.h" 3
      const _CharT*       c_str() const noexcept       { return _M_data(); }       const _CharT*       data() const noexcept       { return _M_data(); }       allocator_type       get_allocator() const noexcept       { return _M_get_allocator(); } 
# 2009 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_string.h" 3
      size_type       find(const _CharT* __s, size_type __pos, size_type __n) const; 
# 2022 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_string.h" 3
      size_type       find(const basic_string& __str, size_type __pos = 0) const  noexcept       { return this->find(__str.data(), __pos, __str.size()); } 
# 2501 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_string.h" 3
      int       compare(size_type __pos, size_type __n1, const _CharT* __s) const; 
# 2528 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_string.h" 3
      int       compare(size_type __pos, size_type __n1, const _CharT* __s,        size_type __n2) const;   }; } 
# 4927 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>     basic_string<_CharT, _Traits, _Alloc>     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,        const basic_string<_CharT, _Traits, _Alloc>& __rhs)     ;   template<typename _CharT, typename _Traits, typename _Alloc>     basic_string<_CharT,_Traits,_Alloc>     operator+(const _CharT* __lhs,        const basic_string<_CharT,_Traits,_Alloc>& __rhs);   template<typename _CharT, typename _Traits, typename _Alloc>     basic_string<_CharT,_Traits,_Alloc>     operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);   template<typename _CharT, typename _Traits, typename _Alloc>      basic_string<_CharT, _Traits, _Alloc>     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,        const _CharT* __rhs)     ;   template<typename _CharT, typename _Traits, typename _Alloc>      basic_string<_CharT, _Traits, _Alloc>     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)     ;   template<typename _CharT, typename _Traits, typename _Alloc>      basic_string<_CharT, _Traits, _Alloc>     operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,        const basic_string<_CharT, _Traits, _Alloc>& __rhs)     ;   template<typename _CharT, typename _Traits, typename _Alloc>      basic_string<_CharT, _Traits, _Alloc>     operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,        basic_string<_CharT, _Traits, _Alloc>&& __rhs)     ;   template<typename _CharT, typename _Traits, typename _Alloc>      basic_string<_CharT, _Traits, _Alloc>     operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,        basic_string<_CharT, _Traits, _Alloc>&& __rhs)     ;   template<typename _CharT, typename _Traits, typename _Alloc>      basic_string<_CharT, _Traits, _Alloc>     operator+(const _CharT* __lhs,        basic_string<_CharT, _Traits, _Alloc>&& __rhs)     ;   template<typename _CharT, typename _Traits, typename _Alloc>      basic_string<_CharT, _Traits, _Alloc>     operator+(_CharT __lhs,        basic_string<_CharT, _Traits, _Alloc>&& __rhs)     ;   template<typename _CharT, typename _Traits, typename _Alloc>      basic_string<_CharT, _Traits, _Alloc>     operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,        const _CharT* __rhs)     ;   template<typename _CharT, typename _Traits, typename _Alloc>      basic_string<_CharT, _Traits, _Alloc>     operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,        _CharT __rhs)     ; 
# 5346 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_string.h" 3
  ; 
# 5363 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_string.h" 3
       ;        ;        ;       }
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ext/string_conversions.h" 1 3
# 33 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ext/string_conversions.h" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cerrno" 1 3
# 40 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cerrno" 3
# 1 "/usr/include/errno.h" 1 3 4
# 31 "/usr/include/errno.h" 3 4
extern "C" { 
# 1 "/usr/include/bits/errno.h" 1 3 4
# 54 "/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name; }
# 68 "/usr/include/errno.h" 3 4
typedef int error_t;
# 43 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cerrno" 2 3
# 45 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ext/string_conversions.h" 2 3
# 34 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/hash_bytes.h" 3
namespace std {      size_t   _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed); }
# 36 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/functional_hash.h" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) { 
# 49 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>     struct __hash_base     {       typedef _Result result_type;       typedef _Arg argument_type;     };   template<typename _Tp>     struct hash;   template<typename _Tp, bool = is_enum<_Tp>::value>     struct __hash_enum     {     private:              ~__hash_enum();     };   template<typename _Tp>     struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>     {       size_t       operator()(_Tp __val) const noexcept       {        using __type = typename underlying_type<_Tp>::type;        return hash<__type>{}(static_cast<__type>(__val));       }     };   template<typename _Tp>     struct hash : __hash_enum<_Tp>     { };   template<typename _Tp>     struct hash<_Tp*> : public __hash_base<size_t, _Tp*>     {       size_t       operator()(_Tp* __p) const noexcept       { return reinterpret_cast<size_t>(__p); }     }; 
# 108 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };   template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };   template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };   template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };   template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };   template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };   template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };   template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };   template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };   template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };   template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };   template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };   template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };   template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };   template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } }; 
# 171 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/functional_hash.h" 3
  struct _Hash_impl   {     static size_t     hash(const void* __ptr, size_t __clength,   size_t __seed = static_cast<size_t>(0xc70f6907UL))     ;     template<typename _Tp>       static size_t       hash(const _Tp& __val)       ;     template<typename _Tp>       static size_t       __hash_combine(const _Tp& __val, size_t __hash)       ;   };   struct _Fnv_hash_impl   {     static size_t     hash(const void* __ptr, size_t __clength,   size_t __seed = static_cast<size_t>(2166136261UL))     { return _Fnv_hash_bytes(__ptr, __clength, __seed); }     template<typename _Tp>       static size_t       hash(const _Tp& __val)       { return hash(&__val, sizeof(__val)); }     template<typename _Tp>       static size_t       __hash_combine(const _Tp& __val, size_t __hash)       { return hash(&__val, sizeof(__val), __hash); }   };   template<>     struct hash<float> : public __hash_base<size_t, float>     {       size_t       operator()(float __val) const noexcept       {  return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;       }     };   template<>     struct hash<double> : public __hash_base<size_t, double>     {       size_t       operator()(double __val) const noexcept       {  return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;       }     };   template<>     struct hash<long double>     : public __hash_base<size_t, long double>     {       __attribute__ ((__pure__)) size_t       operator()(long double __val) const noexcept;     };   template<typename _Hash>     struct __is_fast_hash : public std::true_type     { };   template<>     struct __is_fast_hash<hash<long double>> : public std::false_type     { }; }
# 5629 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_string.h" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) {   template<>     struct hash<string>     : public __hash_base<size_t, string>     {       size_t       operator()(const string& __s) const noexcept       { return std::_Hash_impl::hash(__s.data(), __s.length()); }     };   template<>     struct __is_fast_hash<hash<string>> : std::false_type     { };   template<>     struct hash<wstring>     : public __hash_base<size_t, wstring>     {       size_t       operator()(const wstring& __s) const noexcept       { return std::_Hash_impl::hash(__s.data(),                                      __s.length() * sizeof(wchar_t)); }     };   template<>     struct __is_fast_hash<hash<wstring>> : std::false_type     { };   template<>     struct hash<u16string>     : public __hash_base<size_t, u16string>     {       size_t       operator()(const u16string& __s) const noexcept       { return std::_Hash_impl::hash(__s.data(),                                      __s.length() * sizeof(char16_t)); }     };   template<>     struct __is_fast_hash<hash<u16string>> : std::false_type     { };   template<>     struct hash<u32string>     : public __hash_base<size_t, u32string>     {       size_t       operator()(const u32string& __s) const noexcept       { return std::_Hash_impl::hash(__s.data(),                                      __s.length() * sizeof(char32_t)); }     };   template<>     struct __is_fast_hash<hash<u32string>> : std::false_type     { }; 
  class locale   {   public:     typedef int category;     class facet;     class id;     class _Impl;     friend class facet;     friend class _Impl;     ;     template<typename _Facet>       friend const _Facet&       use_facet(const locale&);     template<typename _Cache>       friend struct __use_cache; 
# 98 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.h" 3
    static const category none = 0;     static const category ctype = 1L << 0;     static const category numeric = 1L << 1;     static const category collate = 1L << 2;     static const category time = 1L << 3;     static const category monetary = 1L << 4;     static const category messages = 1L << 5;     static const category all = (ctype | numeric | collate |         time | monetary | messages); 
# 117 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.h" 3
    locale() throw(); 
# 126 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.h" 3
# 298 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.h" 3
            private:     _Impl* _M_impl;     static _Impl* _S_classic;     static _Impl* _S_global;     static const char* const* const _S_categories; 
# 333 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };     static __gthread_once_t _S_once;                              static const id* const _S_twinned_facets[];   }; 
# 371 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.h" 3
  class locale::facet   {   private:     friend class locale;     friend class locale::_Impl;     mutable _Atomic_word _M_refcount;     static __c_locale _S_c_locale;     static const char _S_c_name[2];     static __gthread_once_t _S_once;        protected: 
# 402 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.h" 3
# 438 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.h" 3
            private:               class __shim;             }; 
# 482 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.h" 3
  class locale::id   {   private:     friend class locale;     friend class locale::_Impl;     template<typename _Facet>       friend const _Facet&       use_facet(const locale&);     ;     mutable size_t _M_index;     static _Atomic_word _S_refcount;             public:     id() ;        };   class locale::_Impl   {   public:     friend class locale;     friend class locale::facet;     ;     template<typename _Facet>       friend const _Facet&       use_facet(const locale&);     template<typename _Cache>       friend struct __use_cache;   private:     _Atomic_word _M_refcount;     const facet** _M_facets;     size_t _M_facets_size;     const facet** _M_caches;     char** _M_names;     static const locale::id* const _S_id_ctype[];     static const locale::id* const _S_id_numeric[];     static const locale::id* const _S_id_collate[];     static const locale::id* const _S_id_time[];     static const locale::id* const _S_id_monetary[];     static const locale::id* const _S_id_messages[];     static const locale::id* const* const _S_facet_categories[];                                                                            ;            ;                  }; 
# 640 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.h" 3
  template<typename _CharT>     class __cxx11:: collate : public locale::facet     {     public:       typedef _CharT char_type;       typedef basic_string<_CharT> string_type;     protected:       __c_locale _M_c_locale_collate;     public:       static locale::id id; 
# 667 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.h" 3
# 681 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.h" 3
# 698 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.h" 3
# 717 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.h" 3
# 731 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.h" 3
                       protected:        
# 760 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.h" 3
# 774 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.h" 3
# 787 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.h" 3
           };   template<typename _CharT>     locale::id collate<_CharT>::id;               template<typename _CharT>     class __cxx11:: collate_byname : public collate<_CharT>     {     public:       typedef _CharT char_type;       typedef basic_string<_CharT> string_type;                   protected:            }; }
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_classes.tcc" 1 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cerrno" 1 3
# 40 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cerrno" 3
# 1 "/usr/include/errno.h" 1 3 4
# 43 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cerrno" 2 3
# 35 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/x86_64-redhat-linux/bits/error_constants.h" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) {   enum class errc     {       address_family_not_supported = 97,       address_in_use = 98,       address_not_available = 99,       already_connected = 106,       argument_list_too_long = 7,       argument_out_of_domain = 33,       bad_address = 14,       bad_file_descriptor = 9,       bad_message = 74,       broken_pipe = 32,       connection_aborted = 103,       connection_already_in_progress = 114,       connection_refused = 111,       connection_reset = 104,       cross_device_link = 18,       destination_address_required = 89,       device_or_resource_busy = 16,       directory_not_empty = 39,       executable_format_error = 8,       file_exists = 17,       file_too_large = 27,       filename_too_long = 36,       function_not_supported = 38,       host_unreachable = 113,       identifier_removed = 43,       illegal_byte_sequence = 84,       inappropriate_io_control_operation = 25,       interrupted = 4,       invalid_argument = 22,       invalid_seek = 29,       io_error = 5,       is_a_directory = 21,       message_size = 90,       network_down = 100,       network_reset = 102,       network_unreachable = 101,       no_buffer_space = 105,       no_child_process = 10,       no_link = 67,       no_lock_available = 37,       no_message_available = 61,       no_message = 42,       no_protocol_option = 92,       no_space_on_device = 28,       no_stream_resources = 63,       no_such_device_or_address = 6,       no_such_device = 19,       no_such_file_or_directory = 2,       no_such_process = 3,       not_a_directory = 20,       not_a_socket = 88,       not_a_stream = 60,       not_connected = 107,       not_enough_memory = 12,       not_supported = 95,       operation_canceled = 125,       operation_in_progress = 115,       operation_not_permitted = 1,       operation_not_supported = 95,       operation_would_block = 11,       owner_dead = 130,       permission_denied = 13,       protocol_error = 71,       protocol_not_supported = 93,       read_only_file_system = 30,       resource_deadlock_would_occur = 35,       resource_unavailable_try_again = 11,       result_out_of_range = 34,       state_not_recoverable = 131,       stream_timeout = 62,       text_file_busy = 26,       timed_out = 110,       too_many_files_open_in_system = 23,       too_many_files_open = 24,       too_many_links = 31,       too_many_symbolic_link_levels = 40,       value_too_large = 75,       wrong_protocol_type = 91     }; }
# 40 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/system_error" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/stdexcept" 1 3
# 37 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/stdexcept" 3
namespace std __attribute__ ((__visibility__ ("default"))) {   struct __cow_string   {     union {       const char* _M_p;       char _M_bytes[sizeof(const char*)];     };                                           };   typedef basic_string<char> __sso_string; 
# 113 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/stdexcept" 3
  class logic_error : public exception   {     __cow_string _M_msg;   public:                                 };   class domain_error : public logic_error   {   public:                  };   class invalid_argument : public logic_error   {   public:                  };   class length_error : public logic_error   {   public:                  };   class out_of_range : public logic_error   {   public:                  };   class runtime_error : public exception   {     __cow_string _M_msg;   public:     explicit     runtime_error(const string& __arg) ;     explicit     runtime_error(const char*) ;     runtime_error(const runtime_error&) noexcept;     runtime_error& operator=(const runtime_error&) noexcept;     virtual ~runtime_error() noexcept;     virtual const char*     what() const noexcept;   };   class range_error : public runtime_error   {   public:     explicit range_error(const string& __arg) ;     explicit range_error(const char*) ;        };   class overflow_error : public runtime_error   {   public:                  };   class underflow_error : public runtime_error   {   public:                  }; }
# 42 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/system_error" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) {   class error_code;   class error_condition;   class system_error;   template<typename _Tp>     struct is_error_code_enum : public false_type { };   template<typename _Tp>     struct is_error_condition_enum : public false_type { };   template<>     struct is_error_condition_enum<errc>     : public true_type { };   inline namespace _V2 {   class error_category   {   public:     constexpr error_category() noexcept = default;               error_category& operator=(const error_category&) = delete;     virtual const char*     name() const noexcept = 0;   private:     __attribute ((__abi_tag__ ("cxx11")))     virtual __cow_string     _M_message(int) const;   public:     __attribute ((__abi_tag__ ("cxx11")))     virtual string     message(int) const = 0; 
# 102 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/system_error" 3
  public:     virtual error_condition     default_error_condition(int __i) const noexcept;     virtual bool     equivalent(int __i, const error_condition& __cond) const noexcept;     virtual bool     equivalent(const error_code& __code, int __i) const noexcept;     bool     operator<(const error_category& __other) const noexcept     { return less<const error_category*>()(this, &__other); }     bool     operator==(const error_category& __other) const noexcept     { return this == &__other; }     bool     operator!=(const error_category& __other) const noexcept     { return this != &__other; }   };   __attribute__ ((__const__)) const error_category& system_category() noexcept;   __attribute__ ((__const__)) const error_category& generic_category() noexcept;   }   error_code make_error_code(errc) noexcept;   template<typename _Tp>     struct hash;   struct error_code   {     error_code() noexcept     : _M_value(0), _M_cat(&system_category()) { }     error_code(int __v, const error_category& __cat) noexcept     : _M_value(__v), _M_cat(&__cat) { }     template<typename _ErrorCodeEnum, typename = typename       enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type>       error_code(_ErrorCodeEnum __e) noexcept       { *this = make_error_code(__e); }     void     assign(int __v, const error_category& __cat) noexcept     {       _M_value = __v;       _M_cat = &__cat;     }     void     clear() noexcept     { assign(0, system_category()); }     template<typename _ErrorCodeEnum>       typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value,     error_code&>::type       operator=(_ErrorCodeEnum __e) noexcept       { return *this = make_error_code(__e); }     int     value() const noexcept { return _M_value; }     const error_category&     category() const noexcept { return *_M_cat; }     error_condition     default_error_condition() const noexcept;     __attribute ((__abi_tag__ ("cxx11")))     string     message() const     ;     explicit operator bool() const noexcept     { return _M_value != 0; }   private:     friend class hash<error_code>;     int _M_value;     const error_category* _M_cat;   };   inline error_code   make_error_code(errc __e) noexcept   { return error_code(static_cast<int>(__e), generic_category()); }   inline bool   operator<(const error_code& __lhs, const error_code& __rhs) noexcept   {     return (__lhs.category() < __rhs.category()      || (__lhs.category() == __rhs.category()   && __lhs.value() < __rhs.value()));   }   template<typename _CharT, typename _Traits>     basic_ostream<_CharT, _Traits>&     operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)     { return (__os << __e.category().name() << ':' << __e.value()); }   error_condition make_error_condition(errc) noexcept;   struct error_condition   {     error_condition() noexcept     : _M_value(0), _M_cat(&generic_category()) { }     error_condition(int __v, const error_category& __cat) noexcept     : _M_value(__v), _M_cat(&__cat) { }     template<typename _ErrorConditionEnum, typename = typename   enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type>       error_condition(_ErrorConditionEnum __e) noexcept       { *this = make_error_condition(__e); }     void     assign(int __v, const error_category& __cat) noexcept     {       _M_value = __v;       _M_cat = &__cat;     }     template<typename _ErrorConditionEnum>       typename enable_if<is_error_condition_enum     <_ErrorConditionEnum>::value, error_condition&>::type       operator=(_ErrorConditionEnum __e) noexcept       { return *this = make_error_condition(__e); }     void     clear() noexcept     { assign(0, generic_category()); }     int     value() const noexcept { return _M_value; }     const error_category&     category() const noexcept { return *_M_cat; }     __attribute ((__abi_tag__ ("cxx11")))     string     message() const     { return category().message(value()); }     explicit operator bool() const noexcept     { return _M_value != 0; }   private:     int _M_value;     const error_category* _M_cat;   };   inline error_condition   make_error_condition(errc __e) noexcept   { return error_condition(static_cast<int>(__e), generic_category()); }   inline bool   operator<(const error_condition& __lhs,      const error_condition& __rhs) noexcept   {     return (__lhs.category() < __rhs.category()      || (__lhs.category() == __rhs.category()   && __lhs.value() < __rhs.value()));   }   inline bool   operator==(const error_code& __lhs, const error_code& __rhs) noexcept   { return (__lhs.category() == __rhs.category()      && __lhs.value() == __rhs.value()); }   inline bool   operator==(const error_code& __lhs, const error_condition& __rhs) noexcept   {     return (__lhs.category().equivalent(__lhs.value(), __rhs)      || __rhs.category().equivalent(__lhs, __rhs.value()));   }   inline bool   operator==(const error_condition& __lhs, const error_code& __rhs) noexcept   {     return (__rhs.category().equivalent(__rhs.value(), __lhs)      || __lhs.category().equivalent(__rhs, __lhs.value()));   }   inline bool   operator==(const error_condition& __lhs,       const error_condition& __rhs) noexcept   {     return (__lhs.category() == __rhs.category()      && __lhs.value() == __rhs.value());   }   inline bool   operator!=(const error_code& __lhs, const error_code& __rhs) noexcept   { return !(__lhs == __rhs); }   inline bool   operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept   { return !(__lhs == __rhs); }   inline bool   operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept   { return !(__lhs == __rhs); }   inline bool   operator!=(const error_condition& __lhs,       const error_condition& __rhs) noexcept   { return !(__lhs == __rhs); }   class system_error : public std::runtime_error   {   private:     error_code _M_code;   public:     system_error(error_code __ec = error_code())     : runtime_error(__ec.message()), _M_code(__ec) { }     system_error(error_code __ec, const string& __what)     : runtime_error(__what + ": " + __ec.message()), _M_code(__ec) { }     system_error(error_code __ec, const char* __what)     : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) { }     system_error(int __v, const error_category& __ecat, const char* __what)     : system_error(error_code(__v, __ecat), __what) { }     system_error(int __v, const error_category& __ecat)     : runtime_error(error_code(__v, __ecat).message()),       _M_code(__v, __ecat) { }     system_error(int __v, const error_category& __ecat, const string& __what)     : runtime_error(__what + ": " + error_code(__v, __ecat).message()),       _M_code(__v, __ecat) { }     virtual ~system_error() noexcept;     const error_code&     code() const noexcept { return _M_code; }   }; }
 namespace std __attribute__ ((__visibility__ ("default"))) {   template<>     struct hash<error_code>     : public __hash_base<size_t, error_code>     {       size_t       operator()(const error_code& __e) const noexcept       {  const size_t __tmp = std::_Hash_impl::hash(__e._M_value);  return std::_Hash_impl::__hash_combine(__e._M_cat, __tmp);       }     }; }
# 47 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ios_base.h" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) {   enum _Ios_Fmtflags     {       _S_boolalpha = 1L << 0,       _S_dec = 1L << 1,       _S_fixed = 1L << 2,       _S_hex = 1L << 3,       _S_internal = 1L << 4,       _S_left = 1L << 5,       _S_oct = 1L << 6,       _S_right = 1L << 7,       _S_scientific = 1L << 8,       _S_showbase = 1L << 9,       _S_showpoint = 1L << 10,       _S_showpos = 1L << 11,       _S_skipws = 1L << 12,       _S_unitbuf = 1L << 13,       _S_uppercase = 1L << 14,       _S_adjustfield = _S_left | _S_right | _S_internal,       _S_basefield = _S_dec | _S_oct | _S_hex,       _S_floatfield = _S_scientific | _S_fixed,       _S_ios_fmtflags_end = 1L << 16,       _S_ios_fmtflags_max = 2147483647,       _S_ios_fmtflags_min = ~2147483647     };   inline constexpr _Ios_Fmtflags   operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)   { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }   inline constexpr _Ios_Fmtflags   operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)   { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }   inline constexpr _Ios_Fmtflags   operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)   { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }   inline constexpr _Ios_Fmtflags   operator~(_Ios_Fmtflags __a)   { return _Ios_Fmtflags(~static_cast<int>(__a)); }   inline const _Ios_Fmtflags&   operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)   { return __a = __a | __b; }   inline const _Ios_Fmtflags&   operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)   { return __a = __a & __b; }   inline const _Ios_Fmtflags&   operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)   { return __a = __a ^ __b; }   enum _Ios_Openmode     {       _S_app = 1L << 0,       _S_ate = 1L << 1,       _S_bin = 1L << 2,       _S_in = 1L << 3,       _S_out = 1L << 4,       _S_trunc = 1L << 5,       _S_ios_openmode_end = 1L << 16,       _S_ios_openmode_max = 2147483647,       _S_ios_openmode_min = ~2147483647     };   inline constexpr _Ios_Openmode   operator&(_Ios_Openmode __a, _Ios_Openmode __b)   { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }   inline constexpr _Ios_Openmode   operator|(_Ios_Openmode __a, _Ios_Openmode __b)   { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }   inline constexpr _Ios_Openmode   operator^(_Ios_Openmode __a, _Ios_Openmode __b)   { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }   inline constexpr _Ios_Openmode   operator~(_Ios_Openmode __a)   { return _Ios_Openmode(~static_cast<int>(__a)); }   inline const _Ios_Openmode&   operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)   { return __a = __a | __b; }   inline const _Ios_Openmode&   operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)   { return __a = __a & __b; }   inline const _Ios_Openmode&   operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)   { return __a = __a ^ __b; }   enum _Ios_Iostate     {       _S_goodbit = 0,       _S_badbit = 1L << 0,       _S_eofbit = 1L << 1,       _S_failbit = 1L << 2,       _S_ios_iostate_end = 1L << 16,       _S_ios_iostate_max = 2147483647,       _S_ios_iostate_min = ~2147483647     };   inline constexpr _Ios_Iostate   operator&(_Ios_Iostate __a, _Ios_Iostate __b)   { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }   inline constexpr _Ios_Iostate   operator|(_Ios_Iostate __a, _Ios_Iostate __b)   { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }   inline constexpr _Ios_Iostate   operator^(_Ios_Iostate __a, _Ios_Iostate __b)   { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }   inline constexpr _Ios_Iostate   operator~(_Ios_Iostate __a)   { return _Ios_Iostate(~static_cast<int>(__a)); }   inline const _Ios_Iostate&   operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)   { return __a = __a | __b; }   inline const _Ios_Iostate&   operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)   { return __a = __a & __b; }   inline const _Ios_Iostate&   operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)   { return __a = __a ^ __b; }   enum _Ios_Seekdir     {       _S_beg = 0,       _S_cur = 1,       _S_end = 2,       _S_ios_seekdir_end = 1L << 16     };   enum class io_errc { stream = 1 };   template <> struct is_error_code_enum<io_errc> : public true_type { };   const error_category& iostream_category() noexcept;   inline error_code   make_error_code(io_errc e) noexcept   { return error_code(static_cast<int>(e), iostream_category()); }   inline error_condition   make_error_condition(io_errc e) noexcept   { return error_condition(static_cast<int>(e), iostream_category()); } 
# 228 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ios_base.h" 3
  class ios_base   { 
# 246 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ios_base.h" 3
  public: 
# 255 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ios_base.h" 3
    class __attribute ((__abi_tag__ ("cxx11"))) failure : public system_error     {     public:       explicit       failure(const string& __str);       explicit       failure(const string&, const error_code&);       explicit       failure(const char*, const error_code& = io_errc::stream);       virtual       ~failure() throw();       virtual const char*       what() const throw();     }; 
# 323 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;     static const fmtflags boolalpha = _S_boolalpha;     static const fmtflags dec = _S_dec;     static const fmtflags fixed = _S_fixed;     static const fmtflags hex = _S_hex;     static const fmtflags internal = _S_internal;     static const fmtflags left = _S_left;     static const fmtflags oct = _S_oct;     static const fmtflags right = _S_right;     static const fmtflags scientific = _S_scientific;     static const fmtflags showbase = _S_showbase;     static const fmtflags showpoint = _S_showpoint;     static const fmtflags showpos = _S_showpos;     static const fmtflags skipws = _S_skipws;     static const fmtflags unitbuf = _S_unitbuf;     static const fmtflags uppercase = _S_uppercase;     static const fmtflags adjustfield = _S_adjustfield;     static const fmtflags basefield = _S_basefield;     static const fmtflags floatfield = _S_floatfield; 
# 398 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;     static const iostate badbit = _S_badbit;     static const iostate eofbit = _S_eofbit;     static const iostate failbit = _S_failbit;     static const iostate goodbit = _S_goodbit; 
# 429 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;     static const openmode app = _S_app;     static const openmode ate = _S_ate;     static const openmode binary = _S_bin;     static const openmode in = _S_in;     static const openmode out = _S_out;     static const openmode trunc = _S_trunc; 
# 461 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;     static const seekdir beg = _S_beg;     static const seekdir cur = _S_cur;     static const seekdir end = _S_end;     typedef int io_state;     typedef int open_mode;     typedef int seek_dir;     typedef std::streampos streampos;     typedef std::streamoff streamoff; 
# 487 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ios_base.h" 3
    enum event     {       erase_event,       imbue_event,       copyfmt_event     }; 
# 504 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i); 
# 516 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ios_base.h" 3
    void     register_callback(event_callback __fn, int __index);   protected:     streamsize _M_precision;     streamsize _M_width;     fmtflags _M_flags;     iostate _M_exception;     iostate _M_streambuf_state;     struct _Callback_list     {       _Callback_list* _M_next;       ios_base::event_callback _M_fn;       int _M_index;       _Atomic_word _M_refcount;       _Callback_list(ios_base::event_callback __fn, int __index,        _Callback_list* __cb)       : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }       void       _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }       int       _M_remove_reference()       {                                                              ;         int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);         if (__res == 0)           {                                                                 ;           }         return __res;       }     };      _Callback_list* _M_callbacks;     void     _M_call_callbacks(event __ev) throw();     void     _M_dispose_callbacks(void) throw();     struct _Words     {       void* _M_pword;       long _M_iword;       _Words() : _M_pword(0), _M_iword(0) { }     };     _Words _M_word_zero;     enum { _S_local_word_size = 8 };     _Words _M_local_word[_S_local_word_size];     int _M_word_size;     _Words* _M_word;     _Words&     _M_grow_words(int __index, bool __iword);     locale _M_ios_locale;     void     _M_init() throw();   public:     class Init     {       friend class ios_base;     public:       Init();       ~Init();     private:       static _Atomic_word _S_refcount;       static bool _S_synced_with_stdio;     };     fmtflags     flags() const     { return _M_flags; } 
# 629 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ios_base.h" 3
    fmtflags     flags(fmtflags __fmtfl)     {       fmtflags __old = _M_flags;       _M_flags = __fmtfl;       return __old;     } 
# 645 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ios_base.h" 3
    void*&     pword(int __ix)     {       _Words& __word = (__ix < _M_word_size)    ? _M_word[__ix] : _M_grow_words(__ix, false);       return __word._M_pword;     } 
# 846 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ios_base.h" 3
    virtual ~ios_base();   protected:     ios_base() throw (); 
# 860 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ios_base.h" 3
  public:     ios_base(const ios_base&) = delete;     ios_base&     operator=(const ios_base&) = delete;   protected:     void     _M_move(ios_base&) noexcept;     void     _M_swap(ios_base& __rhs) noexcept;   };    ios_base&   boolalpha(ios_base& __base)   ;    ios_base&   noboolalpha(ios_base& __base)   ;    ios_base&   showbase(ios_base& __base)   ;                                                                            ios_base&   scientific(ios_base& __base)   ;    ios_base&   hexfloat(ios_base& __base)   ;    ios_base&   defaultfloat(ios_base& __base)   ; }
# 43 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ios" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/streambuf" 1 3
# 37 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/streambuf" 3
namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _CharT, typename _Traits>     streamsize     __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,      basic_streambuf<_CharT, _Traits>*, bool&); 
# 119 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/streambuf" 3
  template<typename _CharT, typename _Traits>     class basic_streambuf     {     public:       typedef _CharT char_type;       typedef _Traits traits_type;       typedef typename traits_type::int_type int_type;       typedef typename traits_type::pos_type pos_type;       typedef typename traits_type::off_type off_type;       typedef basic_streambuf<char_type, traits_type> __streambuf_type;       friend class basic_ios<char_type, traits_type>;       friend class basic_istream<char_type, traits_type>;       friend class basic_ostream<char_type, traits_type>;       friend class istreambuf_iterator<char_type, traits_type>;       friend class ostreambuf_iterator<char_type, traits_type>;       friend streamsize       __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);       template<bool _IsMove, typename _CharT2>         friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,             _CharT2*>::__type         __copy_move_a2(istreambuf_iterator<_CharT2>,          istreambuf_iterator<_CharT2>, _CharT2*);       ;       ;       ;       ;     protected:       char_type* _M_in_beg;       char_type* _M_in_cur;       char_type* _M_in_end;       char_type* _M_out_beg;       char_type* _M_out_cur;       char_type* _M_out_end;       locale _M_buf_locale;   public:        
# 208 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/streambuf" 3
# 782 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/streambuf" 3
                         protected:                          };         template<>     streamsize     __copy_streambufs_eof(basic_streambuf<char>* __sbin,      basic_streambuf<char>* __sbout, bool& __ineof);   template<>     streamsize     __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,      basic_streambuf<wchar_t>* __sbout, bool& __ineof); }
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/streambuf.tcc" 1 3
# 38 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/streambuf.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {         template<typename _CharT, typename _Traits>     streamsize     __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,      basic_streambuf<_CharT, _Traits>* __sbout,      bool& __ineof)     ;        ;   extern template class basic_streambuf<char>;;   extern template     streamsize     __copy_streambufs_eof(basic_streambuf<char>*,      basic_streambuf<char>*, bool&);   extern template class basic_streambuf<wchar_t>;;   extern template     streamsize     __copy_streambufs_eof(basic_streambuf<wchar_t>*,      basic_streambuf<wchar_t>*, bool&); }
# 851 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/streambuf" 2 3
# 52 "/usr/include/wctype.h" 3 4
typedef unsigned long int wctype_t;
# 71 "/usr/include/wctype.h" 3 4
enum {   __ISwupper = 0,   __ISwlower = 1,   __ISwalpha = 2,   __ISwdigit = 3,   __ISwxdigit = 4,   __ISwspace = 5,   __ISwprint = 6,   __ISwgraph = 7,   __ISwblank = 8,   __ISwcntrl = 9,   __ISwpunct = 10,   __ISwalnum = 11,   _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),   _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),   _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),   _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),   _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),   _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),   _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),   _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),   _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),   _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),   _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),   _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24)))) };
 extern "C" { 
# 111 "/usr/include/wctype.h" 3 4
; ; ; ; ; ; ; ; ; ; ; ; 
# 171 "/usr/include/wctype.h" 3 4
; ; 
# 186 "/usr/include/wctype.h" 3 4
typedef const __int32_t *wctrans_t; ; ; }
# 213 "/usr/include/wctype.h" 3 4
namespace std __attribute__ ((__visibility__ ("default"))) {   struct ctype_base   {     typedef const int* __to_type;     typedef unsigned short mask;     static const mask upper = _ISupper;     static const mask lower = _ISlower;     static const mask alpha = _ISalpha;     static const mask digit = _ISdigit;     static const mask xdigit = _ISxdigit;     static const mask space = _ISspace;     static const mask print = _ISprint;     static const mask graph = _ISalpha | _ISdigit | _ISpunct;     static const mask cntrl = _IScntrl;     static const mask punct = _ISpunct;     static const mask alnum = _ISalpha | _ISdigit;     static const mask blank = _ISblank;   }; }
# 42 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 2 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/streambuf_iterator.h" 1 3
# 34 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/streambuf_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) { 
# 49 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/streambuf_iterator.h" 3
  template<typename _CharT>     class __ctype_abstract_base : public locale::facet, public ctype_base     {     public:       typedef _CharT char_type; 
# 168 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
# 185 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
# 201 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
# 217 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
# 231 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
# 563 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
# 588 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
           }; 
# 611 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
  template<typename _CharT>     class ctype : public __ctype_abstract_base<_CharT>     {     public:       typedef _CharT char_type;       typedef typename __ctype_abstract_base<_CharT>::mask mask;       static locale::id id;           protected:                                                                                                };   template<typename _CharT>     locale::id ctype<_CharT>::id; 
# 680 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
  template<>     class ctype<char> : public locale::facet, public ctype_base     {     public:       typedef char char_type;     protected:       __c_locale _M_c_locale_ctype;       bool _M_del;       __to_type _M_toupper;       __to_type _M_tolower;       const mask* _M_table;       mutable char _M_widen_ok;       mutable char _M_widen[1 + static_cast<unsigned char>(-1)];       mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];       mutable char _M_narrow_ok;     public:       static locale::id id;       static const size_t table_size = 1 + static_cast<unsigned char>(-1); 
# 717 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
# 730 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
# 743 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
# 758 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
# 772 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
           private:                   }; 
# 1181 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
  template<>     class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>     {     public:       typedef wchar_t char_type;       typedef wctype_t __wmask_type;     protected:       __c_locale _M_c_locale_ctype;       bool _M_narrow_ok;       char _M_narrow[128];       wint_t _M_widen[1 + static_cast<unsigned char>(-1)];       mask _M_bit[16];       __wmask_type _M_wmask[16];     public:       static locale::id id; 
# 1214 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
# 1225 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
           protected:               
                  };   template<typename _CharT>     class ctype_byname : public ctype<_CharT>     {     public:       typedef typename ctype<_CharT>::mask mask;                   protected:       ;     };   template<>     class ctype_byname<char> : public ctype<char>     {     public:                   protected:            };   template<>     class ctype_byname<wchar_t> : public ctype<wchar_t>     {     public:                   protected:            }; }
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/x86_64-redhat-linux/bits/ctype_inline.h" 1 3
# 37 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/x86_64-redhat-linux/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) {             }
# 1535 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) {   class __num_base   {   public:     enum       {  _S_ominus,  _S_oplus,  _S_ox,  _S_oX,  _S_odigits,  _S_odigits_end = _S_odigits + 16,  _S_oudigits = _S_odigits_end,  _S_oudigits_end = _S_oudigits + 16,  _S_oe = _S_odigits + 14,  _S_oE = _S_oudigits + 14,  _S_oend = _S_oudigits_end       };     static const char* _S_atoms_out;     static const char* _S_atoms_in;     enum     {       _S_iminus,       _S_iplus,       _S_ix,       _S_iX,       _S_izero,       _S_ie = _S_izero + 14,       _S_iE = _S_izero + 20,       _S_iend = 26     };        };   template<typename _CharT>     struct __numpunct_cache : public locale::facet     {       const char* _M_grouping;       size_t _M_grouping_size;       bool _M_use_grouping;       const _CharT* _M_truename;       size_t _M_truename_size;       const _CharT* _M_falsename;       size_t _M_falsename_size;       _CharT _M_decimal_point;       _CharT _M_thousands_sep;       _CharT _M_atoms_out[__num_base::_S_oend];       _CharT _M_atoms_in[__num_base::_S_iend];       bool _M_allocated;                          private:                   };    namespace __cxx11 { 
# 1665 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
  template<typename _CharT>     class numpunct : public locale::facet     {     public:       typedef _CharT char_type;       typedef basic_string<_CharT> string_type;       typedef __numpunct_cache<_CharT> __cache_type;     protected:       __cache_type* _M_data;     public:       static locale::id id;        
# 1703 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
# 1717 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
# 1731 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
# 1744 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
# 1843 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
# 1856 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
# 1869 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
                  };   template<typename _CharT>     locale::id numpunct<_CharT>::id;               template<typename _CharT>     class numpunct_byname : public numpunct<_CharT>     {     public:       typedef _CharT char_type;       typedef basic_string<_CharT> string_type;                   protected:            }; } 
# 1947 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>     class num_get : public locale::facet     {     public:       typedef _CharT char_type;       typedef _InIter iter_type;       static locale::id id; 
# 2207 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
# 2270 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
    };   template<typename _CharT, typename _InIter>     locale::id num_get<_CharT, _InIter>::id; 
# 2288 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>     class num_put : public locale::facet     {     public:       typedef _CharT char_type;       typedef _OutIter iter_type;       static locale::id id; 
# 2309 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
                                                            };   template <typename _CharT, typename _OutIter>     locale::id num_put<_CharT, _OutIter>::id; 
# 2563 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 3
  template<typename _CharT>      bool     isspace(_CharT __c, const locale& __loc)     ;   template<typename _CharT>      bool     isprint(_CharT __c, const locale& __loc)     ;   template<typename _CharT>      bool     iscntrl(_CharT __c, const locale& __loc)     ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ;        ; }
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.tcc" 1 3
# 34 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {   template<typename _Facet>     struct __use_cache     {            };   template<typename _CharT>     struct __use_cache<__numpunct_cache<_CharT> >     {            };    
          ;   extern template class __cxx11:: numpunct<char>;   extern template class __cxx11:: numpunct_byname<char>;   extern template class num_get<char>;   extern template class num_put<char>;   extern template class ctype_byname<char>;   extern template     const ctype<char>&     use_facet<ctype<char> >(const locale&);   extern template     const numpunct<char>&     use_facet<numpunct<char> >(const locale&);   extern template     const num_put<char>&     use_facet<num_put<char> >(const locale&);   extern template     const num_get<char>&     use_facet<num_get<char> >(const locale&);;;;;   extern template class __cxx11:: numpunct<wchar_t>;   extern template class __cxx11:: numpunct_byname<wchar_t>;   extern template class num_get<wchar_t>;   extern template class num_put<wchar_t>;   extern template class ctype_byname<wchar_t>;   extern template     const ctype<wchar_t>&     use_facet<ctype<wchar_t> >(const locale&);   extern template     const numpunct<wchar_t>&     use_facet<numpunct<wchar_t> >(const locale&);   extern template     const num_put<wchar_t>&     use_facet<num_put<wchar_t> >(const locale&);   extern template     const num_get<wchar_t>&     use_facet<num_get<wchar_t> >(const locale&);;;;; }
# 2652 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/locale_facets.h" 2 3
# 38 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_ios.h" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) {        ; 
# 66 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>     class basic_ios : public ios_base     {     public:       typedef _CharT char_type;       typedef typename _Traits::int_type int_type;       typedef typename _Traits::pos_type pos_type;       typedef typename _Traits::off_type off_type;       typedef _Traits traits_type;       typedef ctype<_CharT> __ctype_type;       typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >            __num_put_type;       typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >            __num_get_type;     protected:       basic_ostream<_CharT, _Traits>* _M_tie;       mutable char_type _M_fill;       mutable bool _M_fill_init;       basic_streambuf<_CharT, _Traits>* _M_streambuf;       const __ctype_type* _M_ctype;       const __num_put_type* _M_num_put;       const __num_get_type* _M_num_get;     public: 
# 429 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_ios.h" 3
# 448 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_ios.h" 3
           protected:                                          void       move(basic_ios&& __rhs)       ;       void       swap(basic_ios& __rhs) noexcept       {  ios_base::_M_swap(__rhs);  _M_cache_locale(_M_ios_locale);  __rhs._M_cache_locale(__rhs._M_ios_locale);  std::swap(_M_tie, __rhs._M_tie);  std::swap(_M_fill, __rhs._M_fill);  std::swap(_M_fill_init, __rhs._M_fill_init);       }       void       set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)       { _M_streambuf = __sb; }       void       _M_cache_locale(const locale& __loc);     }; }
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_ios.tcc" 1 3
# 34 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_ios.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {                     extern template class basic_ios<char>;   extern template class basic_ios<wchar_t>; }
# 517 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/basic_ios.h" 2 3
# 45 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ios" 2 3
# 39 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ostream" 2 3
namespace std __attribute__ ((__visibility__ ("default"))) { 
# 57 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ostream" 3
  template<typename _CharT, typename _Traits>     class basic_ostream : virtual public basic_ios<_CharT, _Traits>     {     public:       typedef _CharT char_type;       typedef typename _Traits::int_type int_type;       typedef typename _Traits::pos_type pos_type;       typedef typename _Traits::off_type off_type;       typedef _Traits traits_type;       typedef basic_streambuf<_CharT, _Traits> __streambuf_type;       typedef basic_ios<_CharT, _Traits> __ios_type;       typedef basic_ostream<_CharT, _Traits> __ostream_type;       typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >              __num_put_type;       typedef ctype<_CharT> __ctype_type; 
# 454 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ostream" 3
# 473 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ostream" 3
           }; 
# 495 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ostream" 3
       ;        ;        ;        ;        ; 
# 537 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ostream" 3
       ;   ;        ;        ;        ; 
# 588 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ostream" 3
       ; 
# 600 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ostream" 3
  template<typename _CharT, typename _Traits>      basic_ostream<_CharT, _Traits>&     ends(basic_ostream<_CharT, _Traits>& __os)     ;   template<typename _CharT, typename _Traits>      basic_ostream<_CharT, _Traits>&     flush(basic_ostream<_CharT, _Traits>& __os)     ; 
# 626 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ostream" 3
  template<typename _CharT, typename _Traits, typename _Tp>      basic_ostream<_CharT, _Traits>&     operator<<(basic_ostream<_CharT, _Traits>&& __os, const _Tp& __x)     ; }
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ostream.tcc" 1 3
# 38 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/ostream.tcc" 3
namespace std __attribute__ ((__visibility__ ("default"))) {                                         ;   extern template class basic_ostream<char>;;   extern template ostream& ends(ostream&);   extern template ostream& flush(ostream&);;;;;;;;;;;;;;;   extern template class basic_ostream<wchar_t>;;   extern template wostream& ends(wostream&);   extern template wostream& flush(wostream&);;;;;;;;;;;;; }
# 639 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/ostream" 2 3
# 13 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TimeStamp.h" 2
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/FloatingPoint.h" 1
# 15 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/FloatingPoint.h"
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/MathAlgorithms.h" 1
# 15 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/MathAlgorithms.h"
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cmath" 1 3
# 40 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/cmath" 3
# 1 "/usr/include/math.h" 1 3 4
# 28 "/usr/include/math.h" 3 4
extern "C" { 
# 1 "/usr/include/bits/math-vector.h" 1 3 4
# 25 "/usr/include/bits/math-vector.h" 3 4
# 1 "/usr/include/bits/libm-simd-decl-stubs.h" 1 3 4
# 433 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/FloatingPoint.h"
 ; 
# 454 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/FloatingPoint.h"
 ; 
# 473 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/FloatingPoint.h"
 }
# 16 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TimeStamp.h" 2
namespace IPC { template<typename T> struct ParamTraits; }
 namespace mozilla { typedef uint64_t TimeStampValue; class TimeStamp; class BaseTimeDurationPlatformUtils { public:             }; 
# 62 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TimeStamp.h"
template <typename ValueCalculator> class BaseTimeDuration { public:   constexpr BaseTimeDuration() : mValue(0) {}   struct _SomethingVeryRandomHere;                       ;      ;                                              private:       public:                              ;      ;      ;      ;      ;      ;             
# 303 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TimeStamp.h"
# 467 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TimeStamp.h"
# 482 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TimeStamp.h"
                                             private:   friend struct IPC::ParamTraits<mozilla::TimeStamp>;                       
# 610 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TimeStamp.h"
# 625 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/TimeStamp.h"
  TimeStampValue mValue; }; }
# 19 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/AllocPolicy.h" 2
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/stdlib.h" 1 3
# 20 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/AllocPolicy.h" 2
namespace mozilla { 
# 71 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/AllocPolicy.h"
class MallocAllocPolicy { public:      ;      ;      ;      ;      ;      ;          }; }
# 14 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Vector.h" 2
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/ReentrancyGuard.h" 1
# 16 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/ReentrancyGuard.h"
namespace mozilla { class ReentrancyGuard {   mozilla::detail::GuardObjectNotificationReceiver _mCheckNotUsedAsTemporary;   bool& mEntered; public:       ;    private:       }; }
# 22 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Vector.h" 2
# 33 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Vector.h"
namespace mozilla { template<typename T, size_t N, class AllocPolicy> class Vector; namespace detail {  ; template<typename T, size_t N, class AP, bool IsPod> struct VectorImpl {      ;            ;      ;      ;    }; template<typename T, size_t N, class AP> struct VectorImpl<T, N, AP, true> {      ;            ;      ;          }; struct VectorTesting; } 
# 280 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Vector.h"
template<typename T,          size_t MinInlineCapacity = 0,          class AllocPolicy = MallocAllocPolicy> class Vector final : private AllocPolicy {   static const bool kElemIsPod = IsPod<T>::value;   typedef detail::VectorImpl<T, MinInlineCapacity, AllocPolicy, kElemIsPod> Impl;   friend struct detail::VectorImpl<T, MinInlineCapacity, AllocPolicy, kElemIsPod>;   friend struct detail::VectorTesting;          
# 305 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Vector.h"
  static constexpr size_t kMaxInlineBytes =     1024 - (sizeof(AllocPolicy) + sizeof(T*) + sizeof(size_t) + sizeof(size_t)); 
# 317 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Vector.h"
  ;      ;   ;      ;   ;      ;         ;      ;      ;       
# 749 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Vector.h"
# 767 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Vector.h"
# 777 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Vector.h"
# 794 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Vector.h"
  ;                private:       }; 
# 838 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Vector.h"
                                          }
# 12 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/GCAPI.h" 2
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/HeapAPI.h" 1
# 15 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/HeapAPI.h"
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/Utility.h" 1
# 11 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/Utility.h"
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Atomics.h" 1
# 49 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Atomics.h"
namespace mozilla { 
# 81 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Atomics.h"
enum MemoryOrdering { 
# 111 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Atomics.h"
  Relaxed, 
# 133 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Atomics.h"
  ReleaseAcquire, 
# 162 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Atomics.h"
  SequentiallyConsistent, }; }
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/atomic" 1 3
# 36 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/atomic" 3
# 1 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/atomic_base.h" 1 3
# 34 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/atomic_base.h" 3
# 43 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/atomic_base.h" 3
namespace std __attribute__ ((__visibility__ ("default"))) { 
# 55 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/atomic_base.h" 3
  typedef enum memory_order     {       memory_order_relaxed,       memory_order_consume,       memory_order_acquire,       memory_order_release,       memory_order_acq_rel,       memory_order_seq_cst     } memory_order;   enum __memory_order_modifier     {       __memory_order_mask = 0x0ffff,       __memory_order_modifier_mask = 0xffff0000,       __memory_order_hle_acquire = 0x10000,       __memory_order_hle_release = 0x20000     };   constexpr memory_order   operator|(memory_order __m, __memory_order_modifier __mod)   {     return memory_order(__m | int(__mod));   }   constexpr memory_order   operator&(memory_order __m, __memory_order_modifier __mod)   {     return memory_order(__m & int(__mod));   }   constexpr memory_order   __cmpexch_failure_order2(memory_order __m) noexcept   {     return __m == memory_order_acq_rel ? memory_order_acquire       : __m == memory_order_release ? memory_order_relaxed : __m;   }   constexpr memory_order   __cmpexch_failure_order(memory_order __m) noexcept   {     return memory_order(__cmpexch_failure_order2(__m & __memory_order_mask)       | (__m & __memory_order_modifier_mask));   }   inline __attribute__((__always_inline__)) void   atomic_thread_fence(memory_order __m) noexcept   { __atomic_thread_fence(__m); }   inline __attribute__((__always_inline__)) void   atomic_signal_fence(memory_order __m) noexcept   { __atomic_signal_fence(__m); }   template<typename _Tp>     inline _Tp     kill_dependency(_Tp __y) noexcept     {       _Tp __ret(__y);       return __ret;     }   template<typename _IntTp>     struct __atomic_base;   template<typename _Tp>     struct atomic;   template<typename _Tp>     struct atomic<_Tp*>;     typedef bool __atomic_flag_data_type; 
# 148 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/atomic_base.h" 3
  extern "C" {   struct __atomic_flag_base   {     __atomic_flag_data_type _M_i;   };   }   struct atomic_flag : public __atomic_flag_base   {                              constexpr atomic_flag(bool __i) noexcept       : __atomic_flag_base{ _S_init(__i) }     { }     inline __attribute__((__always_inline__)) bool     test_and_set(memory_order __m = memory_order_seq_cst) noexcept     {       return __atomic_test_and_set (&_M_i, __m);     }     inline __attribute__((__always_inline__)) bool     test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept     {       return __atomic_test_and_set (&_M_i, __m);     }     inline __attribute__((__always_inline__)) void     clear(memory_order __m = memory_order_seq_cst) noexcept     {       memory_order __b = __m & __memory_order_mask;                                                    ;                                                    ;                                                    ;       __atomic_clear (&_M_i, __m);     }     inline __attribute__((__always_inline__)) void     clear(memory_order __m = memory_order_seq_cst) volatile noexcept     {       memory_order __b = __m & __memory_order_mask;                                                    ;                                                    ;                                                    ;       __atomic_clear (&_M_i, __m);     }   private:     static constexpr __atomic_flag_data_type     _S_init(bool __i)     { return __i ? 1 : 0; }   }; 
# 237 "/usr/lib/gcc/x86_64-redhat-linux/6.3.1/../../../../include/c++/6.3.1/bits/atomic_base.h" 3
  template<typename _ITp>     struct __atomic_base     {     private:       typedef _ITp __int_type;       static constexpr int _S_alignment =  sizeof(_ITp) > alignof(_ITp) ? sizeof(_ITp) : alignof(_ITp);       alignas(_S_alignment) __int_type _M_i;     public:                                          constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }       operator __int_type() const noexcept       { return load(); }       operator __int_type() const volatile noexcept       { return load(); }       __int_type       operator=(__int_type __i) noexcept       {  store(__i);  return __i;       }       __int_type       operator=(__int_type __i) volatile noexcept       {  store(__i);  return __i;       }       __int_type       operator++(int) noexcept       { return fetch_add(1); }       __int_type       operator++(int) volatile noexcept       { return fetch_add(1); }       __int_type       operator--(int) noexcept       { return fetch_sub(1); }       __int_type       operator--(int) volatile noexcept       { return fetch_sub(1); }       __int_type       operator++() noexcept       { return __atomic_add_fetch(&_M_i, 1, memory_order_seq_cst); }       __int_type       operator++() volatile noexcept       { return __atomic_add_fetch(&_M_i, 1, memory_order_seq_cst); }       __int_type       operator--() noexcept       { return __atomic_sub_fetch(&_M_i, 1, memory_order_seq_cst); }       __int_type       operator--() volatile noexcept       { return __atomic_sub_fetch(&_M_i, 1, memory_order_seq_cst); }       __int_type       operator+=(__int_type __i) noexcept       { return __atomic_add_fetch(&_M_i, __i, memory_order_seq_cst); }       __int_type       operator+=(__int_type __i) volatile noexcept       { return __atomic_add_fetch(&_M_i, __i, memory_order_seq_cst); }       __int_type       operator-=(__int_type __i) noexcept       { return __atomic_sub_fetch(&_M_i, __i, memory_order_seq_cst); }       __int_type       operator-=(__int_type __i) volatile noexcept       { return __atomic_sub_fetch(&_M_i, __i, memory_order_seq_cst); }       __int_type       operator&=(__int_type __i) noexcept       { return __atomic_and_fetch(&_M_i, __i, memory_order_seq_cst); }       __int_type       operator&=(__int_type __i) volatile noexcept       { return __atomic_and_fetch(&_M_i, __i, memory_order_seq_cst); }       __int_type       operator|=(__int_type __i) noexcept       { return __atomic_or_fetch(&_M_i, __i, memory_order_seq_cst); }       __int_type       operator|=(__int_type __i) volatile noexcept       { return __atomic_or_fetch(&_M_i, __i, memory_order_seq_cst); }       __int_type       operator^=(__int_type __i) noexcept       { return __atomic_xor_fetch(&_M_i, __i, memory_order_seq_cst); }       __int_type       operator^=(__int_type __i) volatile noexcept       { return __atomic_xor_fetch(&_M_i, __i, memory_order_seq_cst); }       bool       is_lock_free() const noexcept       {  return __atomic_is_lock_free(sizeof(_M_i),      reinterpret_cast<void *>(-__alignof(_M_i)));       }       bool       is_lock_free() const volatile noexcept       {  return __atomic_is_lock_free(sizeof(_M_i),      reinterpret_cast<void *>(-__alignof(_M_i)));       }       inline __attribute__((__always_inline__)) void       store(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept       {         memory_order __b = __m & __memory_order_mask;                                               ;                                               ;                                               ;  __atomic_store_n(&_M_i, __i, __m);       }       inline __attribute__((__always_inline__)) void       store(__int_type __i,      memory_order __m = memory_order_seq_cst) volatile noexcept       {         memory_order __b = __m & __memory_order_mask;                                               ;                                               ;                                               ;  __atomic_store_n(&_M_i, __i, __m);       }       inline __attribute__((__always_inline__)) __int_type       load(memory_order __m = memory_order_seq_cst) const noexcept       {        memory_order __b = __m & __memory_order_mask;                                               ;                                               ;  return __atomic_load_n(&_M_i, __m);       }       inline __attribute__((__always_inline__)) __int_type       load(memory_order __m = memory_order_seq_cst) const volatile noexcept       {         memory_order __b = __m & __memory_order_mask;                                               ;                                               ;  return __atomic_load_n(&_M_i, __m);       }       inline __attribute__((__always_inline__)) __int_type       exchange(__int_type __i,         memory_order __m = memory_order_seq_cst) noexcept       {  return __atomic_exchange_n(&_M_i, __i, __m);       }       inline __attribute__((__always_inline__)) __int_type       exchange(__int_type __i,         memory_order __m = memory_order_seq_cst) volatile noexcept       {  return __atomic_exchange_n(&_M_i, __i, __m);       }       inline __attribute__((__always_inline__)) bool       compare_exchange_weak(__int_type& __i1, __int_type __i2,        memory_order __m1, memory_order __m2) noexcept       {        memory_order __b2 = __m2 & __memory_order_mask;        memory_order __b1 = __m1 & __memory_order_mask;                                                ;                                                ;                                ;  return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1, __m1, __m2);       }       inline __attribute__((__always_inline__)) bool       compare_exchange_weak(__int_type& __i1, __int_type __i2,        memory_order __m1,        memory_order __m2) volatile noexcept       {        memory_order __b2 = __m2 & __memory_order_mask;        memory_order __b1 = __m1 & __memory_order_mask;                                                ;                                                ;                                ;  return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1, __m1, __m2);       }       inline __attribute__((__always_inline__)) bool       compare_exchange_weak(__int_type& __i1, __int_type __i2,        memory_order __m = memory_order_seq_cst) noexcept       {  return compare_exchange_weak(__i1, __i2, __m,          __cmpexch_failure_order(__m));       }       inline __attribute__((__always_inline__)) bool       compare_exchange_weak(__int_type& __i1, __int_type __i2,      memory_order __m = memory_order_seq_cst) volatile noexcept       {  return compare_exchange_weak(__i1, __i2, __m,          __cmpexch_failure_order(__m));       }       inline __attribute__((__always_inline__)) bool       compare_exchange_strong(__int_type& __i1, __int_type __i2,          memory_order __m1, memory_order __m2) noexcept       {         memory_order __b2 = __m2 & __memory_order_mask;         memory_order __b1 = __m1 & __memory_order_mask;                                                ;                                                ;                                ;  return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0, __m1, __m2);       }       inline __attribute__((__always_inline__)) bool       compare_exchange_strong(__int_type& __i1, __int_type __i2,          memory_order __m1,          memory_order __m2) volatile noexcept       {         memory_order __b2 = __m2 & __memory_order_mask;         memory_order __b1 = __m1 & __memory_order_mask;                                                ;                                                ;                                ;  return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0, __m1, __m2);       }       inline __attribute__((__always_inline__)) bool       compare_exchange_strong(__int_type& __i1, __int_type __i2,          memory_order __m = memory_order_seq_cst) noexcept       {  return compare_exchange_strong(__i1, __i2, __m,            __cmpexch_failure_order(__m));       }       inline __attribute__((__always_inline__)) bool       compare_exchange_strong(__int_type& __i1, __int_type __i2,    memory_order __m = memory_order_seq_cst) volatile noexcept       {  return compare_exchange_strong(__i1, __i2, __m,            __cmpexch_failure_order(__m));       }       inline __attribute__((__always_inline__)) __int_type       fetch_add(__int_type __i,   memory_order __m = memory_order_seq_cst) noexcept       { return __atomic_fetch_add(&_M_i, __i, __m); }       inline __attribute__((__always_inline__)) __int_type       fetch_add(__int_type __i,   memory_order __m = memory_order_seq_cst) volatile noexcept       { return __atomic_fetch_add(&_M_i, __i, __m); }       inline __attribute__((__always_inline__)) __int_type       fetch_sub(__int_type __i,   memory_order __m = memory_order_seq_cst) noexcept       { return __atomic_fetch_sub(&_M_i, __i, __m); }       inline __attribute__((__always_inline__)) __int_type       fetch_sub(__int_type __i,   memory_order __m = memory_order_seq_cst) volatile noexcept       { return __atomic_fetch_sub(&_M_i, __i, __m); }       inline __attribute__((__always_inline__)) __int_type       fetch_and(__int_type __i,   memory_order __m = memory_order_seq_cst) noexcept       { return __atomic_fetch_and(&_M_i, __i, __m); }       inline __attribute__((__always_inline__)) __int_type       fetch_and(__int_type __i,   memory_order __m = memory_order_seq_cst) volatile noexcept       { return __atomic_fetch_and(&_M_i, __i, __m); }       inline __attribute__((__always_inline__)) __int_type       fetch_or(__int_type __i,         memory_order __m = memory_order_seq_cst) noexcept       { return __atomic_fetch_or(&_M_i, __i, __m); }       inline __attribute__((__always_inline__)) __int_type       fetch_or(__int_type __i,         memory_order __m = memory_order_seq_cst) volatile noexcept       { return __atomic_fetch_or(&_M_i, __i, __m); }       inline __attribute__((__always_inline__)) __int_type       fetch_xor(__int_type __i,   memory_order __m = memory_order_seq_cst) noexcept       { return __atomic_fetch_xor(&_M_i, __i, __m); }       inline __attribute__((__always_inline__)) __int_type       fetch_xor(__int_type __i,   memory_order __m = memory_order_seq_cst) volatile noexcept       { return __atomic_fetch_xor(&_M_i, __i, __m); }     };   template<typename _PTp>     struct __atomic_base<_PTp*>     {     private:       typedef _PTp* __pointer_type;       __pointer_type _M_p;       constexpr ptrdiff_t       _M_type_size(ptrdiff_t __d) const { return __d * sizeof(_PTp); }       constexpr ptrdiff_t       _M_type_size(ptrdiff_t __d) const volatile { return __d * sizeof(_PTp); }     public:       __atomic_base() noexcept = default;                                   constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }       operator __pointer_type() const noexcept       { return load(); }       operator __pointer_type() const volatile noexcept       { return load(); }       __pointer_type       operator=(__pointer_type __p) noexcept       {  store(__p);  return __p;       }       __pointer_type       operator=(__pointer_type __p) volatile noexcept       {  store(__p);  return __p;       }       __pointer_type       operator++(int) noexcept       { return fetch_add(1); }       __pointer_type       operator++(int) volatile noexcept       { return fetch_add(1); }       __pointer_type       operator--(int) noexcept       { return fetch_sub(1); }       __pointer_type       operator--(int) volatile noexcept       { return fetch_sub(1); }       __pointer_type       operator++() noexcept       { return __atomic_add_fetch(&_M_p, _M_type_size(1),       memory_order_seq_cst); }       __pointer_type       operator++() volatile noexcept       { return __atomic_add_fetch(&_M_p, _M_type_size(1),       memory_order_seq_cst); }       __pointer_type       operator--() noexcept       { return __atomic_sub_fetch(&_M_p, _M_type_size(1),       memory_order_seq_cst); }       __pointer_type       operator--() volatile noexcept       { return __atomic_sub_fetch(&_M_p, _M_type_size(1),       memory_order_seq_cst); }       __pointer_type       operator+=(ptrdiff_t __d) noexcept       { return __atomic_add_fetch(&_M_p, _M_type_size(__d),       memory_order_seq_cst); }       __pointer_type       operator+=(ptrdiff_t __d) volatile noexcept       { return __atomic_add_fetch(&_M_p, _M_type_size(__d),       memory_order_seq_cst); }       __pointer_type       operator-=(ptrdiff_t __d) noexcept       { return __atomic_sub_fetch(&_M_p, _M_type_size(__d),       memory_order_seq_cst); }       __pointer_type       operator-=(ptrdiff_t __d) volatile noexcept       { return __atomic_sub_fetch(&_M_p, _M_type_size(__d),       memory_order_seq_cst); }       bool       is_lock_free() const noexcept       {  return __atomic_is_lock_free(sizeof(_M_p),      reinterpret_cast<void *>(-__alignof(_M_p)));       }       bool       is_lock_free() const volatile noexcept       {  return __atomic_is_lock_free(sizeof(_M_p),      reinterpret_cast<void *>(-__alignof(_M_p)));       }       inline __attribute__((__always_inline__)) void       store(__pointer_type __p,      memory_order __m = memory_order_seq_cst) noexcept       {         memory_order __b = __m & __memory_order_mask;                                               ;                                               ;                                               ;  __atomic_store_n(&_M_p, __p, __m);       }       inline __attribute__((__always_inline__)) void       store(__pointer_type __p,      memory_order __m = memory_order_seq_cst) volatile noexcept       {         memory_order __b = __m & __memory_order_mask;                                               ;                                               ;                                               ;  __atomic_store_n(&_M_p, __p, __m);       }       inline __attribute__((__always_inline__)) __pointer_type       load(memory_order __m = memory_order_seq_cst) const noexcept       {         memory_order __b = __m & __memory_order_mask;                                               ;                                               ;  return __atomic_load_n(&_M_p, __m);       }       inline __attribute__((__always_inline__)) __pointer_type       load(memory_order __m = memory_order_seq_cst) const volatile noexcept       {         memory_order __b = __m & __memory_order_mask;                                               ;                                               ;  return __atomic_load_n(&_M_p, __m);       }       inline __attribute__((__always_inline__)) __pointer_type       exchange(__pointer_type __p,         memory_order __m = memory_order_seq_cst) noexcept       {  return __atomic_exchange_n(&_M_p, __p, __m);       }       inline __attribute__((__always_inline__)) __pointer_type       exchange(__pointer_type __p,         memory_order __m = memory_order_seq_cst) volatile noexcept       {  return __atomic_exchange_n(&_M_p, __p, __m);       }       inline __attribute__((__always_inline__)) bool       compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,          memory_order __m1,          memory_order __m2) noexcept       {         memory_order __b2 = __m2 & __memory_order_mask;         memory_order __b1 = __m1 & __memory_order_mask;                                                ;                                                ;                                ;  return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0, __m1, __m2);       }       inline __attribute__((__always_inline__)) bool       compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,          memory_order __m1,          memory_order __m2) volatile noexcept       {         memory_order __b2 = __m2 & __memory_order_mask;         memory_order __b1 = __m1 & __memory_order_mask;                                                ;                                                ;                                ;  return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0, __m1, __m2);       }       inline __attribute__((__always_inline__)) __pointer_type       fetch_add(ptrdiff_t __d,   memory_order __m = memory_order_seq_cst) noexcept       { return __atomic_fetch_add(&_M_p, _M_type_size(__d), __m); }       inline __attribute__((__always_inline__)) __pointer_type       fetch_add(ptrdiff_t __d,   memory_order __m = memory_order_seq_cst) volatile noexcept       { return __atomic_fetch_add(&_M_p, _M_type_size(__d), __m); }       inline __attribute__((__always_inline__)) __pointer_type       fetch_sub(ptrdiff_t __d,   memory_order __m = memory_order_seq_cst) noexcept       { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), __m); }       inline __attribute__((__always_inline__)) __pointer_type       fetch_sub(ptrdiff_t __d,   memory_order __m = memory_order_seq_cst) volatile noexcept       { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), __m); }     }; }
namespace mozilla { namespace detail { template<MemoryOrdering Order> struct AtomicOrderConstraints; template<> struct AtomicOrderConstraints<Relaxed> {   static const std::memory_order AtomicRMWOrder = std::memory_order_relaxed;   static const std::memory_order LoadOrder = std::memory_order_relaxed;   static const std::memory_order StoreOrder = std::memory_order_relaxed;   static const std::memory_order CompareExchangeFailureOrder =     std::memory_order_relaxed; }; template<> struct AtomicOrderConstraints<ReleaseAcquire> {   static const std::memory_order AtomicRMWOrder = std::memory_order_acq_rel;   static const std::memory_order LoadOrder = std::memory_order_acquire;   static const std::memory_order StoreOrder = std::memory_order_release;   static const std::memory_order CompareExchangeFailureOrder =     std::memory_order_acquire; }; template<> struct AtomicOrderConstraints<SequentiallyConsistent> {   static const std::memory_order AtomicRMWOrder = std::memory_order_seq_cst;   static const std::memory_order LoadOrder = std::memory_order_seq_cst;   static const std::memory_order StoreOrder = std::memory_order_seq_cst;   static const std::memory_order CompareExchangeFailureOrder =     std::memory_order_seq_cst; }; template<typename T, MemoryOrdering Order> struct IntrinsicBase {   typedef std::atomic<T> ValueType;   typedef AtomicOrderConstraints<Order> OrderedOp; }; template<typename T, MemoryOrdering Order> struct IntrinsicMemoryOps : public IntrinsicBase<T, Order> {   typedef IntrinsicBase<T, Order> Base;             }; template<typename T, MemoryOrdering Order> struct IntrinsicAddSub : public IntrinsicBase<T, Order> {   typedef IntrinsicBase<T, Order> Base;       }; template<typename T, MemoryOrdering Order> struct IntrinsicAddSub<T*, Order> : public IntrinsicBase<T*, Order> {   typedef IntrinsicBase<T*, Order> Base;       }; template<typename T, MemoryOrdering Order> struct IntrinsicIncDec : public IntrinsicAddSub<T, Order> {   typedef IntrinsicBase<T, Order> Base;       }; template<typename T, MemoryOrdering Order> struct AtomicIntrinsics : public IntrinsicMemoryOps<T, Order>,                           public IntrinsicIncDec<T, Order> {   typedef IntrinsicBase<T, Order> Base;          }; template<typename T, MemoryOrdering Order> struct AtomicIntrinsics<T*, Order>   : public IntrinsicMemoryOps<T*, Order>, public IntrinsicIncDec<T*, Order> { }; template<typename T> struct ToStorageTypeArgument {   static constexpr T convert (T aT) { return aT; } }; } }
# 533 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Atomics.h"
namespace mozilla { namespace detail { template<typename T, MemoryOrdering Order> class AtomicBase {    protected:   typedef typename detail::AtomicIntrinsics<T, Order> Intrinsics;   typedef typename Intrinsics::ValueType ValueType;   ValueType mValue; public:   constexpr AtomicBase() : mValue() {}   explicit constexpr AtomicBase(T aInit)     : mValue(ToStorageTypeArgument<T>::convert(aInit))   {}       
# 585 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Atomics.h"
   private:   template<MemoryOrdering AnyOrder>   AtomicBase(const AtomicBase<T, AnyOrder>& aCopy) = delete; }; template<typename T, MemoryOrdering Order> class AtomicBaseIncDec : public AtomicBase<T, Order> {   typedef typename detail::AtomicBase<T, Order> Base; public:   constexpr AtomicBaseIncDec() : Base() {}   explicit constexpr AtomicBaseIncDec(T aInit) : Base(aInit) {}   using Base::operator=;   operator T() const ;   T operator++(int) ;   T operator--(int) ;   T operator++() ;   T operator--() ; private:   template<MemoryOrdering AnyOrder>   AtomicBaseIncDec(const AtomicBaseIncDec<T, AnyOrder>& aCopy) = delete; }; } 
# 636 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Atomics.h"
template<typename T,          MemoryOrdering Order = SequentiallyConsistent,          typename Enable = void> class Atomic; 
# 649 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Atomics.h"
template<typename T, MemoryOrdering Order> class Atomic<T, Order, typename EnableIf<IsIntegral<T>::value &&                        !IsSame<T, bool>::value>::Type>   : public detail::AtomicBaseIncDec<T, Order> {   typedef typename detail::AtomicBaseIncDec<T, Order> Base; public:   constexpr Atomic() : Base() {}   explicit constexpr Atomic(T aInit) : Base(aInit) {}   using Base::operator=;   T operator+=(T aDelta)   ;             private:    }; 
template<MemoryOrdering Order> class Atomic<bool, Order>   : protected detail::AtomicBase<uint32_t, Order> {   typedef typename detail::AtomicBase<uint32_t, Order> Base; public:   constexpr Atomic() : Base() {}   explicit constexpr Atomic(bool aInit) : Base(aInit) {}                          private:    }; }
# 12 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/Utility.h" 2
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Scoped.h" 1
# 50 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Scoped.h"
namespace mozilla { 
# 67 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Scoped.h"
template<typename Traits> class Scoped { public:   typedef typename Traits::type Resource;                         
# 113 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Scoped.h"
# 141 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Scoped.h"
  Scoped& operator=(const Resource& aOther) ;   Scoped& reset(const Resource& aOther)   ;   Scoped& operator=(Scoped&& aRhs)   ; private:       private:   Resource mValue;   mozilla::detail::GuardObjectNotificationReceiver _mCheckNotUsedAsTemporary; }; 
# 236 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Scoped.h"
; template <typename T> struct TypeSpecificScopedPointerTraits {   typedef T* type;       }; template<typename Type> struct TypeSpecificScopedPointer : public mozilla::Scoped<TypeSpecificScopedPointerTraits<Type> > { typedef mozilla::Scoped<TypeSpecificScopedPointerTraits<Type> > Super; typedef typename Super::Resource Resource;      private:   }; }
 namespace JS { template<typename T> struct DeletePolicy {     constexpr DeletePolicy() {}          ;      }; struct FreePolicy {      }; typedef mozilla::UniquePtr<char[], JS::FreePolicy> UniqueChars; typedef mozilla::UniquePtr<char16_t[], JS::FreePolicy> UniqueTwoByteChars; }
 namespace js { typedef uint32_t HashNumber; const unsigned HashNumberSizeBits = 32; namespace detail { 
# 524 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/Utility.h"
 } }
# 16 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/HeapAPI.h" 2
namespace js {   namespace gc { struct Cell; const size_t ArenaShift = 12; const size_t ArenaSize = size_t(1) << ArenaShift; const size_t ArenaMask = ArenaSize - 1; const size_t ChunkShift = 20; const size_t ChunkSize = size_t(1) << ChunkShift; const size_t ChunkMask = ChunkSize - 1; const size_t CellShift = 3; const size_t CellSize = size_t(1) << CellShift; const size_t CellMask = CellSize - 1; const size_t ChunkMarkBitmapOffset = 1032352; const size_t ChunkMarkBitmapBits = 129024; const size_t ChunkRuntimeOffset = ChunkSize - sizeof(void*); const size_t ChunkTrailerSize = 2 * sizeof(uintptr_t) + sizeof(uint64_t); const size_t ChunkLocationOffset = ChunkSize - ChunkTrailerSize; const size_t ArenaZoneOffset = sizeof(size_t); const size_t ArenaHeaderSize = sizeof(size_t) + 2 * sizeof(uintptr_t) +                                sizeof(size_t) + sizeof(uintptr_t); static const uint32_t BLACK = 0; static const uint32_t GRAY = 1; enum class ChunkLocation : uint32_t {     Invalid = 0,     Nursery = 1,     TenuredHeap = 2 };   bool IsInsideNursery(const js::gc::Cell* cell); } }
 typedef enum JSGCMode {     JSGC_MODE_GLOBAL = 0,     JSGC_MODE_ZONE = 1,     JSGC_MODE_INCREMENTAL = 2 }
 JSGCMode;
 typedef enum JSGCInvocationKind {     GC_NORMAL = 0,     GC_SHRINK = 1 }
 JSGCInvocationKind;
 namespace JS { 
# 114 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/GCAPI.h"
 }
 namespace js { namespace gc {   ;  } }
 namespace JS {     }
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/TracingAPI.h" 1
# 10 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/TracingAPI.h"
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/jsalloc.h" 1
# 20 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/jsalloc.h"
namespace js { enum class AllocFunction {     Malloc,     Calloc,     Realloc }; class SystemAllocPolicy {   public:           ;      ;      ;      ;      ;                };  
# 60 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/jsalloc.h"
class TempAllocPolicy {     JSContext* const cx_;           ;   public:                        ;      ;      ;      ;      ;      ;                }; }
# 11 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/TracingAPI.h" 2
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/HashTable.h" 1
# 14 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/HashTable.h"
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/HashFunctions.h" 1
# 52 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/HashFunctions.h"
 static_assert(sizeof(u""[0]) == 2, "Is unicode string char 16 bits?");
# 53 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/HashFunctions.h" 2
namespace mozilla { static const uint32_t kGoldenRatioU32 = 0x9E3779B9U;   namespace detail {   ;   } 
class HashCodeScrambler {   struct SipHasher;   uint64_t mK0, mK1; public:   constexpr HashCodeScrambler(uint64_t aK0, uint64_t aK1) : mK0(aK0), mK1(aK1) {}    private:   struct SipHasher   {                    uint64_t mV0, mV1, mV2, mV3;   }; }; }
# 15 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/HashTable.h" 2
# 1 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Opaque.h" 1
# 14 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/mozilla/Opaque.h"
namespace mozilla { template<typename T> class Opaque final {      T mValue; public:             }; }
# 18 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/HashTable.h" 2
namespace js { class TempAllocPolicy; template <class> struct DefaultHasher; template <class, class> class HashMapEntry; namespace detail {     template <class T> class HashTableEntry;     template <class T, class HashPolicy, class AllocPolicy> class HashTable; } 
# 48 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/HashTable.h"
using Generation = mozilla::Opaque<uint64_t>; 
# 65 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/HashTable.h"
template <class Key,           class Value,           class HashPolicy = DefaultHasher<Key>,           class AllocPolicy = TempAllocPolicy> class HashMap {     typedef HashMapEntry<Key, Value> TableEntry;     struct MapHashPolicy : HashPolicy     {         using Base = HashPolicy;         typedef Key KeyType;                       };     typedef detail::HashTable<TableEntry, MapHashPolicy, AllocPolicy> Impl;     Impl impl;   public:     typedef typename HashPolicy::Lookup Lookup;     typedef TableEntry Entry;                
# 105 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/HashTable.h"
    typedef typename Impl::Enum Enum;                                                        ;      ;      ;                                 private:               friend class Impl::Enum; }; 
# 327 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/HashTable.h"
template <class T,           class HashPolicy = DefaultHasher<T>,           class AllocPolicy = TempAllocPolicy> class HashSet {     struct SetOps : HashPolicy     {         using Base = HashPolicy;         typedef T KeyType;                       };     typedef detail::HashTable<const T, SetOps, AllocPolicy> Impl;     Impl impl;   public:     typedef typename HashPolicy::Lookup Lookup;     typedef T Entry;                
# 443 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/HashTable.h"
    typedef typename Impl::Enum Enum;                                                        ;      ;      ;      ;                                 private:               friend class Impl::Enum; }; 
# 587 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/HashTable.h"
# 739 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/HashTable.h"
template <class Key, class Value> class HashMapEntry {     Key key_;     Value value_;     template <class, class, class> friend class detail::HashTable;     template <class> friend class detail::HashTableEntry;     template <class, class, class, class> friend class HashMap;   public:           ;               typedef Key KeyType;     typedef Value ValueType;                       private:           }; }
 namespace mozilla { template <typename T> struct IsPod<js::detail::HashTableEntry<T> > : IsPod<T> {}; template <typename K, typename V> struct IsPod<js::HashMapEntry<K, V> >   : IntegralConstant<bool, IsPod<K>::value && IsPod<V>::value> {}; }
# 13 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/TracingAPI.h" 2
class JSTracer;
 namespace JS { class CallbackTracer; template <typename T> class Heap; template <typename T> class TenuredHeap;   }
 enum WeakMapTraceKind {     DoNotTraceWeakMaps,     ExpandWeakMaps,     TraceWeakMapValues,     TraceWeakMapKeysValues };
 class JSTracer {   public:               enum class TracerKindTag {         Marking,         WeakMarking,         Tenuring,         Callback     };                         ;             protected:             private:     JSRuntime* runtime_;     WeakMapTraceKind weakMapAction_;     bool checkEdges_;   protected:     TracerKindTag tag_;     bool traceWeakEdges_; };
 namespace JS { class AutoTracingName; class AutoTracingIndex; class AutoTracingCallback; class CallbackTracer : public JSTracer {   public:                                                                       
# 195 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/TracingAPI.h"
         const static size_t InvalidIndex = size_t(-1);               class ContextFunctor {       public:              };     enum class TracerKind { DoNotCare, Moving, GrayBuffering, VerifyTraceProtoAndIface };                                                               protected:        private:     friend class AutoTracingName;     const char* contextName_;     friend class AutoTracingIndex;     size_t contextIndex_;     friend class AutoTracingDetails;     ContextFunctor* contextFunctor_; }; class AutoTracingName {     CallbackTracer* trc_;     const char* prior_;   public:           }; class AutoTracingIndex {     CallbackTracer* trc_;   public:                }; class AutoTracingDetails {     CallbackTracer* trc_;   public:           }; }
  namespace JS { 
# 350 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/TracingAPI.h"
;  ;  using ZoneSet = js::HashSet<Zone*, js::DefaultHasher<Zone*>, js::SystemAllocPolicy>; using CompartmentSet = js::HashSet<JSCompartment*, js::DefaultHasher<JSCompartment*>,                                    js::SystemAllocPolicy>;  }
  namespace js { ; namespace gc { ; ; } }
# 47 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/GCPolicyAPI.h" 2
# 65 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/GCPolicyAPI.h"
class JSAtom;
 class JSString;
 namespace JS { class Symbol; }
 namespace JS { template <typename T> struct StructGCPolicy {                     }; template <typename T> struct GCPolicy : public StructGCPolicy<T> {}; template <typename T> struct IgnoreGCPolicy {                }; template <> struct GCPolicy<uint32_t> : public IgnoreGCPolicy<uint32_t> {}; template <> struct GCPolicy<uint64_t> : public IgnoreGCPolicy<uint64_t> {}; template <typename T> struct GCPointerPolicy {                }; template <> struct GCPolicy<JS::Symbol*> : public GCPointerPolicy<JS::Symbol*> {}; template <> struct GCPolicy<JSAtom*> : public GCPointerPolicy<JSAtom*> {}; template <> struct GCPolicy<JSFunction*> : public GCPointerPolicy<JSFunction*> {}; template <> struct GCPolicy<JSObject*> : public GCPointerPolicy<JSObject*> {}; template <> struct GCPolicy<JSScript*> : public GCPointerPolicy<JSScript*> {}; template <> struct GCPolicy<JSString*> : public GCPointerPolicy<JSString*> {}; template <typename T> struct GCPolicy<JS::Heap<T>> {           }; template <typename T, typename D> struct GCPolicy<mozilla::UniquePtr<T, D>> {                }; }
# 24 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/RootingAPI.h" 2
# 110 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/RootingAPI.h"
namespace js { template <typename T> struct BarrierMethods { }; template <typename Element, typename Wrapper> class WrappedPtrOperations {}; template <typename Element, typename Wrapper> class MutableWrappedPtrOperations : public WrappedPtrOperations<Element, Wrapper> {}; template <typename T, typename Wrapper> class RootedBase : public MutableWrappedPtrOperations<T, Wrapper> {}; template <typename T, typename Wrapper> class HandleBase : public WrappedPtrOperations<T, Wrapper> {}; template <typename T, typename Wrapper> class MutableHandleBase : public MutableWrappedPtrOperations<T, Wrapper> {}; template <typename T, typename Wrapper> class HeapBase : public MutableWrappedPtrOperations<T, Wrapper> {}; template <typename T> struct IsHeapConstructibleType { static constexpr bool value = false; }; template <> struct IsHeapConstructibleType<JS::Symbol*> { static constexpr bool value = true; }; template <> struct IsHeapConstructibleType<JSAtom*> { static constexpr bool value = true; }; template <> struct IsHeapConstructibleType<JSFunction*> { static constexpr bool value = true; }; template <> struct IsHeapConstructibleType<JSObject*> { static constexpr bool value = true; }; template <> struct IsHeapConstructibleType<JSScript*> { static constexpr bool value = true; }; template <> struct IsHeapConstructibleType<JSString*> { static constexpr bool value = true; }; template <> struct IsHeapConstructibleType<JS::Value> { static constexpr bool value = true; }; template <> struct IsHeapConstructibleType<jsid> { static constexpr bool value = true; }; template <typename T, typename Wrapper> class PersistentRootedBase : public MutableWrappedPtrOperations<T, Wrapper> {}; namespace gc { struct Cell; template<typename T> struct PersistentRootedMarker; } 
# 182 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/RootingAPI.h"
}
 namespace JS { template <typename T> class Rooted; template <typename T> class PersistentRooted;       
# 229 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/RootingAPI.h"
template <typename T> class Heap : public js::HeapBase<T, Heap<T>> {        public:     using ElementType = T;                          ;      ;          void exposeToActiveJS() const ;                            private:                    T ptr; };           
# 380 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/RootingAPI.h"
template <typename T> class TenuredHeap : public js::HeapBase<T, TenuredHeap<T>> {   public:     using ElementType = T;                                                                                        private:     enum {         maskBits = 3,         flagsMask = (1 << maskBits) - 1,     };     uintptr_t bits; }; 
# 463 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/RootingAPI.h"
template <typename T> class Handle : public js::HandleBase<T, Handle<T>> {     friend class JS::MutableHandle<T>;   public:     using ElementType = T;          ;                                     
# 507 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/RootingAPI.h"
    static constexpr Handle fromMarkedLocation(const T* p) {         return Handle(p, DeliberatelyChoosingThisOverload,                       ImUsingThisOnlyInFromFromMarkedLocation);     }     template <typename S>     inline                  Handle(const Rooted<S>& root,                         typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy = 0);     ;     ;      ;      ;   private:          template <typename S> Handle<T>& operator=(S) = delete; Handle<T>& operator=(const Handle<T>&) = delete;;     enum Disambiguator { DeliberatelyChoosingThisOverload = 42 };     enum CallerIdentity { ImUsingThisOnlyInFromFromMarkedLocation = 17 };     constexpr Handle(const T* p, Disambiguator, CallerIdentity) : ptr(p) {}     const T* ptr; }; 
# 554 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/RootingAPI.h"
template <typename T> class MutableHandle : public js::MutableHandleBase<T, MutableHandle<T>> {   public:     using ElementType = T;     inline MutableHandle(Rooted<T>* root);     inline MutableHandle(PersistentRooted<T>* root);   private:     MutableHandle(decltype(nullptr)) = delete;   public:     void set(const T& v) ; 
# 579 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/RootingAPI.h"
    static MutableHandle fromMarkedLocation(T* p) ;     operator const T&() const ; const T& operator->() const ;;     const T* address() const ; const T& get() const ;;     T* address() ; T& get() ;;   private:     MutableHandle() ;     template <typename S> MutableHandle<T>& operator=(S) = delete; MutableHandle<T>& operator=(const MutableHandle<T>&) = delete;;     T* ptr; }; }
 namespace js { 
# 722 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/RootingAPI.h"
template <typename T> class alignas(8) DispatchWrapper {     static_assert(JS::MapTypeToRootKind<T>::kind == JS::RootKind::Traceable,                   "DispatchWrapper is intended only for usage with a Traceable");     using TraceFn = void (*)(JSTracer*, T*, const char*);     TraceFn tracer;     alignas(gc::CellSize) T storage;   public:     template <typename U>                  DispatchWrapper(U&& initial)       : tracer(&JS::GCPolicy<T>::trace),         storage(mozilla::Forward<U>(initial))     { }     T* operator &() { return &storage; }     const T* operator &() const { return &storage; }     operator T&() { return storage; }     operator const T&() const { return storage; }     static void TraceWrapped(JSTracer* trc, T* thingp, const char* name) {         auto wrapper = reinterpret_cast<DispatchWrapper*>(                            uintptr_t(thingp) - __builtin_offsetof(DispatchWrapper, storage));         wrapper->tracer(trc, &wrapper->storage, name);     } }; }
 namespace JS { namespace detail { 
# 768 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/RootingAPI.h"
template <typename T> using MaybeWrapped = typename mozilla::Conditional<     MapTypeToRootKind<T>::kind == JS::RootKind::Traceable,     js::DispatchWrapper<T>,     T>::Type; } 
# 784 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/RootingAPI.h"
template <typename T> class Rooted : public js::RootedBase<T, Rooted<T>> {                   public:     using ElementType = T;                               ;      ;      ;      ;   private:     Rooted<void*>** stack;     Rooted<void*>* prev;     detail::MaybeWrapped<T> ptr;      } ; }
 namespace js { 
template <typename Container> class HandleBase<JSObject*, Container> : public WrappedPtrOperations<JSObject*, Container> {   public:     ; }; template <typename T> class FakeRooted : public RootedBase<T, FakeRooted<T>> {   public:     using ElementType = T;       ;       ;      ;      ;      ;      ;   private:     T ptr;           }; template <typename T> class FakeMutableHandle : public js::MutableHandleBase<T, FakeMutableHandle<T>> {   public:     using ElementType = T;                                               const T& operator->() const ;;     const T* address() const ; const T& get() const ;;     T* address() ; T& get() ;;   private:     FakeMutableHandle() ;     template <typename S> FakeMutableHandle<T>& operator=(S) = delete; FakeMutableHandle<T>& operator=(const FakeMutableHandle<T>&) = delete;;     T* ptr; }; 
# 958 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/RootingAPI.h"
enum AllowGC {     NoGC = 0,     CanGC = 1 }; template <typename T, AllowGC allowGC> class MaybeRooted { }; template <typename T> class MaybeRooted<T, CanGC> {   public:     typedef JS::Handle<T> HandleType;     typedef JS::Rooted<T> RootType;     typedef JS::MutableHandle<T> MutableHandleType;     static JS::Handle<T> toHandle(HandleType v) ;     static JS::MutableHandle<T> toMutableHandle(MutableHandleType v) ;     template <typename T2>     static JS::Handle<T2*> downcastHandle(HandleType v) ; }; template <typename T> class MaybeRooted<T, NoGC> {   public:     typedef const T& HandleType;     typedef FakeRooted<T> RootType;     typedef FakeMutableHandle<T> MutableHandleType;     static JS::Handle<T> toHandle(HandleType v) ;     static JS::MutableHandle<T> toMutableHandle(MutableHandleType v) ;     template <typename T2>     static inline T2* downcastHandle(HandleType v) {         return &v->template as<T2>();     } }; }
 namespace JS { template <typename T> template <typename S> inline Handle<T>::Handle(const Rooted<S>& root,                   typename mozilla::EnableIf<mozilla::IsConvertible<S, T>::value, int>::Type dummy) {     ptr = reinterpret_cast<const T*>(root.address()); }   template <typename T> inline MutableHandle<T>::MutableHandle(Rooted<T>* root) {     static_assert(sizeof(MutableHandle<T>) == sizeof(T*),                   "MutableHandle must be binary compatible with T*.");     ptr = root->address(); } template <typename T> inline MutableHandle<T>::MutableHandle(PersistentRooted<T>* root) {     static_assert(sizeof(MutableHandle<T>) == sizeof(T*),                   "MutableHandle must be binary compatible with T*.");     ptr = root->address(); }  void AddPersistentRoot(RootingContext* cx, RootKind kind, PersistentRooted<void*>* root);  void AddPersistentRoot(JSRuntime* rt, RootKind kind, PersistentRooted<void*>* root); 
# 1095 "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/RootingAPI.h"
template<typename T> class PersistentRooted : public js::RootedBase<T, PersistentRooted<T>>,                          private mozilla::LinkedListElement<PersistentRooted<T>> {     using ListBase = mozilla::LinkedListElement<PersistentRooted<T>>;     friend class mozilla::LinkedList<PersistentRooted>;     friend class mozilla::LinkedListElement<PersistentRooted>;     void registerWithRootLists(RootingContext* cx) {         do { static_assert(mozilla::detail::AssertionConditionType<decltype(!initialized())>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(!initialized()))), 0))) { MOZ_ReportAssertionFailure("!initialized()", "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/RootingAPI.h", 1105); do { } while (0); do { *((volatile int*) __null) = 1105; ::abort(); } while (0); } } while (0);         JS::RootKind kind = JS::MapTypeToRootKind<T>::kind;         AddPersistentRoot(cx, kind, reinterpret_cast<JS::PersistentRooted<void*>*>(this));     }     void registerWithRootLists(JSRuntime* rt) {         do { static_assert(mozilla::detail::AssertionConditionType<decltype(!initialized())>::isValid, "invalid assertion condition"); if ((__builtin_expect(!!(!(!!(!initialized()))), 0))) { MOZ_ReportAssertionFailure("!initialized()", "/home/fitzgen/stylo/obj-x86_64-pc-linux-gnu/dist/include/js/RootingAPI.h", 1111); do { } while (0); do { *((volatile int*) __null) = 1111; ::abort(); } while (0); } } while (0);         JS::RootKind kind = JS::MapTypeToRootKind<T>::kind;         AddPersistentRoot(rt, kind, reinterpret_cast<JS::PersistentRooted<void*>*>(this));     }   public:     using ElementType = T;     PersistentRooted() : ptr(GCPolicy<T>::initial()) {}                                        bool initialized() {         return ListBase::isInList();     }           ;           ;      ;      ;             private:          detail::MaybeWrapped<T> ptr; } ; class ObjectPtr {     Heap<JSObject*> value;   public:     using ElementType = JSObject*;                                                                                      }; }
